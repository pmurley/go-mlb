// Package mlb provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package gen

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "basicAuth.Scopes"
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AggregateSortTypeEnum.
const (
	Avg     AggregateSortTypeEnum = "avg"
	Comp    AggregateSortTypeEnum = "comp"
	Max     AggregateSortTypeEnum = "max"
	Min     AggregateSortTypeEnum = "min"
	Num     AggregateSortTypeEnum = "num"
	NumComp AggregateSortTypeEnum = "num_comp"
	P50     AggregateSortTypeEnum = "p50"
	P75     AggregateSortTypeEnum = "p75"
	P90     AggregateSortTypeEnum = "p90"
)

// Defines values for AllStarEnum.
const (
	F AllStarEnum = "F"
	I AllStarEnum = "I"
	N AllStarEnum = "N"
	O AllStarEnum = "O"
	T AllStarEnum = "T"
	Y AllStarEnum = "Y"
)

// Defines values for BaseballPosition.
const (
	BaseballPositionBASERUNNER              BaseballPosition = "BASE_RUNNER"
	BaseballPositionBATTER                  BaseballPosition = "BATTER"
	BaseballPositionCATCHER                 BaseballPosition = "CATCHER"
	BaseballPositionCENTERFIELD             BaseballPosition = "CENTER_FIELD"
	BaseballPositionCLOSER                  BaseballPosition = "CLOSER"
	BaseballPositionDESIGNATEDHITTER        BaseballPosition = "DESIGNATED_HITTER"
	BaseballPositionEXTRAHITTER             BaseballPosition = "EXTRA_HITTER"
	BaseballPositionFIRSTBASE               BaseballPosition = "FIRST_BASE"
	BaseballPositionINFIELD                 BaseballPosition = "INFIELD"
	BaseballPositionLEFTFIELD               BaseballPosition = "LEFT_FIELD"
	BaseballPositionLEFTHANDEDPITCHER       BaseballPosition = "LEFT_HANDED_PITCHER"
	BaseballPositionLEFTHANDEDRELIEVER      BaseballPosition = "LEFT_HANDED_RELIEVER"
	BaseballPositionLEFTHANDEDSTARTER       BaseballPosition = "LEFT_HANDED_STARTER"
	BaseballPositionOUTFIELD                BaseballPosition = "OUTFIELD"
	BaseballPositionPINCHHITTER             BaseballPosition = "PINCH_HITTER"
	BaseballPositionPINCHRUNNER             BaseballPosition = "PINCH_RUNNER"
	BaseballPositionPITCHER                 BaseballPosition = "PITCHER"
	BaseballPositionRELIEFPITCHER           BaseballPosition = "RELIEF_PITCHER"
	BaseballPositionRIGHTFIELD              BaseballPosition = "RIGHT_FIELD"
	BaseballPositionRIGHTHANDEDPITCHER      BaseballPosition = "RIGHT_HANDED_PITCHER"
	BaseballPositionRIGHTHANDEDRELIEVER     BaseballPosition = "RIGHT_HANDED_RELIEVER"
	BaseballPositionRIGHTHANDEDSTARTER      BaseballPosition = "RIGHT_HANDED_STARTER"
	BaseballPositionRUNNERONFIRST           BaseballPosition = "RUNNER_ON_FIRST"
	BaseballPositionRUNNERONSECOND          BaseballPosition = "RUNNER_ON_SECOND"
	BaseballPositionRUNNERONTHIRD           BaseballPosition = "RUNNER_ON_THIRD"
	BaseballPositionSECONDBASE              BaseballPosition = "SECOND_BASE"
	BaseballPositionSHORTSTOP               BaseballPosition = "SHORTSTOP"
	BaseballPositionSTARTINGPITCHER         BaseballPosition = "STARTING_PITCHER"
	BaseballPositionTHIRDBASE               BaseballPosition = "THIRD_BASE"
	BaseballPositionTWOWAYPITCHERINFIELDER  BaseballPosition = "TWO_WAY_PITCHER_INFIELDER"
	BaseballPositionTWOWAYPITCHEROUTFIELDER BaseballPosition = "TWO_WAY_PITCHER_OUTFIELDER"
	BaseballPositionTWOWAYPITCHERUTILITY    BaseballPosition = "TWO_WAY_PITCHER_UTILITY"
	BaseballPositionTWOWAYPLAYER            BaseballPosition = "TWO_WAY_PLAYER"
	BaseballPositionUNKNOWN                 BaseballPosition = "UNKNOWN"
	BaseballPositionUTLITY                  BaseballPosition = "UTLITY"
	BaseballPositionUTLITYINFIELDER         BaseballPosition = "UTLITY_INFIELDER"
	BaseballPositionUTLITYOUTFIELDER        BaseballPosition = "UTLITY_OUTFIELDER"
)

// Defines values for BaseballStatsEnum.
const (
	BaseballStatsEnumACCELERATION                        BaseballStatsEnum = "ACCELERATION"
	BaseballStatsEnumAIROUTS                             BaseballStatsEnum = "AIROUTS"
	BaseballStatsEnumARMSTRENGTH                         BaseballStatsEnum = "ARM_STRENGTH"
	BaseballStatsEnumASSISTS                             BaseballStatsEnum = "ASSISTS"
	BaseballStatsEnumATBATS                              BaseballStatsEnum = "AT_BATS"
	BaseballStatsEnumATBATSPERHOMERUN                    BaseballStatsEnum = "AT_BATS_PER_HOMERUN"
	BaseballStatsEnumATTACKANGLE                         BaseballStatsEnum = "ATTACK_ANGLE"
	BaseballStatsEnumATTENDANCE                          BaseballStatsEnum = "ATTENDANCE"
	BaseballStatsEnumBALK                                BaseballStatsEnum = "BALK"
	BaseballStatsEnumBARRELS                             BaseballStatsEnum = "BARRELS"
	BaseballStatsEnumBASERUNNINGRUNSABOVEAVG             BaseballStatsEnum = "BASE_RUNNING_RUNS_ABOVE_AVG"
	BaseballStatsEnumBATSPEED                            BaseballStatsEnum = "BAT_SPEED"
	BaseballStatsEnumBATTINGAVERAGE                      BaseballStatsEnum = "BATTING_AVERAGE"
	BaseballStatsEnumBATTINGAVERAGEBALLSINPLAY           BaseballStatsEnum = "BATTING_AVERAGE_BALLS_IN_PLAY"
	BaseballStatsEnumBATTINGRUNSABOVEAVG                 BaseballStatsEnum = "BATTING_RUNS_ABOVE_AVG"
	BaseballStatsEnumBEQUEATHEDRUNNERS                   BaseballStatsEnum = "BEQUEATHED_RUNNERS"
	BaseballStatsEnumBEQUEATHEDRUNNERSSCORED             BaseballStatsEnum = "BEQUEATHED_RUNNERS_SCORED"
	BaseballStatsEnumBLOWNSAVES                          BaseballStatsEnum = "BLOWN_SAVES"
	BaseballStatsEnumBURST                               BaseballStatsEnum = "BURST"
	BaseballStatsEnumBURSTDISTANCE                       BaseballStatsEnum = "BURST_DISTANCE"
	BaseballStatsEnumCATCHERERA                          BaseballStatsEnum = "CATCHER_ERA"
	BaseballStatsEnumCATCHERSINTERFERENCE                BaseballStatsEnum = "CATCHERS_INTERFERENCE"
	BaseballStatsEnumCATCHPROBABILITY                    BaseballStatsEnum = "CATCH_PROBABILITY"
	BaseballStatsEnumCAUGHTSTEALING                      BaseballStatsEnum = "CAUGHT_STEALING"
	BaseballStatsEnumCHANCES                             BaseballStatsEnum = "CHANCES"
	BaseballStatsEnumCOMPLETEGAME                        BaseballStatsEnum = "COMPLETE_GAME"
	BaseballStatsEnumDISTANCECOVERED                     BaseballStatsEnum = "DISTANCE_COVERED"
	BaseballStatsEnumDOUBLEPLAYS                         BaseballStatsEnum = "DOUBLE_PLAYS"
	BaseballStatsEnumDOUBLES                             BaseballStatsEnum = "DOUBLES"
	BaseballStatsEnumDURATION                            BaseballStatsEnum = "DURATION"
	BaseballStatsEnumEARNEDRUN                           BaseballStatsEnum = "EARNED_RUN"
	BaseballStatsEnumEARNEDRUNAVERAGE                    BaseballStatsEnum = "EARNED_RUN_AVERAGE"
	BaseballStatsEnumENDOFAPPEARANCEAVERAGELEVERAGEINDEX BaseballStatsEnum = "END_OF_APPEARANCE_AVERAGE_LEVERAGE_INDEX"
	BaseballStatsEnumERAMINUS                            BaseballStatsEnum = "ERA_MINUS"
	BaseballStatsEnumERRORS                              BaseballStatsEnum = "ERRORS"
	BaseballStatsEnumEXCHANGE                            BaseballStatsEnum = "EXCHANGE"
	BaseballStatsEnumEXITVELOCITY                        BaseballStatsEnum = "EXIT_VELOCITY"
	BaseballStatsEnumEXPECTEDFIELDINGINDEPENDENTPITCHING BaseballStatsEnum = "EXPECTED_FIELDING_INDEPENDENT_PITCHING"
	BaseballStatsEnumEXTENSION                           BaseballStatsEnum = "EXTENSION"
	BaseballStatsEnumEXTRABASEHITS                       BaseballStatsEnum = "EXTRA_BASE_HITS"
	BaseballStatsEnumFIELDERBURSTDISTANCE                BaseballStatsEnum = "FIELDER_BURST_DISTANCE"
	BaseballStatsEnumFIELDERJUMPDISTANCE                 BaseballStatsEnum = "FIELDER_JUMP_DISTANCE"
	BaseballStatsEnumFIELDERREACTIONDISTANCE             BaseballStatsEnum = "FIELDER_REACTION_DISTANCE"
	BaseballStatsEnumFIELDINGINDEPENDENTPITCHING         BaseballStatsEnum = "FIELDING_INDEPENDENT_PITCHING"
	BaseballStatsEnumFIELDINGINDEPENDENTPITCHINGMINUS    BaseballStatsEnum = "FIELDING_INDEPENDENT_PITCHING_MINUS"
	BaseballStatsEnumFIELDINGPERCENTAGE                  BaseballStatsEnum = "FIELDING_PERCENTAGE"
	BaseballStatsEnumFIELDINGRUNSABOVEAVG                BaseballStatsEnum = "FIELDING_RUNS_ABOVE_AVG"
	BaseballStatsEnumFIELDINGRUNSPREVENTED               BaseballStatsEnum = "FIELDING_RUNS_PREVENTED"
	BaseballStatsEnumFIRSTSTEP                           BaseballStatsEnum = "FIRST_STEP"
	BaseballStatsEnumFIRSTSTEPEFFICIENCY                 BaseballStatsEnum = "FIRST_STEP_EFFICIENCY"
	BaseballStatsEnumFIRSTTOHOME                         BaseballStatsEnum = "FIRST_TO_HOME"
	BaseballStatsEnumFIRSTTOSECOND                       BaseballStatsEnum = "FIRST_TO_SECOND"
	BaseballStatsEnumFIRSTTOTHIRD                        BaseballStatsEnum = "FIRST_TO_THIRD"
	BaseballStatsEnumFLYOUTS                             BaseballStatsEnum = "FLYOUTS"
	BaseballStatsEnumGAMEAVERAGELEVERAGEINDEX            BaseballStatsEnum = "GAME_AVERAGE_LEVERAGE_INDEX"
	BaseballStatsEnumGAMEDATE                            BaseballStatsEnum = "GAME_DATE"
	BaseballStatsEnumGAMESFINISHED                       BaseballStatsEnum = "GAMES_FINISHED"
	BaseballStatsEnumGAMESPLAYED                         BaseballStatsEnum = "GAMES_PLAYED"
	BaseballStatsEnumGAMESSTARTED                        BaseballStatsEnum = "GAMES_STARTED"
	BaseballStatsEnumGROUNDINTODOUBLEPLAYOPPORTUNITIES   BaseballStatsEnum = "GROUND_INTO_DOUBLE_PLAY_OPPORTUNITIES"
	BaseballStatsEnumGROUNDINTODOUBLEPLAYS               BaseballStatsEnum = "GROUND_INTO_DOUBLE_PLAYS"
	BaseballStatsEnumGROUNDINTOTRIPLEPLAYS               BaseballStatsEnum = "GROUND_INTO_TRIPLE_PLAYS"
	BaseballStatsEnumGROUNDOUTS                          BaseballStatsEnum = "GROUNDOUTS"
	BaseballStatsEnumGROUNDOUTTOFLYOUTRATIO              BaseballStatsEnum = "GROUNDOUT_TO_FLYOUT_RATIO"
	BaseballStatsEnumHANGTIME                            BaseballStatsEnum = "HANG_TIME"
	BaseballStatsEnumHITBATSMAN                          BaseballStatsEnum = "HIT_BATSMAN"
	BaseballStatsEnumHITBYPITCHES                        BaseballStatsEnum = "HIT_BY_PITCHES"
	BaseballStatsEnumHITDISTANCE                         BaseballStatsEnum = "HIT_DISTANCE"
	BaseballStatsEnumHITPROBABILITY                      BaseballStatsEnum = "HIT_PROBABILITY"
	BaseballStatsEnumHITS                                BaseballStatsEnum = "HITS"
	BaseballStatsEnumHITSPER9INN                         BaseballStatsEnum = "HITS_PER_9_INN"
	BaseballStatsEnumHITSRISP                            BaseballStatsEnum = "HITS_RISP"
	BaseballStatsEnumHOLDS                               BaseballStatsEnum = "HOLDS"
	BaseballStatsEnumHOMERUNDISTANCE                     BaseballStatsEnum = "HOME_RUN_DISTANCE"
	BaseballStatsEnumHOMERUNS                            BaseballStatsEnum = "HOME_RUNS"
	BaseballStatsEnumHOMERUNSPERPLATEAPPEARANCE          BaseballStatsEnum = "HOME_RUNS_PER_PLATE_APPEARANCE"
	BaseballStatsEnumHOMERUNTROT                         BaseballStatsEnum = "HOME_RUN_TROT"
	BaseballStatsEnumHOMERUNVENUEIDS                     BaseballStatsEnum = "HOME_RUN_VENUE_IDS"
	BaseballStatsEnumHOMERUNXBALLPARKS                   BaseballStatsEnum = "HOME_RUN_X_BALLPARKS"
	BaseballStatsEnumHOMETOFIRST                         BaseballStatsEnum = "HOME_TO_FIRST"
	BaseballStatsEnumHOMETOSECOND                        BaseballStatsEnum = "HOME_TO_SECOND"
	BaseballStatsEnumHOMETOTHIRD                         BaseballStatsEnum = "HOME_TO_THIRD"
	BaseballStatsEnumHORIZONTALBREAK                     BaseballStatsEnum = "HORIZONTAL_BREAK"
	BaseballStatsEnumINHERITEDRUNNER                     BaseballStatsEnum = "INHERITED_RUNNER"
	BaseballStatsEnumINHERITEDRUNNERSCORED               BaseballStatsEnum = "INHERITED_RUNNER_SCORED"
	BaseballStatsEnumINNINGAVERAGELEVERAGEINDEX          BaseballStatsEnum = "INNING_AVERAGE_LEVERAGE_INDEX"
	BaseballStatsEnumINNINGS                             BaseballStatsEnum = "INNINGS"
	BaseballStatsEnumINNINGSPITCHED                      BaseballStatsEnum = "INNINGS_PITCHED"
	BaseballStatsEnumINTENTIONALWALKS                    BaseballStatsEnum = "INTENTIONAL_WALKS"
	BaseballStatsEnumISO                                 BaseballStatsEnum = "ISO"
	BaseballStatsEnumJUMPDISTANCE                        BaseballStatsEnum = "JUMP_DISTANCE"
	BaseballStatsEnumLAUNCHANGLE                         BaseballStatsEnum = "LAUNCH_ANGLE"
	BaseballStatsEnumLEADDISTANCE                        BaseballStatsEnum = "LEAD_DISTANCE"
	BaseballStatsEnumLEFTONBASE                          BaseballStatsEnum = "LEFT_ON_BASE"
	BaseballStatsEnumLEFTONBASERISP                      BaseballStatsEnum = "LEFT_ON_BASE_RISP"
	BaseballStatsEnumLOSSES                              BaseballStatsEnum = "LOSSES"
	BaseballStatsEnumLOSSSTREAK                          BaseballStatsEnum = "LOSS_STREAK"
	BaseballStatsEnumMAXHEIGHT                           BaseballStatsEnum = "MAX_HEIGHT"
	BaseballStatsEnumMELTDOWNS                           BaseballStatsEnum = "MELTDOWNS"
	BaseballStatsEnumNUMBEROFBALLS                       BaseballStatsEnum = "NUMBER_OF_BALLS"
	BaseballStatsEnumNUMBEROFPITCHES                     BaseballStatsEnum = "NUMBER_OF_PITCHES"
	BaseballStatsEnumNUMBEROFSTRIKES                     BaseballStatsEnum = "NUMBER_OF_STRIKES"
	BaseballStatsEnumONBASEPERCENTAGE                    BaseballStatsEnum = "ON_BASE_PERCENTAGE"
	BaseballStatsEnumONBASEPLUSSLUGGING                  BaseballStatsEnum = "ON_BASE_PLUS_SLUGGING"
	BaseballStatsEnumOUTFIELDASSISTS                     BaseballStatsEnum = "OUTFIELD_ASSISTS"
	BaseballStatsEnumOUTOFBOX                            BaseballStatsEnum = "OUT_OF_BOX"
	BaseballStatsEnumOUTSABOVEAVERAGE                    BaseballStatsEnum = "OUTS_ABOVE_AVERAGE"
	BaseballStatsEnumOUTSPITCHED                         BaseballStatsEnum = "OUTS_PITCHED"
	BaseballStatsEnumPASSEDBALLS                         BaseballStatsEnum = "PASSED_BALLS"
	BaseballStatsEnumPICKOFFS                            BaseballStatsEnum = "PICKOFFS"
	BaseballStatsEnumPITCHERAVERAGELEVERAGEINDEX         BaseballStatsEnum = "PITCHER_AVERAGE_LEVERAGE_INDEX"
	BaseballStatsEnumPITCHESPERINNING                    BaseballStatsEnum = "PITCHES_PER_INNING"
	BaseballStatsEnumPITCHESPERPLATEAPPEARANCE           BaseballStatsEnum = "PITCHES_PER_PLATE_APPEARANCE"
	BaseballStatsEnumPITCHSPEED                          BaseballStatsEnum = "PITCH_SPEED"
	BaseballStatsEnumPOPTIME1B                           BaseballStatsEnum = "POP_TIME_1B"
	BaseballStatsEnumPOPTIME2B                           BaseballStatsEnum = "POP_TIME_2B"
	BaseballStatsEnumPOPTIME3B                           BaseballStatsEnum = "POP_TIME_3B"
	BaseballStatsEnumPOSITIONALRUNSABOVEAVG              BaseballStatsEnum = "POSITIONAL_RUNS_ABOVE_AVG"
	BaseballStatsEnumPUTOUTS                             BaseballStatsEnum = "PUT_OUTS"
	BaseballStatsEnumQUALITYSTARTS                       BaseballStatsEnum = "QUALITY_STARTS"
	BaseballStatsEnumRANGEFACTORPER9INN                  BaseballStatsEnum = "RANGE_FACTOR_PER_9_INN"
	BaseballStatsEnumRANGEFACTORPERGAME                  BaseballStatsEnum = "RANGE_FACTOR_PER_GAME"
	BaseballStatsEnumREACHEDONERROR                      BaseballStatsEnum = "REACHED_ON_ERROR"
	BaseballStatsEnumREPLACEMENTRUNS                     BaseballStatsEnum = "REPLACEMENT_RUNS"
	BaseballStatsEnumROUTEEFFICIENCY                     BaseballStatsEnum = "ROUTE_EFFICIENCY"
	BaseballStatsEnumRUNS                                BaseballStatsEnum = "RUNS"
	BaseballStatsEnumRUNSABOVEREPLACEMENT                BaseballStatsEnum = "RUNS_ABOVE_REPLACEMENT"
	BaseballStatsEnumRUNSALLOWEDBASEDWAR                 BaseballStatsEnum = "RUNS_ALLOWED_BASED_WAR"
	BaseballStatsEnumRUNSBATTEDIN                        BaseballStatsEnum = "RUNS_BATTED_IN"
	BaseballStatsEnumSACRIFICEBUNTS                      BaseballStatsEnum = "SACRIFICE_BUNTS"
	BaseballStatsEnumSACRIFICEFLIES                      BaseballStatsEnum = "SACRIFICE_FLIES"
	BaseballStatsEnumSAVEOPPORTUNITIES                   BaseballStatsEnum = "SAVE_OPPORTUNITIES"
	BaseballStatsEnumSAVES                               BaseballStatsEnum = "SAVES"
	BaseballStatsEnumSECONDARYLEADDISTANCE               BaseballStatsEnum = "SECONDARY_LEAD_DISTANCE"
	BaseballStatsEnumSECONDTOHOME                        BaseballStatsEnum = "SECOND_TO_HOME"
	BaseballStatsEnumSECONDTOTHIRD                       BaseballStatsEnum = "SECOND_TO_THIRD"
	BaseballStatsEnumSHUTDOWNS                           BaseballStatsEnum = "SHUTDOWNS"
	BaseballStatsEnumSHUTOUTS                            BaseballStatsEnum = "SHUTOUTS"
	BaseballStatsEnumSLUGGINGPERCENTAGE                  BaseballStatsEnum = "SLUGGING_PERCENTAGE"
	BaseballStatsEnumSPEEDSCORE                          BaseballStatsEnum = "SPEED_SCORE"
	BaseballStatsEnumSPINRATE                            BaseballStatsEnum = "SPIN_RATE"
	BaseballStatsEnumSPRINTSPEED                         BaseballStatsEnum = "SPRINT_SPEED"
	BaseballStatsEnumSTEALFIRSTTOSECOND                  BaseballStatsEnum = "STEAL_FIRST_TO_SECOND"
	BaseballStatsEnumSTEALSECONDTOTHIRD                  BaseballStatsEnum = "STEAL_SECOND_TO_THIRD"
	BaseballStatsEnumSTEALTHIRDTOHOME                    BaseballStatsEnum = "STEAL_THIRD_TO_HOME"
	BaseballStatsEnumSTOLENBASEPERCENTAGE                BaseballStatsEnum = "STOLEN_BASE_PERCENTAGE"
	BaseballStatsEnumSTOLENBASES                         BaseballStatsEnum = "STOLEN_BASES"
	BaseballStatsEnumSTREAK                              BaseballStatsEnum = "STREAK"
	BaseballStatsEnumSTRIKEOUTS                          BaseballStatsEnum = "STRIKEOUTS"
	BaseballStatsEnumSTRIKEOUTSPER9INN                   BaseballStatsEnum = "STRIKEOUTS_PER_9_INN"
	BaseballStatsEnumSTRIKEOUTSPERPLATEAPPEARANCE        BaseballStatsEnum = "STRIKEOUTS_PER_PLATE_APPEARANCE"
	BaseballStatsEnumSTRIKEOUTWALKRATIO                  BaseballStatsEnum = "STRIKEOUT_WALK_RATIO"
	BaseballStatsEnumTAGFIRSTSTEP                        BaseballStatsEnum = "TAG_FIRST_STEP"
	BaseballStatsEnumTAGFIRSTTOSECOND                    BaseballStatsEnum = "TAG_FIRST_TO_SECOND"
	BaseballStatsEnumTAGSECONDTOTHIRD                    BaseballStatsEnum = "TAG_SECOND_TO_THIRD"
	BaseballStatsEnumTAGTHIRDTOHOME                      BaseballStatsEnum = "TAG_THIRD_TO_HOME"
	BaseballStatsEnumTHIRDTOHOME                         BaseballStatsEnum = "THIRD_TO_HOME"
	BaseballStatsEnumTHROWACCURACY                       BaseballStatsEnum = "THROW_ACCURACY"
	BaseballStatsEnumTHROWDISTANCE                       BaseballStatsEnum = "THROW_DISTANCE"
	BaseballStatsEnumTHROWDISTANCEWITHBOUNCES            BaseballStatsEnum = "THROW_DISTANCE_WITH_BOUNCES"
	BaseballStatsEnumTHROWINGERRORS                      BaseballStatsEnum = "THROWING_ERRORS"
	BaseballStatsEnumTOTALBASES                          BaseballStatsEnum = "TOTAL_BASES"
	BaseballStatsEnumTOTALBATTERSFACED                   BaseballStatsEnum = "TOTAL_BATTERS_FACED"
	BaseballStatsEnumTOTALPLATEAPPEARANCES               BaseballStatsEnum = "TOTAL_PLATE_APPEARANCES"
	BaseballStatsEnumTRIPLEPLAYS                         BaseballStatsEnum = "TRIPLE_PLAYS"
	BaseballStatsEnumTRIPLES                             BaseballStatsEnum = "TRIPLES"
	BaseballStatsEnumULTIMATEBASERUNNING                 BaseballStatsEnum = "ULTIMATE_BASE_RUNNING"
	BaseballStatsEnumUZR                                 BaseballStatsEnum = "UZR"
	BaseballStatsEnumVERTICALBREAK                       BaseballStatsEnum = "VERTICAL_BREAK"
	BaseballStatsEnumWALKOFFS                            BaseballStatsEnum = "WALKOFFS"
	BaseballStatsEnumWALKS                               BaseballStatsEnum = "WALKS"
	BaseballStatsEnumWALKSHITSPERINNINGPITCHED           BaseballStatsEnum = "WALKS_HITS_PER_INNING_PITCHED"
	BaseballStatsEnumWALKSPER9INN                        BaseballStatsEnum = "WALKS_PER_9_INN"
	BaseballStatsEnumWALKSPERPLATEAPPEARANCE             BaseballStatsEnum = "WALKS_PER_PLATE_APPEARANCE"
	BaseballStatsEnumWALKSPERSTRIKEOUT                   BaseballStatsEnum = "WALKS_PER_STRIKEOUT"
	BaseballStatsEnumWEIGHTEDLEAGUEADJUST                BaseballStatsEnum = "WEIGHTED_LEAGUE_ADJUST"
	BaseballStatsEnumWEIGHTEDNOTGROUNDINTODPRUNS         BaseballStatsEnum = "WEIGHTED_NOT_GROUND_INTO_DP_RUNS"
	BaseballStatsEnumWEIGHTEDRUNSABOVEAVERAGE            BaseballStatsEnum = "WEIGHTED_RUNS_ABOVE_AVERAGE"
	BaseballStatsEnumWEIGHTEDRUNSCREATED                 BaseballStatsEnum = "WEIGHTED_RUNS_CREATED"
	BaseballStatsEnumWEIGHTEDRUNSCREATEDPLUS             BaseballStatsEnum = "WEIGHTED_RUNS_CREATED_PLUS"
	BaseballStatsEnumWEIGHTEDSTOLENBASERUNS              BaseballStatsEnum = "WEIGHTED_STOLEN_BASE_RUNS"
	BaseballStatsEnumWILDPITCH                           BaseballStatsEnum = "WILD_PITCH"
	BaseballStatsEnumWINPERCENTAGE                       BaseballStatsEnum = "WIN_PERCENTAGE"
	BaseballStatsEnumWINS                                BaseballStatsEnum = "WINS"
	BaseballStatsEnumWINSABOVEREPLACEMENT                BaseballStatsEnum = "WINS_ABOVE_REPLACEMENT"
	BaseballStatsEnumWINSTREAK                           BaseballStatsEnum = "WIN_STREAK"
	BaseballStatsEnumWOBA                                BaseballStatsEnum = "WOBA"
	BaseballStatsEnumXAVG                                BaseballStatsEnum = "XAVG"
	BaseballStatsEnumXSLG                                BaseballStatsEnum = "XSLG"
	BaseballStatsEnumXWOBA                               BaseballStatsEnum = "XWOBA"
	BaseballStatsEnumXWOBACON                            BaseballStatsEnum = "XWOBACON"
)

// Defines values for BatterDetailType.
const (
	BatterDetailTypeATBAT                         BatterDetailType = "AT_BAT"
	BatterDetailTypeATBATSCORINGPOSITION          BatterDetailType = "AT_BAT_SCORING_POSITION"
	BatterDetailTypeBATTERINTERFERENCE            BatterDetailType = "BATTER_INTERFERENCE"
	BatterDetailTypeCATCHERINTERFERENCE           BatterDetailType = "CATCHER_INTERFERENCE"
	BatterDetailTypeCAUGHTSTEALING2B              BatterDetailType = "CAUGHT_STEALING_2B"
	BatterDetailTypeCAUGHTSTEALING3B              BatterDetailType = "CAUGHT_STEALING_3B"
	BatterDetailTypeCAUGHTSTEALINGHP              BatterDetailType = "CAUGHT_STEALING_HP"
	BatterDetailTypeDOUBLE                        BatterDetailType = "DOUBLE"
	BatterDetailTypeFANINTERFERENCE               BatterDetailType = "FAN_INTERFERENCE"
	BatterDetailTypeFLYOUT                        BatterDetailType = "FLY_OUT"
	BatterDetailTypeFOULOUT                       BatterDetailType = "FOUL_OUT"
	BatterDetailTypeGAME                          BatterDetailType = "GAME"
	BatterDetailTypeGROUNDINTODOUBLEPLAY          BatterDetailType = "GROUND_INTO_DOUBLE_PLAY"
	BatterDetailTypeGROUNDINTOTRIPLEPLAY          BatterDetailType = "GROUND_INTO_TRIPLE_PLAY"
	BatterDetailTypeGROUNDOUT                     BatterDetailType = "GROUND_OUT"
	BatterDetailTypeGROUNDRULEDOUBLE              BatterDetailType = "GROUND_RULE_DOUBLE"
	BatterDetailTypeHITBYPITCH                    BatterDetailType = "HIT_BY_PITCH"
	BatterDetailTypeHITSSCORINGPOSIITION          BatterDetailType = "HITS_SCORING_POSIITION"
	BatterDetailTypeHOMERUN                       BatterDetailType = "HOME_RUN"
	BatterDetailTypeINFIELDFLY                    BatterDetailType = "INFIELD_FLY"
	BatterDetailTypeINSIDETHEPARKHOMERUN          BatterDetailType = "INSIDE_THE_PARK_HOME_RUN"
	BatterDetailTypeINTENTWALK                    BatterDetailType = "INTENT_WALK"
	BatterDetailTypeLEFTONBASE                    BatterDetailType = "LEFT_ON_BASE"
	BatterDetailTypeLEFTONBASESCORINGPOSITION     BatterDetailType = "LEFT_ON_BASE_SCORING_POSITION"
	BatterDetailTypePICKOFF1B                     BatterDetailType = "PICKOFF_1B"
	BatterDetailTypePICKOFF2B                     BatterDetailType = "PICKOFF_2B"
	BatterDetailTypePICKOFF3B                     BatterDetailType = "PICKOFF_3B"
	BatterDetailTypePINCHHIT                      BatterDetailType = "PINCH_HIT"
	BatterDetailTypePLATEAPPEARANCE               BatterDetailType = "PLATE_APPEARANCE"
	BatterDetailTypeRBI                           BatterDetailType = "RBI"
	BatterDetailTypeREACHEDONINTERFERENCE         BatterDetailType = "REACHED_ON_INTERFERENCE"
	BatterDetailTypeREACHONERROR                  BatterDetailType = "REACH_ON_ERROR"
	BatterDetailTypeRUN                           BatterDetailType = "RUN"
	BatterDetailTypeSACBUNT                       BatterDetailType = "SAC_BUNT"
	BatterDetailTypeSACFLY                        BatterDetailType = "SAC_FLY"
	BatterDetailTypeSINGLE                        BatterDetailType = "SINGLE"
	BatterDetailTypeSTOLENBASE2B                  BatterDetailType = "STOLEN_BASE_2B"
	BatterDetailTypeSTOLENBASE3B                  BatterDetailType = "STOLEN_BASE_3B"
	BatterDetailTypeSTOLENBASEHP                  BatterDetailType = "STOLEN_BASE_HP"
	BatterDetailTypeSTRIKEOUT                     BatterDetailType = "STRIKEOUT"
	BatterDetailTypeTEAMLEFTONBASE                BatterDetailType = "TEAM_LEFT_ON_BASE"
	BatterDetailTypeTEAMLEFTONBASESCORINGPOSITION BatterDetailType = "TEAM_LEFT_ON_BASE_SCORING_POSITION"
	BatterDetailTypeTRIPLE                        BatterDetailType = "TRIPLE"
	BatterDetailTypeUNKNOWN                       BatterDetailType = "UNKNOWN"
	BatterDetailTypeWALK                          BatterDetailType = "WALK"
)

// Defines values for BroadcastAvailability.
const (
	EXCLUSIVE        BroadcastAvailability = "EXCLUSIVE"
	GLOBAL           BroadcastAvailability = "GLOBAL"
	INTERNATIONAL    BroadcastAvailability = "INTERNATIONAL"
	LOCALINMARKET    BroadcastAvailability = "LOCAL_IN_MARKET"
	LOCALOUTOFMARKET BroadcastAvailability = "LOCAL_OUT_OF_MARKET"
	NATIONAL         BroadcastAvailability = "NATIONAL"
	REGIONAL         BroadcastAvailability = "REGIONAL"
)

// Defines values for BroadcasterActiveStatusEnum.
const (
	BroadcasterActiveStatusEnumACTIVE   BroadcasterActiveStatusEnum = "ACTIVE"
	BroadcasterActiveStatusEnumBOTH     BroadcasterActiveStatusEnum = "BOTH"
	BroadcasterActiveStatusEnumINACTIVE BroadcasterActiveStatusEnum = "INACTIVE"
)

// Defines values for CalendarTypes.
const (
	PRIMARY   CalendarTypes = "PRIMARY"
	SECONDARY CalendarTypes = "SECONDARY"
	TERTIARY  CalendarTypes = "TERTIARY"
)

// Defines values for DraftStatusEnum.
const (
	DRAFTED     DraftStatusEnum = "DRAFTED"
	NOTDRAFTED  DraftStatusEnum = "NOT_DRAFTED"
	NOTSELECTED DraftStatusEnum = "NOT_SELECTED"
	SELECTED    DraftStatusEnum = "SELECTED"
	SKIPPED     DraftStatusEnum = "SKIPPED"
)

// Defines values for DraftTypeEnum.
const (
	AD DraftTypeEnum = "AD"
	AL DraftTypeEnum = "AL"
	JD DraftTypeEnum = "JD"
	JR DraftTypeEnum = "JR"
	JS DraftTypeEnum = "JS"
	NR DraftTypeEnum = "NR"
	NS DraftTypeEnum = "NS"
	RA DraftTypeEnum = "RA"
	RT DraftTypeEnum = "RT"
	RV DraftTypeEnum = "RV"
)

// Defines values for EventType.
const (
	EventTypeAtBatStart                EventType = "at_bat_start"
	EventTypeAutomaticBall             EventType = "automatic_ball"
	EventTypeAutomaticStrike           EventType = "automatic_strike"
	EventTypeBalk                      EventType = "balk"
	EventTypeBall                      EventType = "ball"
	EventTypeBatterInterference        EventType = "batter_interference"
	EventTypeBatterTimeout             EventType = "batter_timeout"
	EventTypeBatterTurn                EventType = "batter_turn"
	EventTypeBetweenInnings            EventType = "between_innings"
	EventTypeBlockedBall               EventType = "blocked_ball"
	EventTypeBuntFoulTip               EventType = "bunt_foul_tip"
	EventTypeCalledStrike              EventType = "called_strike"
	EventTypeCatcherInterf             EventType = "catcher_interf"
	EventTypeCaughtStealing            EventType = "caught_stealing"
	EventTypeCaughtStealing2b          EventType = "caught_stealing_2b"
	EventTypeCaughtStealing3b          EventType = "caught_stealing_3b"
	EventTypeCaughtStealingHome        EventType = "caught_stealing_home"
	EventTypeCsDoublePlay              EventType = "cs_double_play"
	EventTypeDefensiveIndiff           EventType = "defensive_indiff"
	EventTypeDefensiveSubstitution     EventType = "defensive_substitution"
	EventTypeDefensiveSwitch           EventType = "defensive_switch"
	EventTypeDouble                    EventType = "double"
	EventTypeDoublePlay                EventType = "double_play"
	EventTypeEjection                  EventType = "ejection"
	EventTypeEmpty                     EventType = ""
	EventTypeError                     EventType = "error"
	EventTypeFanInterference           EventType = "fan_interference"
	EventTypeFieldError                EventType = "field_error"
	EventTypeFieldOut                  EventType = "field_out"
	EventTypeFielderInterference       EventType = "fielder_interference"
	EventTypeFieldersChoice            EventType = "fielders_choice"
	EventTypeFieldersChoiceOut         EventType = "fielders_choice_out"
	EventTypeForceOut                  EventType = "force_out"
	EventTypeForcedBalk                EventType = "forced_balk"
	EventTypeFoul                      EventType = "foul"
	EventTypeFoulBunt                  EventType = "foul_bunt"
	EventTypeFoulPitchout              EventType = "foul_pitchout"
	EventTypeFoulTip                   EventType = "foul_tip"
	EventTypeGameAdvisory              EventType = "game_advisory"
	EventTypeGameFinished              EventType = "game_finished"
	EventTypeGameStart                 EventType = "game_start"
	EventTypeGroundedIntoDoublePlay    EventType = "grounded_into_double_play"
	EventTypeGroundedIntoTriplePlay    EventType = "grounded_into_triple_play"
	EventTypeHitByPitch                EventType = "hit_by_pitch"
	EventTypeHitIntoPlay               EventType = "hit_into_play"
	EventTypeHitIntoPlayNoOut          EventType = "hit_into_play_no_out"
	EventTypeHitIntoPlayScore          EventType = "hit_into_play_score"
	EventTypeHomeRun                   EventType = "home_run"
	EventTypeInjury                    EventType = "injury"
	EventTypeIntentBall                EventType = "intent_ball"
	EventTypeIntentWalk                EventType = "intent_walk"
	EventTypeLeftOnBase                EventType = "left_on_base"
	EventTypeMissedBunt                EventType = "missed_bunt"
	EventTypeMoundVisit                EventType = "mound_visit"
	EventTypeNoPitch                   EventType = "no_pitch"
	EventTypeOffensiveSubstitution     EventType = "offensive_substitution"
	EventTypeOsRulingPendingPrimary    EventType = "os_ruling_pending_primary"
	EventTypeOsRulingPendingPrior      EventType = "os_ruling_pending_prior"
	EventTypeOtherAdvance              EventType = "other_advance"
	EventTypeOtherOut                  EventType = "other_out"
	EventTypePassedBall                EventType = "passed_ball"
	EventTypePickoff1b                 EventType = "pickoff_1b"
	EventTypePickoff2b                 EventType = "pickoff_2b"
	EventTypePickoff3b                 EventType = "pickoff_3b"
	EventTypePickoffAttempt1b          EventType = "pickoff_attempt_1b"
	EventTypePickoffAttempt2b          EventType = "pickoff_attempt_2b"
	EventTypePickoffAttempt3b          EventType = "pickoff_attempt_3b"
	EventTypePickoffCaughtStealing2b   EventType = "pickoff_caught_stealing_2b"
	EventTypePickoffCaughtStealing3b   EventType = "pickoff_caught_stealing_3b"
	EventTypePickoffCaughtStealingHome EventType = "pickoff_caught_stealing_home"
	EventTypePickoffError1b            EventType = "pickoff_error_1b"
	EventTypePickoffError2b            EventType = "pickoff_error_2b"
	EventTypePickoffError3b            EventType = "pickoff_error_3b"
	EventTypePitchChallenge            EventType = "pitch_challenge"
	EventTypePitcherStepOff            EventType = "pitcher_step_off"
	EventTypePitcherSwitch             EventType = "pitcher_switch"
	EventTypePitchingSubstitution      EventType = "pitching_substitution"
	EventTypePitchout                  EventType = "pitchout"
	EventTypePitchoutHitIntoPlay       EventType = "pitchout_hit_into_play"
	EventTypePitchoutHitIntoPlayNoOut  EventType = "pitchout_hit_into_play_no_out"
	EventTypePitchoutHitIntoPlayScore  EventType = "pitchout_hit_into_play_score"
	EventTypePlateAppearance           EventType = "plate_appearance"
	EventTypePlayByPlay                EventType = "play_by_play"
	EventTypePlayByPlayExtra           EventType = "play_by_play_extra"
	EventTypeReliefNoOut               EventType = "relief_no_out"
	EventTypeReplayManager             EventType = "replay_manager"
	EventTypeReplayUmpire              EventType = "replay_umpire"
	EventTypeRun                       EventType = "run"
	EventTypeRunnerDoublePlay          EventType = "runner_double_play"
	EventTypeRunnerInterference        EventType = "runner_interference"
	EventTypeRunnerMovement            EventType = "runner_movement"
	EventTypeRunnerPlaced              EventType = "runner_placed"
	EventTypeSacBunt                   EventType = "sac_bunt"
	EventTypeSacBuntDoublePlay         EventType = "sac_bunt_double_play"
	EventTypeSacFly                    EventType = "sac_fly"
	EventTypeSacFlyDoublePlay          EventType = "sac_fly_double_play"
	EventTypeSingle                    EventType = "single"
	EventTypeStolenBase                EventType = "stolen_base"
	EventTypeStolenBase2b              EventType = "stolen_base_2b"
	EventTypeStolenBase3b              EventType = "stolen_base_3b"
	EventTypeStolenBaseHome            EventType = "stolen_base_home"
	EventTypeStrikeOut                 EventType = "strike_out"
	EventTypeStrikeout                 EventType = "strikeout"
	EventTypeStrikeoutDoublePlay       EventType = "strikeout_double_play"
	EventTypeStrikeoutTriplePlay       EventType = "strikeout_triple_play"
	EventTypeSwingingPitchout          EventType = "swinging_pitchout"
	EventTypeSwingingStrike            EventType = "swinging_strike"
	EventTypeSwingingStrikeBlocked     EventType = "swinging_strike_blocked"
	EventTypeTriple                    EventType = "triple"
	EventTypeTriplePlay                EventType = "triple_play"
	EventTypeUmpireSubstitution        EventType = "umpire_substitution"
	EventTypeUnknownStrike             EventType = "unknown_strike"
	EventTypeWalk                      EventType = "walk"
	EventTypeWildPitch                 EventType = "wild_pitch"
)

// Defines values for ExpandEnum.
const (
	AWARDSPERSON                                   ExpandEnum = "AWARDS_PERSON"
	AWARDSRESULTS                                  ExpandEnum = "AWARDS_RESULTS"
	AWARDSTEAM                                     ExpandEnum = "AWARDS_TEAM"
	BATTINGSTATSTEAM                               ExpandEnum = "BATTING_STATS_TEAM"
	DECISIONSPERSON                                ExpandEnum = "DECISIONS_PERSON"
	GAMETEAM                                       ExpandEnum = "GAME_TEAM"
	LEADERSPERSON                                  ExpandEnum = "LEADERS_PERSON"
	LEAGUELEADERSTEAM                              ExpandEnum = "LEAGUE_LEADERS_TEAM"
	PERSONCURRENTTEAM                              ExpandEnum = "PERSON_CURRENT_TEAM"
	PERSONNAMES                                    ExpandEnum = "PERSON_NAMES"
	PERSONSOCIAL                                   ExpandEnum = "PERSON_SOCIAL"
	PERSONSTATS                                    ExpandEnum = "PERSON_STATS"
	ROSTERPERSON                                   ExpandEnum = "ROSTER_PERSON"
	SCHEDULEBROADCASTS                             ExpandEnum = "SCHEDULE_BROADCASTS"
	SCHEDULEBROADCASTSALL                          ExpandEnum = "SCHEDULE_BROADCASTS_ALL"
	SCHEDULEDECISIONS                              ExpandEnum = "SCHEDULE_DECISIONS"
	SCHEDULEGAMECONTENTALL                         ExpandEnum = "SCHEDULE_GAME_CONTENT_ALL"
	SCHEDULEGAMECONTENTEDITORIALALL                ExpandEnum = "SCHEDULE_GAME_CONTENT_EDITORIAL_ALL"
	SCHEDULEGAMECONTENTEDITORIALARTICLES           ExpandEnum = "SCHEDULE_GAME_CONTENT_EDITORIAL_ARTICLES"
	SCHEDULEGAMECONTENTEDITORIALPREVIEW            ExpandEnum = "SCHEDULE_GAME_CONTENT_EDITORIAL_PREVIEW"
	SCHEDULEGAMECONTENTEDITORIALRECAP              ExpandEnum = "SCHEDULE_GAME_CONTENT_EDITORIAL_RECAP"
	SCHEDULEGAMECONTENTHIGHLIGHTSALL               ExpandEnum = "SCHEDULE_GAME_CONTENT_HIGHLIGHTS_ALL"
	SCHEDULEGAMECONTENTHIGHLIGHTSGAMECENTER        ExpandEnum = "SCHEDULE_GAME_CONTENT_HIGHLIGHTS_GAMECENTER"
	SCHEDULEGAMECONTENTHIGHLIGHTSMILESTONE         ExpandEnum = "SCHEDULE_GAME_CONTENT_HIGHLIGHTS_MILESTONE"
	SCHEDULEGAMECONTENTHIGHLIGHTSSCOREBOARD        ExpandEnum = "SCHEDULE_GAME_CONTENT_HIGHLIGHTS_SCOREBOARD"
	SCHEDULEGAMECONTENTHIGHLIGHTSSCOREBOARDPREVIEW ExpandEnum = "SCHEDULE_GAME_CONTENT_HIGHLIGHTS_SCOREBOARD_PREVIEW"
	SCHEDULEGAMECONTENTMEDIAALL                    ExpandEnum = "SCHEDULE_GAME_CONTENT_MEDIA_ALL"
	SCHEDULEGAMECONTENTMEDIAEPG                    ExpandEnum = "SCHEDULE_GAME_CONTENT_MEDIA_EPG"
	SCHEDULEGAMECONTENTMEDIAMILESTONES             ExpandEnum = "SCHEDULE_GAME_CONTENT_MEDIA_MILESTONES"
	SCHEDULEGAMESERIESSUMMARY                      ExpandEnum = "SCHEDULE_GAME_SERIES_SUMMARY"
	SCHEDULELINESCORE                              ExpandEnum = "SCHEDULE_LINESCORE"
	SCHEDULEMETADATA                               ExpandEnum = "SCHEDULE_METADATA"
	SCHEDULERADIOBROADCASTS                        ExpandEnum = "SCHEDULE_RADIO_BROADCASTS"
	SCHEDULESCORINGPLAYS                           ExpandEnum = "SCHEDULE_SCORING_PLAYS"
	SCHEDULETEAM                                   ExpandEnum = "SCHEDULE_TEAM"
	SCHEDULETICKET                                 ExpandEnum = "SCHEDULE_TICKET"
	SCHEDULEVENUE                                  ExpandEnum = "SCHEDULE_VENUE"
	SCORINGPLAYSPERSON                             ExpandEnum = "SCORING_PLAYS_PERSON"
	SERIESSUMMARYSERIES                            ExpandEnum = "SERIES_SUMMARY_SERIES"
	STANDINGSCONFERENCE                            ExpandEnum = "STANDINGS_CONFERENCE"
	STANDINGSDIVISION                              ExpandEnum = "STANDINGS_DIVISION"
	STANDINGSLEAGUE                                ExpandEnum = "STANDINGS_LEAGUE"
	STANDINGSRECORD                                ExpandEnum = "STANDINGS_RECORD"
	STANDINGSRECORDCONFERENCE                      ExpandEnum = "STANDINGS_RECORD_CONFERENCE"
	STANDINGSRECORDDIVISION                        ExpandEnum = "STANDINGS_RECORD_DIVISION"
	STANDINGSRECORDOVERALL                         ExpandEnum = "STANDINGS_RECORD_OVERALL"
	STANDINGSTEAM                                  ExpandEnum = "STANDINGS_TEAM"
	STATSTEAM                                      ExpandEnum = "STATS_TEAM"
	TEAMCONFERENCE                                 ExpandEnum = "TEAM_CONFERENCE"
	TEAMCONTENTHOMEALL                             ExpandEnum = "TEAM_CONTENT_HOME_ALL"
	TEAMCONTENTSECTIONS                            ExpandEnum = "TEAM_CONTENT_SECTIONS"
	TEAMDEVICEPROPERTIES                           ExpandEnum = "TEAM_DEVICE_PROPERTIES"
	TEAMDIVISION                                   ExpandEnum = "TEAM_DIVISION"
	TEAMFRANCHISE                                  ExpandEnum = "TEAM_FRANCHISE"
	TEAMLEADERS                                    ExpandEnum = "TEAM_LEADERS"
	TEAMLEAGUE                                     ExpandEnum = "TEAM_LEAGUE"
	TEAMNAME                                       ExpandEnum = "TEAM_NAME"
	TEAMPLAYOFFINFO                                ExpandEnum = "TEAM_PLAYOFF_INFO"
	TEAMRECORD                                     ExpandEnum = "TEAM_RECORD"
	TEAMROSTER                                     ExpandEnum = "TEAM_ROSTER"
	TEAMSCHEDULENEXT                               ExpandEnum = "TEAM_SCHEDULE_NEXT"
	TEAMSCHEDULEPREVIOUS                           ExpandEnum = "TEAM_SCHEDULE_PREVIOUS"
	TEAMSOCIAL                                     ExpandEnum = "TEAM_SOCIAL"
	TEAMSTATS                                      ExpandEnum = "TEAM_STATS"
	TEAMTICKET                                     ExpandEnum = "TEAM_TICKET"
)

// Defines values for FielderDetailType.
const (
	FielderDetailTypeASSIST              FielderDetailType = "ASSIST"
	FielderDetailTypeCATCHERINTERFERENCE FielderDetailType = "CATCHER_INTERFERENCE"
	FielderDetailTypeCAUGHTSTEALING2B    FielderDetailType = "CAUGHT_STEALING_2B"
	FielderDetailTypeCAUGHTSTEALING3B    FielderDetailType = "CAUGHT_STEALING_3B"
	FielderDetailTypeCAUGHTSTEALINGHP    FielderDetailType = "CAUGHT_STEALING_HP"
	FielderDetailTypeDEFLECTION          FielderDetailType = "DEFLECTION"
	FielderDetailTypeDROPPEDBALLERROR    FielderDetailType = "DROPPED_BALL_ERROR"
	FielderDetailTypeERROR               FielderDetailType = "ERROR"
	FielderDetailTypeFIELDEDBALL         FielderDetailType = "FIELDED_BALL"
	FielderDetailTypeFIELDINGERROR       FielderDetailType = "FIELDING_ERROR"
	FielderDetailTypeFOULERROR           FielderDetailType = "FOUL_ERROR"
	FielderDetailTypeINTERFERENCE        FielderDetailType = "INTERFERENCE"
	FielderDetailTypeOUTFIELDASSIST      FielderDetailType = "OUTFIELD_ASSIST"
	FielderDetailTypeOUTNUMBER           FielderDetailType = "OUT_NUMBER"
	FielderDetailTypePASSEDBALL          FielderDetailType = "PASSED_BALL"
	FielderDetailTypePICKOFF1B           FielderDetailType = "PICKOFF_1B"
	FielderDetailTypePICKOFF2B           FielderDetailType = "PICKOFF_2B"
	FielderDetailTypePICKOFF3B           FielderDetailType = "PICKOFF_3B"
	FielderDetailTypePUTOUT              FielderDetailType = "PUTOUT"
	FielderDetailTypeSTOLENBASE2B        FielderDetailType = "STOLEN_BASE_2B"
	FielderDetailTypeSTOLENBASE3B        FielderDetailType = "STOLEN_BASE_3B"
	FielderDetailTypeSTOLENBASEHP        FielderDetailType = "STOLEN_BASE_HP"
	FielderDetailTypeTEAMDOUBLEPLAY      FielderDetailType = "TEAM_DOUBLE_PLAY"
	FielderDetailTypeTEAMERROR           FielderDetailType = "TEAM_ERROR"
	FielderDetailTypeTEAMTRIPLEPLAY      FielderDetailType = "TEAM_TRIPLE_PLAY"
	FielderDetailTypeTHROWINGERROR       FielderDetailType = "THROWING_ERROR"
	FielderDetailTypeTOUCH               FielderDetailType = "TOUCH"
	FielderDetailTypeUNKNOWN             FielderDetailType = "UNKNOWN"
)

// Defines values for FilterLevelEnum.
const (
	FilterLevelEnumATBAT     FilterLevelEnum = "AT_BAT"
	FilterLevelEnumCAREER    FilterLevelEnum = "CAREER"
	FilterLevelEnumGAME      FilterLevelEnum = "GAME"
	FilterLevelEnumINNING    FilterLevelEnum = "INNING"
	FilterLevelEnumNONE      FilterLevelEnum = "NONE"
	FilterLevelEnumPITCH     FilterLevelEnum = "PITCH"
	FilterLevelEnumPITCHTYPE FilterLevelEnum = "PITCH_TYPE"
	FilterLevelEnumSEASON    FilterLevelEnum = "SEASON"
)

// Defines values for FreeGameTypeEnum.
const (
	FREEGAMEEXTRAINNINGS FreeGameTypeEnum = "FREE_GAME_EXTRA_INNINGS"
	FREEGAMEOFTHEDAY     FreeGameTypeEnum = "FREE_GAME_OF_THE_DAY"
)

// Defines values for GameTypeEnum.
const (
	GameTypeEnumALLSTAR                  GameTypeEnum = "ALL_STAR"
	GameTypeEnumCHAMPIONSHIP             GameTypeEnum = "CHAMPIONSHIP"
	GameTypeEnumDIVISIONSERIES           GameTypeEnum = "DIVISION_SERIES"
	GameTypeEnumEXHIBITION               GameTypeEnum = "EXHIBITION"
	GameTypeEnumFIRSTROUND               GameTypeEnum = "FIRST_ROUND"
	GameTypeEnumINTRASQUAD               GameTypeEnum = "INTRASQUAD"
	GameTypeEnumLEAGUECHAMPIONSHIPSERIES GameTypeEnum = "LEAGUE_CHAMPIONSHIP_SERIES"
	GameTypeEnumNINETEENTHCENTURYSERIES  GameTypeEnum = "NINETEENTH_CENTURY_SERIES"
	GameTypeEnumPLAYOFFS                 GameTypeEnum = "PLAYOFFS"
	GameTypeEnumREGULARSEASON            GameTypeEnum = "REGULAR_SEASON"
	GameTypeEnumSPRINGTRAINING           GameTypeEnum = "SPRING_TRAINING"
	GameTypeEnumWORLDSERIES              GameTypeEnum = "WORLD_SERIES"
)

// Defines values for GenericLookup.
const (
	GenericLookupBATS           GenericLookup = "BATS"
	GenericLookupBATSIDE        GenericLookup = "BAT_SIDE"
	GenericLookupDOUBLEHEADERSW GenericLookup = "DOUBLE_HEADER_SW"
	GenericLookupDRAFTTYPE      GenericLookup = "DRAFT_TYPE"
	GenericLookupGAMEDAYSW      GenericLookup = "GAMEDAY_SW"
	GenericLookupHITHARDNESS    GenericLookup = "HIT_HARDNESS"
	GenericLookupHITTRAJECTORY  GenericLookup = "HIT_TRAJECTORY"
	GenericLookupIFNECESSARY    GenericLookup = "IF_NECESSARY"
	GenericLookupMOUNDVISITTYPE GenericLookup = "MOUND_VISIT_TYPE"
	GenericLookupPITCHCODE      GenericLookup = "PITCH_CODE"
	GenericLookupPITCHHAND      GenericLookup = "PITCH_HAND"
	GenericLookupPITCHTYPE      GenericLookup = "PITCH_TYPE"
	GenericLookupPLAYERSTATUS   GenericLookup = "PLAYER_STATUS"
	GenericLookupREVIEWREASON   GenericLookup = "REVIEW_REASON"
	GenericLookupSITCODE        GenericLookup = "SIT_CODE"
	GenericLookupSKY            GenericLookup = "SKY"
	GenericLookupTHROWS         GenericLookup = "THROWS"
	GenericLookupTIEBREAKERSW   GenericLookup = "TIEBREAKER_SW"
	GenericLookupTRANSTYPE      GenericLookup = "TRANS_TYPE"
	GenericLookupWINDDIRECTION  GenericLookup = "WIND_DIRECTION"
)

// Defines values for GroupByEnum.
const (
	GroupByEnumATBATNUMBER        GroupByEnum = "AT_BAT_NUMBER"
	GroupByEnumBASESTATE          GroupByEnum = "BASE_STATE"
	GroupByEnumBATSIDE            GroupByEnum = "BAT_SIDE"
	GroupByEnumBATTER             GroupByEnum = "BATTER"
	GroupByEnumBATTINGDIVISION    GroupByEnum = "BATTING_DIVISION"
	GroupByEnumBATTINGLEAGUE      GroupByEnum = "BATTING_LEAGUE"
	GroupByEnumBATTINGORDER       GroupByEnum = "BATTING_ORDER"
	GroupByEnumBATTINGSPORT       GroupByEnum = "BATTING_SPORT"
	GroupByEnumBATTINGTEAM        GroupByEnum = "BATTING_TEAM"
	GroupByEnumCATCHER            GroupByEnum = "CATCHER"
	GroupByEnumCENTERFIELDER      GroupByEnum = "CENTER_FIELDER"
	GroupByEnumCOUNTBALLS         GroupByEnum = "COUNT_BALLS"
	GroupByEnumCOUNTOUTS          GroupByEnum = "COUNT_OUTS"
	GroupByEnumCOUNTSTRIKES       GroupByEnum = "COUNT_STRIKES"
	GroupByEnumDATE               GroupByEnum = "DATE"
	GroupByEnumDAYNIGHT           GroupByEnum = "DAY_NIGHT"
	GroupByEnumDAYOFWEEK          GroupByEnum = "DAY_OF_WEEK"
	GroupByEnumDEFENSIVEALIGNMENT GroupByEnum = "DEFENSIVE_ALIGNMENT"
	GroupByEnumDESIGNATEDHITTER   GroupByEnum = "DESIGNATED_HITTER"
	GroupByEnumDIVISION           GroupByEnum = "DIVISION"
	GroupByEnumEVENTTYPE          GroupByEnum = "EVENT_TYPE"
	GroupByEnumFIELDINGDIVISION   GroupByEnum = "FIELDING_DIVISION"
	GroupByEnumFIELDINGLEAGUE     GroupByEnum = "FIELDING_LEAGUE"
	GroupByEnumFIELDINGSPORT      GroupByEnum = "FIELDING_SPORT"
	GroupByEnumFIELDINGTEAM       GroupByEnum = "FIELDING_TEAM"
	GroupByEnumFIRSTBASEMAN       GroupByEnum = "FIRST_BASEMAN"
	GroupByEnumGAME               GroupByEnum = "GAME"
	GroupByEnumGAMETYPE           GroupByEnum = "GAME_TYPE"
	GroupByEnumHITDIRECTION       GroupByEnum = "HIT_DIRECTION"
	GroupByEnumHITTRAJECTORY      GroupByEnum = "HIT_TRAJECTORY"
	GroupByEnumHOMEAWAY           GroupByEnum = "HOME_AWAY"
	GroupByEnumINNING             GroupByEnum = "INNING"
	GroupByEnumLEAGUE             GroupByEnum = "LEAGUE"
	GroupByEnumLEFTFIELDER        GroupByEnum = "LEFT_FIELDER"
	GroupByEnumMONTH              GroupByEnum = "MONTH"
	GroupByEnumOPPONENTTEAM       GroupByEnum = "OPPONENT_TEAM"
	GroupByEnumPITCHCODE          GroupByEnum = "PITCH_CODE"
	GroupByEnumPITCHER            GroupByEnum = "PITCHER"
	GroupByEnumPITCHHAND          GroupByEnum = "PITCH_HAND"
	GroupByEnumPITCHNUMBER        GroupByEnum = "PITCH_NUMBER"
	GroupByEnumPITCHTYPE          GroupByEnum = "PITCH_TYPE"
	GroupByEnumPITCHZONE          GroupByEnum = "PITCH_ZONE"
	GroupByEnumPLAYER             GroupByEnum = "PLAYER"
	GroupByEnumPOSITION           GroupByEnum = "POSITION"
	GroupByEnumRIGHTFIELDER       GroupByEnum = "RIGHT_FIELDER"
	GroupByEnumRISP               GroupByEnum = "RISP"
	GroupByEnumRUNNERFIRST        GroupByEnum = "RUNNER_FIRST"
	GroupByEnumRUNNERSECOND       GroupByEnum = "RUNNER_SECOND"
	GroupByEnumRUNNERTHIRD        GroupByEnum = "RUNNER_THIRD"
	GroupByEnumSEASON             GroupByEnum = "SEASON"
	GroupByEnumSECONDBASEMAN      GroupByEnum = "SECOND_BASEMAN"
	GroupByEnumSHORTSTOP          GroupByEnum = "SHORTSTOP"
	GroupByEnumSITUATIONCODE      GroupByEnum = "SITUATION_CODE"
	GroupByEnumSPORT              GroupByEnum = "SPORT"
	GroupByEnumSTATGROUP          GroupByEnum = "STAT_GROUP"
	GroupByEnumTEAM               GroupByEnum = "TEAM"
	GroupByEnumTHIRDBASEMAN       GroupByEnum = "THIRD_BASEMAN"
	GroupByEnumVENUE              GroupByEnum = "VENUE"
)

// Defines values for HighLowStatEnum.
const (
	HighLowStatEnumASSISTS               HighLowStatEnum = "ASSISTS"
	HighLowStatEnumATBATS                HighLowStatEnum = "AT_BATS"
	HighLowStatEnumATTENDANCE            HighLowStatEnum = "ATTENDANCE"
	HighLowStatEnumAWAYTEAMERRORS        HighLowStatEnum = "AWAY_TEAM_ERRORS"
	HighLowStatEnumAWAYTEAMHITS          HighLowStatEnum = "AWAY_TEAM_HITS"
	HighLowStatEnumAWAYTEAMRUNS          HighLowStatEnum = "AWAY_TEAM_RUNS"
	HighLowStatEnumBALKS                 HighLowStatEnum = "BALKS"
	HighLowStatEnumCAUGHTSTEALING        HighLowStatEnum = "CAUGHT_STEALING"
	HighLowStatEnumCHANCES               HighLowStatEnum = "CHANCES"
	HighLowStatEnumDELAYTIME             HighLowStatEnum = "DELAY_TIME"
	HighLowStatEnumDOUBLEPLAYS           HighLowStatEnum = "DOUBLE_PLAYS"
	HighLowStatEnumDOUBLES               HighLowStatEnum = "DOUBLES"
	HighLowStatEnumERRORS                HighLowStatEnum = "ERRORS"
	HighLowStatEnumEXTRABASEHITS         HighLowStatEnum = "EXTRA_BASE_HITS"
	HighLowStatEnumGAMETIME              HighLowStatEnum = "GAME_TIME"
	HighLowStatEnumGROUNDINTODOUBLEPLAYS HighLowStatEnum = "GROUND_INTO_DOUBLE_PLAYS"
	HighLowStatEnumHITBYPITCHES          HighLowStatEnum = "HIT_BY_PITCHES"
	HighLowStatEnumHITS                  HighLowStatEnum = "HITS"
	HighLowStatEnumHITSRISP              HighLowStatEnum = "HITS_RISP"
	HighLowStatEnumHOMERUNS              HighLowStatEnum = "HOME_RUNS"
	HighLowStatEnumHOMETEAMERRORS        HighLowStatEnum = "HOME_TEAM_ERRORS"
	HighLowStatEnumHOMETEAMHITS          HighLowStatEnum = "HOME_TEAM_HITS"
	HighLowStatEnumHOMETEAMRUNS          HighLowStatEnum = "HOME_TEAM_RUNS"
	HighLowStatEnumINNING                HighLowStatEnum = "INNING"
	HighLowStatEnumINNINGSPITCHED        HighLowStatEnum = "INNINGS_PITCHED"
	HighLowStatEnumLEFTONBASE            HighLowStatEnum = "LEFT_ON_BASE"
	HighLowStatEnumLONGEST               HighLowStatEnum = "LONGEST"
	HighLowStatEnumLOSSSTREAK            HighLowStatEnum = "LOSS_STREAK"
	HighLowStatEnumPITCHES               HighLowStatEnum = "PITCHES"
	HighLowStatEnumPUTOUTS               HighLowStatEnum = "PUT_OUTS"
	HighLowStatEnumRUNS                  HighLowStatEnum = "RUNS"
	HighLowStatEnumRUNSBATTEDIN          HighLowStatEnum = "RUNS_BATTED_IN"
	HighLowStatEnumSACRIFICEBUNTS        HighLowStatEnum = "SACRIFICE_BUNTS"
	HighLowStatEnumSACRIFICEFLIES        HighLowStatEnum = "SACRIFICE_FLIES"
	HighLowStatEnumSHORTEST              HighLowStatEnum = "SHORTEST"
	HighLowStatEnumSTOLENBASES           HighLowStatEnum = "STOLEN_BASES"
	HighLowStatEnumSTRIKEOUTS            HighLowStatEnum = "STRIKEOUTS"
	HighLowStatEnumSTRIKES               HighLowStatEnum = "STRIKES"
	HighLowStatEnumTOTALBASES            HighLowStatEnum = "TOTAL_BASES"
	HighLowStatEnumTOTALPLATEAPPEARANCES HighLowStatEnum = "TOTAL_PLATE_APPEARANCES"
	HighLowStatEnumTRIPLES               HighLowStatEnum = "TRIPLES"
	HighLowStatEnumWALKS                 HighLowStatEnum = "WALKS"
	HighLowStatEnumWINSTREAK             HighLowStatEnum = "WIN_STREAK"
)

// Defines values for HighLowTypeEnum.
const (
	HighLowTypeEnumGAME   HighLowTypeEnum = "GAME"
	HighLowTypeEnumPLAYER HighLowTypeEnum = "PLAYER"
	HighLowTypeEnumTEAM   HighLowTypeEnum = "TEAM"
)

// Defines values for HitTrajectory.
const (
	HitTrajectoryBUNTGROUNDBALL HitTrajectory = "BUNT_GROUND_BALL"
	HitTrajectoryBUNTLINEDRIVE  HitTrajectory = "BUNT_LINE_DRIVE"
	HitTrajectoryBUNTPOPUP      HitTrajectory = "BUNT_POP_UP"
	HitTrajectoryFLYBALL        HitTrajectory = "FLY_BALL"
	HitTrajectoryGROUNDBALL     HitTrajectory = "GROUND_BALL"
	HitTrajectoryLINEDRIVE      HitTrajectory = "LINE_DRIVE"
	HitTrajectoryPOPUP          HitTrajectory = "POP_UP"
	HitTrajectoryUNKNOWN        HitTrajectory = "UNKNOWN"
)

// Defines values for ImageTypeEnum.
const (
	HEADER       ImageTypeEnum = "HEADER"
	LIST         ImageTypeEnum = "LIST"
	LOGOIMAGE    ImageTypeEnum = "LOGOIMAGE"
	MAPTHUMBNAIL ImageTypeEnum = "MAP_THUMBNAIL"
	SPONSORSHIP  ImageTypeEnum = "SPONSORSHIP"
	THUMBNAIL    ImageTypeEnum = "THUMBNAIL"
	URL          ImageTypeEnum = "URL"
)

// Defines values for Language.
const (
	BIS              Language = "BIS"
	CHINESE          Language = "CHINESE"
	DUTCH            Language = "DUTCH"
	ELIAS            Language = "ELIAS"
	ENGLISH          Language = "ENGLISH"
	FRENCH           Language = "FRENCH"
	GERMAN           Language = "GERMAN"
	GREEK            Language = "GREEK"
	ITALIAN          Language = "ITALIAN"
	JAPANESE         Language = "JAPANESE"
	JAPANESE2        Language = "JAPANESE_2"
	KOREAN           Language = "KOREAN"
	PORTUGUESE       Language = "PORTUGUESE"
	SPANISH          Language = "SPANISH"
	TAGALOG          Language = "TAGALOG"
	UNACCENTOVERRIDE Language = "UNACCENT_OVERRIDE"
)

// Defines values for LeagueActiveStatusEnum.
const (
	LeagueActiveStatusEnumACTIVE   LeagueActiveStatusEnum = "ACTIVE"
	LeagueActiveStatusEnumBOTH     LeagueActiveStatusEnum = "BOTH"
	LeagueActiveStatusEnumINACTIVE LeagueActiveStatusEnum = "INACTIVE"
	LeagueActiveStatusEnumPENDING  LeagueActiveStatusEnum = "PENDING"
)

// Defines values for LeagueListsEnum.
const (
	LeagueListsEnumABL              LeagueListsEnum = "ABL"
	LeagueListsEnumBASEBALLALL      LeagueListsEnum = "BASEBALL_ALL"
	LeagueListsEnumMEXALL           LeagueListsEnum = "MEX_ALL"
	LeagueListsEnumMILBALL          LeagueListsEnum = "MILB_ALL"
	LeagueListsEnumMILBALLDOMESTIC  LeagueListsEnum = "MILB_ALL_DOMESTIC"
	LeagueListsEnumMILBALLNOMEX     LeagueListsEnum = "MILB_ALL_NOMEX"
	LeagueListsEnumMILBCOMPLEX      LeagueListsEnum = "MILB_COMPLEX"
	LeagueListsEnumMILBDOMCOMP      LeagueListsEnum = "MILB_DOMCOMP"
	LeagueListsEnumMILBFULL         LeagueListsEnum = "MILB_FULL"
	LeagueListsEnumMILBINTCOMP      LeagueListsEnum = "MILB_INTCOMP"
	LeagueListsEnumMILBNONCOMP      LeagueListsEnum = "MILB_NONCOMP"
	LeagueListsEnumMILBNONCOMPNOMEX LeagueListsEnum = "MILB_NONCOMP_NOMEX"
	LeagueListsEnumMILBSHORT        LeagueListsEnum = "MILB_SHORT"
	LeagueListsEnumMLB              LeagueListsEnum = "MLB"
	LeagueListsEnumMLBALNL          LeagueListsEnum = "MLB_AL_NL"
	LeagueListsEnumMLBHIST          LeagueListsEnum = "MLB_HIST"
	LeagueListsEnumMLBMILB          LeagueListsEnum = "MLB_MILB"
	LeagueListsEnumMLBMILBHIST      LeagueListsEnum = "MLB_MILB_HIST"
	LeagueListsEnumMLBMILBWIN       LeagueListsEnum = "MLB_MILB_WIN"
	LeagueListsEnumMLBNEGRO         LeagueListsEnum = "MLB_NEGRO"
	LeagueListsEnumMLBSPRING        LeagueListsEnum = "MLB_SPRING"
	LeagueListsEnumNEGROALL         LeagueListsEnum = "NEGRO_ALL"
	LeagueListsEnumWINALL           LeagueListsEnum = "WIN_ALL"
	LeagueListsEnumWINCARIBBEAN     LeagueListsEnum = "WIN_CARIBBEAN"
	LeagueListsEnumWINNOABL         LeagueListsEnum = "WIN_NOABL"
)

// Defines values for MediaSourceType.
const (
	MediaSourceTypeALTERNATEBROADCAST       MediaSourceType = "ALTERNATE_BROADCAST"
	MediaSourceTypeAWAY                     MediaSourceType = "AWAY"
	MediaSourceTypeBROADCAST                MediaSourceType = "BROADCAST"
	MediaSourceTypeCENTERFIELD              MediaSourceType = "CENTERFIELD"
	MediaSourceTypeCF                       MediaSourceType = "CF"
	MediaSourceTypeCHHIGHSIDEVIEW           MediaSourceType = "CH_HIGH_SIDEVIEW"
	MediaSourceTypeCHSIDEVIEW               MediaSourceType = "CH_SIDEVIEW"
	MediaSourceTypeFIRSTBASEBATTERSIDEVIEW  MediaSourceType = "FIRST_BASE_BATTER_SIDEVIEW"
	MediaSourceTypeFIRSTBASEPITCHERSIDEVIEW MediaSourceType = "FIRST_BASE_PITCHER_SIDEVIEW"
	MediaSourceTypeFIRSTBASESIDEVIEW        MediaSourceType = "FIRST_BASE_SIDEVIEW"
	MediaSourceTypeHIGHHOME                 MediaSourceType = "HIGH_HOME"
	MediaSourceTypeHOME                     MediaSourceType = "HOME"
	MediaSourceTypeNETWORK                  MediaSourceType = "NETWORK"
	MediaSourceTypePITCHCAST                MediaSourceType = "PITCHCAST"
	MediaSourceTypeTHIRDBASEBATTERSIDEVIEW  MediaSourceType = "THIRD_BASE_BATTER_SIDEVIEW"
	MediaSourceTypeTHIRDBASEPITCHERSIDEVIEW MediaSourceType = "THIRD_BASE_PITCHER_SIDEVIEW"
	MediaSourceTypeTHIRDBASESIDEVIEW        MediaSourceType = "THIRD_BASE_SIDEVIEW"
)

// Defines values for MediaState.
const (
	MEDIAARCHIVE MediaState = "MEDIA_ARCHIVE"
	MEDIAOFF     MediaState = "MEDIA_OFF"
	MEDIAON      MediaState = "MEDIA_ON"
)

// Defines values for MetricType.
const (
	MetricTypeACCELERATION                     MetricType = "ACCELERATION"
	MetricTypeACTIVESPINANGLE                  MetricType = "ACTIVE_SPIN_ANGLE"
	MetricTypeANGLETOBALLCAUGHT                MetricType = "ANGLE_TO_BALL_CAUGHT"
	MetricTypeANGLETOBALLLANDING               MetricType = "ANGLE_TO_BALL_LANDING"
	MetricTypeARMSTRENGTH                      MetricType = "ARM_STRENGTH"
	MetricTypeARMSTRENGTH1B                    MetricType = "ARM_STRENGTH_1B"
	MetricTypeARMSTRENGTH2B                    MetricType = "ARM_STRENGTH_2B"
	MetricTypeARMSTRENGTH3B                    MetricType = "ARM_STRENGTH_3B"
	MetricTypeARMSTRENGTHHP                    MetricType = "ARM_STRENGTH_HP"
	MetricTypeATTACKANGLE                      MetricType = "ATTACK_ANGLE"
	MetricTypeATTACKZONES                      MetricType = "ATTACK_ZONES"
	MetricTypeBACKSPIN                         MetricType = "BACKSPIN"
	MetricTypeBALLHEIGHTATTHEFENCE             MetricType = "BALL_HEIGHT_AT_THE_FENCE"
	MetricTypeBALLLOCATIONAT300FEET            MetricType = "BALL_LOCATION_AT_300_FEET"
	MetricTypeBALLPARKHOMERUNCOUNT             MetricType = "BALLPARK_HOME_RUN_COUNT"
	MetricTypeBALLPROJDISTANCEFROMFENCE        MetricType = "BALL_PROJ_DISTANCE_FROM_FENCE"
	MetricTypeBALLTRACKING                     MetricType = "BALL_TRACKING"
	MetricTypeBARRELEDBALL                     MetricType = "BARRELED_BALL"
	MetricTypeBASERUNNERMARKERS                MetricType = "BASERUNNER_MARKERS"
	MetricTypeBATSPEED                         MetricType = "BAT_SPEED"
	MetricTypeBATTEDBALLTRAVELDISTANCEZ0       MetricType = "BATTED_BALL_TRAVEL_DISTANCE_Z0"
	MetricTypeBATTEDBALLTRAVELDISTANCEZ8       MetricType = "BATTED_BALL_TRAVEL_DISTANCE_Z8"
	MetricTypeBATTEDBALLTRAVELDISTANCEZF       MetricType = "BATTED_BALL_TRAVEL_DISTANCE_ZF"
	MetricTypeBATTEDBALLTRAVELDISTANCEZI       MetricType = "BATTED_BALL_TRAVEL_DISTANCE_ZI"
	MetricTypeBATTEDBALLTRAVELTIMEZ0           MetricType = "BATTED_BALL_TRAVEL_TIME_Z0"
	MetricTypeBATTEDBALLTRAVELTIMEZ8           MetricType = "BATTED_BALL_TRAVEL_TIME_Z8"
	MetricTypeBATTEDBALLTRAVELTIMEZF           MetricType = "BATTED_BALL_TRAVEL_TIME_ZF"
	MetricTypeBATTEDBALLTRAVELTIMEZI           MetricType = "BATTED_BALL_TRAVEL_TIME_ZI"
	MetricTypeBATTERBIOMECHANICS               MetricType = "BATTER_BIOMECHANICS"
	MetricTypeBLOCKRADIUS                      MetricType = "BLOCK_RADIUS"
	MetricTypeBURST                            MetricType = "BURST"
	MetricTypeCATCHEREXCHANGE                  MetricType = "CATCHER_EXCHANGE"
	MetricTypeCATCHERGLOVEPOSITION             MetricType = "CATCHER_GLOVE_POSITION"
	MetricTypeCATCHPROBABILITY                 MetricType = "CATCH_PROBABILITY"
	MetricTypeDELIVERYTIME                     MetricType = "DELIVERY_TIME"
	MetricTypeDISTANCECOVERED                  MetricType = "DISTANCE_COVERED"
	MetricTypeDISTANCECOVEREDBREAKDOWN         MetricType = "DISTANCE_COVERED_BREAKDOWN"
	MetricTypeDISTANCEFROMBALLLANDING          MetricType = "DISTANCE_FROM_BALL_LANDING"
	MetricTypeDISTANCEFROMBASEONTHROW          MetricType = "DISTANCE_FROM_BASE_ON_THROW"
	MetricTypeDISTANCEFROMSWEETSPOT            MetricType = "DISTANCE_FROM_SWEET_SPOT"
	MetricTypeDISTANCETOCATCHERSMITT           MetricType = "DISTANCE_TO_CATCHERS_MITT"
	MetricTypeDISTANCETOCATCHERSMITTSKELETAL   MetricType = "DISTANCE_TO_CATCHERS_MITT_SKELETAL"
	MetricTypeENDPLAYERANGLE                   MetricType = "END_PLAYER_ANGLE"
	MetricTypeENDPLAYERPOSITION                MetricType = "END_PLAYER_POSITION"
	MetricTypeESTIMATEDEXITVELOCITYTEMPORARY   MetricType = "ESTIMATED_EXIT_VELOCITY_TEMPORARY"
	MetricTypeESTIMATEDFIRSTSTEPTEMPORARY      MetricType = "ESTIMATED_FIRST_STEP_TEMPORARY"
	MetricTypeESTIMATEDSWINGSPEED              MetricType = "ESTIMATED_SWING_SPEED"
	MetricTypeEXCHANGE                         MetricType = "EXCHANGE"
	MetricTypeEXCHANGE1B                       MetricType = "EXCHANGE_1B"
	MetricTypeEXCHANGE2B                       MetricType = "EXCHANGE_2B"
	MetricTypeEXCHANGE3B                       MetricType = "EXCHANGE_3B"
	MetricTypeEXCHANGEDISTANCE                 MetricType = "EXCHANGE_DISTANCE"
	MetricTypeEXPECTEDSLUGGING                 MetricType = "EXPECTED_SLUGGING"
	MetricTypeEXPECTEDWOBA                     MetricType = "EXPECTED_WOBA"
	MetricTypeEXTENSION                        MetricType = "EXTENSION"
	MetricTypeFIELDERBURSTDISTANCE             MetricType = "FIELDER_BURST_DISTANCE"
	MetricTypeFIELDERENGAGEMENT                MetricType = "FIELDER_ENGAGEMENT"
	MetricTypeFIELDERJUMPDISTANCE              MetricType = "FIELDER_JUMP_DISTANCE"
	MetricTypeFIELDERREACTIONDISTANCE          MetricType = "FIELDER_REACTION_DISTANCE"
	MetricTypeFIELDERROUTINGDISTANCE           MetricType = "FIELDER_ROUTING_DISTANCE"
	MetricTypeFIELDINGRUNSPREVENTED            MetricType = "FIELDING_RUNS_PREVENTED"
	MetricTypeFIELDINGRUNSPREVENTEDTESTING     MetricType = "FIELDING_RUNS_PREVENTED_TESTING"
	MetricTypeFIELDINGZONE                     MetricType = "FIELDING_ZONE"
	MetricTypeFIRSTSTEP                        MetricType = "FIRST_STEP"
	MetricTypeFIRSTSTEPALL                     MetricType = "FIRST_STEP_ALL"
	MetricTypeFIRSTSTEPEFFICIENCY              MetricType = "FIRST_STEP_EFFICIENCY"
	MetricTypeFIRSTSTEPSTEALING                MetricType = "FIRST_STEP_STEALING"
	MetricTypeFIRSTSTEPTAG                     MetricType = "FIRST_STEP_TAG"
	MetricTypeFIRSTTOHOME                      MetricType = "FIRST_TO_HOME"
	MetricTypeFIRSTTOSECOND                    MetricType = "FIRST_TO_SECOND"
	MetricTypeFIRSTTOSECONDALL                 MetricType = "FIRST_TO_SECOND_ALL"
	MetricTypeFIRSTTOTHIRD                     MetricType = "FIRST_TO_THIRD"
	MetricTypeGAMEDAYZONE                      MetricType = "GAMEDAY_ZONE"
	MetricTypeGENERATEDSPEED                   MetricType = "GENERATED_SPEED"
	MetricTypeGYROSPIN                         MetricType = "GYROSPIN"
	MetricTypeGYROSPINRATE                     MetricType = "GYROSPIN_RATE"
	MetricTypeHANGTIME                         MetricType = "HANG_TIME"
	MetricTypeHANGTIMEAT8FEET                  MetricType = "HANG_TIME_AT_8_FEET"
	MetricTypeHITBEARINGANGLE                  MetricType = "HIT_BEARING_ANGLE"
	MetricTypeHITDISTANCE                      MetricType = "HIT_DISTANCE"
	MetricTypeHITDISTANCEAT8FEET               MetricType = "HIT_DISTANCE_AT_8_FEET"
	MetricTypeHITLAUNCHDIRECTION               MetricType = "HIT_LAUNCH_DIRECTION"
	MetricTypeHITPROBABILITY                   MetricType = "HIT_PROBABILITY"
	MetricTypeHITSPINANGLE                     MetricType = "HIT_SPIN_ANGLE"
	MetricTypeHITTRACKINGPCT                   MetricType = "HIT_TRACKING_PCT"
	MetricTypeHITTRAJECTORY                    MetricType = "HIT_TRAJECTORY"
	MetricTypeHITTRAJECTORYNOTTYPE             MetricType = "HIT_TRAJECTORY_NOT_TYPE"
	MetricTypeHITTRAVELDISTANCE                MetricType = "HIT_TRAVEL_DISTANCE"
	MetricTypeHITTRAVELTIME                    MetricType = "HIT_TRAVEL_TIME"
	MetricTypeHOMERUNDISTANCE                  MetricType = "HOME_RUN_DISTANCE"
	MetricTypeHOMERUNXBALLPARKS                MetricType = "HOME_RUN_X_BALLPARKS"
	MetricTypeHOMETOFIRST                      MetricType = "HOME_TO_FIRST"
	MetricTypeHOMETOHOME                       MetricType = "HOME_TO_HOME"
	MetricTypeHOMETOSECOND                     MetricType = "HOME_TO_SECOND"
	MetricTypeHOMETOTHIRD                      MetricType = "HOME_TO_THIRD"
	MetricTypeHORIZONTALBREAK                  MetricType = "HORIZONTAL_BREAK"
	MetricTypeINFERREDBACKSPINRATE             MetricType = "INFERRED_BACKSPIN_RATE"
	MetricTypeINFERREDGYROSPINRATE             MetricType = "INFERRED_GYROSPIN_RATE"
	MetricTypeINFERREDSIDESPINRATE             MetricType = "INFERRED_SIDESPIN_RATE"
	MetricTypeINFIELDOUTOFPOSITIONCODE         MetricType = "INFIELD_OUT_OF_POSITION_CODE"
	MetricTypeINTENDEDPLATEX                   MetricType = "INTENDED_PLATE_X"
	MetricTypeINTERCEPT                        MetricType = "INTERCEPT"
	MetricTypeJUMPDISTANCE                     MetricType = "JUMP_DISTANCE"
	MetricTypeKEYSTEP                          MetricType = "KEY_STEP"
	MetricTypeLAUNCHANGLE                      MetricType = "LAUNCH_ANGLE"
	MetricTypeLAUNCHSPEED                      MetricType = "LAUNCH_SPEED"
	MetricTypeLAUNCHSPINRATE                   MetricType = "LAUNCH_SPIN_RATE"
	MetricTypeLAUNCHVECTOR                     MetricType = "LAUNCH_VECTOR"
	MetricTypeLIMBAPEXSKELETAL                 MetricType = "LIMB_APEX_SKELETAL"
	MetricTypeMAXHEIGHT                        MetricType = "MAX_HEIGHT"
	MetricTypeNONE                             MetricType = "NONE"
	MetricTypeOPPORTUNITYTIMEGROUND            MetricType = "OPPORTUNITY_TIME_GROUND"
	MetricTypeOPPORTUNITYTIMEZ8                MetricType = "OPPORTUNITY_TIME_Z8"
	MetricTypeOPPORTUNITYTIMEZI                MetricType = "OPPORTUNITY_TIME_ZI"
	MetricTypeOUTFIELDERDISTANCETOFENCE        MetricType = "OUTFIELDER_DISTANCE_TO_FENCE"
	MetricTypeOUTFIELDOUTOFPOSITIONCODE        MetricType = "OUTFIELD_OUT_OF_POSITION_CODE"
	MetricTypeOUTSABOVEAVERAGE                 MetricType = "OUTS_ABOVE_AVERAGE"
	MetricTypeOUTSABOVEAVERAGETESTING          MetricType = "OUTS_ABOVE_AVERAGE_TESTING"
	MetricTypePERCEIVEDPITCHSPEED              MetricType = "PERCEIVED_PITCH_SPEED"
	MetricTypePITCHERBIOMECHANICS              MetricType = "PITCHER_BIOMECHANICS"
	MetricTypePITCHERPOSITION                  MetricType = "PITCHER_POSITION"
	MetricTypePITCHERRELEASE                   MetricType = "PITCHER_RELEASE"
	MetricTypePITCHINGPOSITIONTESTING          MetricType = "PITCHING_POSITION_TESTING"
	MetricTypePITCHLAUNCHANGLE                 MetricType = "PITCH_LAUNCH_ANGLE"
	MetricTypePITCHLAUNCHDIRECTION             MetricType = "PITCH_LAUNCH_DIRECTION"
	MetricTypePITCHSPEED                       MetricType = "PITCH_SPEED"
	MetricTypePLATELOCATIONX                   MetricType = "PLATE_LOCATION_X"
	MetricTypePLATELOCATIONZ                   MetricType = "PLATE_LOCATION_Z"
	MetricTypePLATESPEED                       MetricType = "PLATE_SPEED"
	MetricTypePLATETIMEY0                      MetricType = "PLATE_TIME_Y0"
	MetricTypePLATETIMEY17                     MetricType = "PLATE_TIME_Y17"
	MetricTypePLATETIMEYI                      MetricType = "PLATE_TIME_YI"
	MetricTypePLAYERTRACKING                   MetricType = "PLAYER_TRACKING"
	MetricTypePLAYERTRACKINGCOMPLETENESS       MetricType = "PLAYER_TRACKING_COMPLETENESS"
	MetricTypePOPTIME                          MetricType = "POP_TIME"
	MetricTypePOPTIME1B                        MetricType = "POP_TIME_1B"
	MetricTypePOPTIME2B                        MetricType = "POP_TIME_2B"
	MetricTypePOPTIME3B                        MetricType = "POP_TIME_3B"
	MetricTypePOSETRACKINGCOMPLETENESS         MetricType = "POSE_TRACKING_COMPLETENESS"
	MetricTypePOSITIONING                      MetricType = "POSITIONING"
	MetricTypePRIMARYLEAD                      MetricType = "PRIMARY_LEAD"
	MetricTypePROJECTEDDISTANCEFROMBALLLANDING MetricType = "PROJECTED_DISTANCE_FROM_BALL_LANDING"
	MetricTypePROJECTEDDISTANCEOFBALLFROMFENCE MetricType = "PROJECTED_DISTANCE_OF_BALL_FROM_FENCE"
	MetricTypePROJECTEDLANDINGPOSITION         MetricType = "PROJECTED_LANDING_POSITION"
	MetricTypeRELATIVESTRIKEZONELOCATION       MetricType = "RELATIVE_STRIKE_ZONE_LOCATION"
	MetricTypeRELATIVESTRIKEZONELOCATIONX      MetricType = "RELATIVE_STRIKE_ZONE_LOCATION_X"
	MetricTypeRELATIVESTRIKEZONELOCATIONZ      MetricType = "RELATIVE_STRIKE_ZONE_LOCATION_Z"
	MetricTypeRELEASEBACKSPINRATE              MetricType = "RELEASE_BACKSPIN_RATE"
	MetricTypeRELEASESIDESPINRATE              MetricType = "RELEASE_SIDESPIN_RATE"
	MetricTypeREVOLUTIONSHANDTOPLATE           MetricType = "REVOLUTIONS_HAND_TO_PLATE"
	MetricTypeROUTEEFFICIENCY                  MetricType = "ROUTE_EFFICIENCY"
	MetricTypeROUTETOSPRINTSPEED               MetricType = "ROUTE_TO_SPRINT_SPEED"
	MetricTypeRUNVALUEADDED                    MetricType = "RUN_VALUE_ADDED"
	MetricTypeSACFLYPROBABILITY                MetricType = "SAC_FLY_PROBABILITY"
	MetricTypeSACRIFICEFLY                     MetricType = "SACRIFICE_FLY"
	MetricTypeSCOOPRADIUS                      MetricType = "SCOOP_RADIUS"
	MetricTypeSECONDARYLEAD                    MetricType = "SECONDARY_LEAD"
	MetricTypeSECONDTOHOME                     MetricType = "SECOND_TO_HOME"
	MetricTypeSECONDTOTHIRD                    MetricType = "SECOND_TO_THIRD"
	MetricTypeSECONDTOTHIRDALL                 MetricType = "SECOND_TO_THIRD_ALL"
	MetricTypeSHIFTCLASSIFICATION              MetricType = "SHIFT_CLASSIFICATION"
	MetricTypeSIDESPIN                         MetricType = "SIDESPIN"
	MetricTypeSPEEDINTHELASTSECONDS            MetricType = "SPEED_IN_THE_LAST_SECONDS"
	MetricTypeSPINANGLE                        MetricType = "SPIN_ANGLE"
	MetricTypeSPINAXISOCTANTS                  MetricType = "SPIN_AXIS_OCTANTS"
	MetricTypeSPINRATE                         MetricType = "SPIN_RATE"
	MetricTypeSPINRATEPERMPH                   MetricType = "SPIN_RATE_PER_MPH"
	MetricTypeSPRINTSPEED                      MetricType = "SPRINT_SPEED"
	MetricTypeSTARTPLAYERANGLE                 MetricType = "START_PLAYER_ANGLE"
	MetricTypeSTARTPLAYERPOSITION              MetricType = "START_PLAYER_POSITION"
	MetricTypeSTARTUPTIME                      MetricType = "STARTUP_TIME"
	MetricTypeSTEALFIRSTTOSECOND               MetricType = "STEAL_FIRST_TO_SECOND"
	MetricTypeSTEALSECONDTOTHIRD               MetricType = "STEAL_SECOND_TO_THIRD"
	MetricTypeSTEALTHIRDTOHOME                 MetricType = "STEAL_THIRD_TO_HOME"
	MetricTypeSTOLENBASEPROBABILITY            MetricType = "STOLEN_BASE_PROBABILITY"
	MetricTypeSTRIKEPROBABILITY                MetricType = "STRIKE_PROBABILITY"
	MetricTypeSTRIKEVALUEADDED                 MetricType = "STRIKE_VALUE_ADDED"
	MetricTypeSWINGLENGTH                      MetricType = "SWING_LENGTH"
	MetricTypeSWORDSWING                       MetricType = "SWORD_SWING"
	MetricTypeTAGFIRSTTOSECOND                 MetricType = "TAG_FIRST_TO_SECOND"
	MetricTypeTAGSECONDTOTHIRD                 MetricType = "TAG_SECOND_TO_THIRD"
	MetricTypeTAGTHIRDTOHOME                   MetricType = "TAG_THIRD_TO_HOME"
	MetricTypeTHIRDTOHOME                      MetricType = "THIRD_TO_HOME"
	MetricTypeTHIRDTOHOMEALL                   MetricType = "THIRD_TO_HOME_ALL"
	MetricTypeTHROWANGLE                       MetricType = "THROW_ANGLE"
	MetricTypeTHROWDISTANCE                    MetricType = "THROW_DISTANCE"
	MetricTypeTHROWDISTANCEWITHBOUNCES         MetricType = "THROW_DISTANCE_WITH_BOUNCES"
	MetricTypeTHROWINGACCURACY                 MetricType = "THROWING_ACCURACY"
	MetricTypeTIMEOUTOFBOX                     MetricType = "TIME_OUT_OF_BOX"
	MetricTypeTOPACCELERATION                  MetricType = "TOP_ACCELERATION"
	MetricTypeTOPSPEED                         MetricType = "TOP_SPEED"
	MetricTypeTOTALDISTANCECOVERED             MetricType = "TOTAL_DISTANCE_COVERED"
	MetricTypeVERTICALBREAK                    MetricType = "VERTICAL_BREAK"
	MetricTypeVERTICALBREAKINDUCED             MetricType = "VERTICAL_BREAK_INDUCED"
	MetricTypeWALLBALLCLASSIFICATION           MetricType = "WALL_BALL_CLASSIFICATION"
	MetricTypeWINPROBABILITYADDED              MetricType = "WIN_PROBABILITY_ADDED"
)

// Defines values for OrganizationType.
const (
	OrganizationTypeDIVISION   OrganizationType = "DIVISION"
	OrganizationTypeLEAGUE     OrganizationType = "LEAGUE"
	OrganizationTypeLEAGUELIST OrganizationType = "LEAGUE_LIST"
	OrganizationTypePLAYER     OrganizationType = "PLAYER"
	OrganizationTypeSPORT      OrganizationType = "SPORT"
	OrganizationTypeTEAM       OrganizationType = "TEAM"
)

// Defines values for PersonLeadersEnum.
const (
	PersonLeadersEnumAIROUTS                   PersonLeadersEnum = "AIROUTS"
	PersonLeadersEnumASSISTS                   PersonLeadersEnum = "ASSISTS"
	PersonLeadersEnumATBAT                     PersonLeadersEnum = "AT_BAT"
	PersonLeadersEnumBALK                      PersonLeadersEnum = "BALK"
	PersonLeadersEnumBASEBALLWINS              PersonLeadersEnum = "BASEBALL_WINS"
	PersonLeadersEnumBATTINGAVERAGE            PersonLeadersEnum = "BATTING_AVERAGE"
	PersonLeadersEnumBLOWNSAVES                PersonLeadersEnum = "BLOWN_SAVES"
	PersonLeadersEnumCATCHERERA                PersonLeadersEnum = "CATCHER_ERA"
	PersonLeadersEnumCATCHERSINTERFERENCE      PersonLeadersEnum = "CATCHERS_INTERFERENCE"
	PersonLeadersEnumCAUGHTSTEALING            PersonLeadersEnum = "CAUGHT_STEALING"
	PersonLeadersEnumCHANCES                   PersonLeadersEnum = "CHANCES"
	PersonLeadersEnumCOMPLETEGAME              PersonLeadersEnum = "COMPLETE_GAME"
	PersonLeadersEnumDOUBLEPLAYS               PersonLeadersEnum = "DOUBLE_PLAYS"
	PersonLeadersEnumDOUBLES                   PersonLeadersEnum = "DOUBLES"
	PersonLeadersEnumEARNEDRUN                 PersonLeadersEnum = "EARNED_RUN"
	PersonLeadersEnumEARNEDRUNAVERAGE          PersonLeadersEnum = "EARNED_RUN_AVERAGE"
	PersonLeadersEnumERRORS                    PersonLeadersEnum = "ERRORS"
	PersonLeadersEnumEXTRABASEHITS             PersonLeadersEnum = "EXTRA_BASE_HITS"
	PersonLeadersEnumFIELDINGPERCENTAGE        PersonLeadersEnum = "FIELDING_PERCENTAGE"
	PersonLeadersEnumFLYOUTS                   PersonLeadersEnum = "FLYOUTS"
	PersonLeadersEnumGAMESFINISHED             PersonLeadersEnum = "GAMES_FINISHED"
	PersonLeadersEnumGAMESPLAYED               PersonLeadersEnum = "GAMES_PLAYED"
	PersonLeadersEnumGAMESSTARTED              PersonLeadersEnum = "GAMES_STARTED"
	PersonLeadersEnumGROUNDINTODOUBLEPLAYS     PersonLeadersEnum = "GROUND_INTO_DOUBLE_PLAYS"
	PersonLeadersEnumGROUNDOUTS                PersonLeadersEnum = "GROUNDOUTS"
	PersonLeadersEnumGROUNDOUTTOFLYOUTRATIO    PersonLeadersEnum = "GROUNDOUT_TO_FLYOUT_RATIO"
	PersonLeadersEnumHITBATSMAN                PersonLeadersEnum = "HIT_BATSMAN"
	PersonLeadersEnumHITBYPITCHES              PersonLeadersEnum = "HIT_BY_PITCHES"
	PersonLeadersEnumHITS                      PersonLeadersEnum = "HITS"
	PersonLeadersEnumHITSPER9INN               PersonLeadersEnum = "HITS_PER_9_INN"
	PersonLeadersEnumHOLDS                     PersonLeadersEnum = "HOLDS"
	PersonLeadersEnumHOMERUNS                  PersonLeadersEnum = "HOME_RUNS"
	PersonLeadersEnumINNINGS                   PersonLeadersEnum = "INNINGS"
	PersonLeadersEnumINNINGSPITCHED            PersonLeadersEnum = "INNINGS_PITCHED"
	PersonLeadersEnumINTENTIONALWALKS          PersonLeadersEnum = "INTENTIONAL_WALKS"
	PersonLeadersEnumLOSSES                    PersonLeadersEnum = "LOSSES"
	PersonLeadersEnumNUMBEROFPITCHES           PersonLeadersEnum = "NUMBER_OF_PITCHES"
	PersonLeadersEnumONBASEPERCENTAGE          PersonLeadersEnum = "ON_BASE_PERCENTAGE"
	PersonLeadersEnumONBASEPLUSSLUGGING        PersonLeadersEnum = "ON_BASE_PLUS_SLUGGING"
	PersonLeadersEnumOUTFIELDASSISTS           PersonLeadersEnum = "OUTFIELD_ASSISTS"
	PersonLeadersEnumPASSEDBALLS               PersonLeadersEnum = "PASSED_BALLS"
	PersonLeadersEnumPICKOFFS                  PersonLeadersEnum = "PICKOFFS"
	PersonLeadersEnumPITCHESPERINNING          PersonLeadersEnum = "PITCHES_PER_INNING"
	PersonLeadersEnumPUTOUTS                   PersonLeadersEnum = "PUT_OUTS"
	PersonLeadersEnumRANGEFACTORPER9INN        PersonLeadersEnum = "RANGE_FACTOR_PER_9_INN"
	PersonLeadersEnumRANGEFACTORPERGAME        PersonLeadersEnum = "RANGE_FACTOR_PER_GAME"
	PersonLeadersEnumRUNS                      PersonLeadersEnum = "RUNS"
	PersonLeadersEnumRUNSBATTEDIN              PersonLeadersEnum = "RUNS_BATTED_IN"
	PersonLeadersEnumSACRIFICEBUNTS            PersonLeadersEnum = "SACRIFICE_BUNTS"
	PersonLeadersEnumSACRIFICEFLIES            PersonLeadersEnum = "SACRIFICE_FLIES"
	PersonLeadersEnumSAVEOPPORTUNITIES         PersonLeadersEnum = "SAVE_OPPORTUNITIES"
	PersonLeadersEnumSAVES                     PersonLeadersEnum = "SAVES"
	PersonLeadersEnumSHUTOUTS                  PersonLeadersEnum = "SHUTOUTS"
	PersonLeadersEnumSLUGGINGPERCENTAGE        PersonLeadersEnum = "SLUGGING_PERCENTAGE"
	PersonLeadersEnumSTOLENBASEPERCENTAGE      PersonLeadersEnum = "STOLEN_BASE_PERCENTAGE"
	PersonLeadersEnumSTOLENBASES               PersonLeadersEnum = "STOLEN_BASES"
	PersonLeadersEnumSTRIKEOUTS                PersonLeadersEnum = "STRIKEOUTS"
	PersonLeadersEnumSTRIKEOUTSPER9INN         PersonLeadersEnum = "STRIKEOUTS_PER_9_INN"
	PersonLeadersEnumSTRIKEOUTWALKRATIO        PersonLeadersEnum = "STRIKEOUT_WALK_RATIO"
	PersonLeadersEnumTHROWINGERRORS            PersonLeadersEnum = "THROWING_ERRORS"
	PersonLeadersEnumTOTALBASES                PersonLeadersEnum = "TOTAL_BASES"
	PersonLeadersEnumTOTALBATTERSFACED         PersonLeadersEnum = "TOTAL_BATTERS_FACED"
	PersonLeadersEnumTOTALPLATEAPPEARANCES     PersonLeadersEnum = "TOTAL_PLATE_APPEARANCES"
	PersonLeadersEnumTRIPLEPLAYS               PersonLeadersEnum = "TRIPLE_PLAYS"
	PersonLeadersEnumTRIPLES                   PersonLeadersEnum = "TRIPLES"
	PersonLeadersEnumWALKS                     PersonLeadersEnum = "WALKS"
	PersonLeadersEnumWALKSHITSPERINNINGPITCHED PersonLeadersEnum = "WALKS_HITS_PER_INNING_PITCHED"
	PersonLeadersEnumWALKSPER9INN              PersonLeadersEnum = "WALKS_PER_9_INN"
	PersonLeadersEnumWILDPITCH                 PersonLeadersEnum = "WILD_PITCH"
	PersonLeadersEnumWINPERCENTAGE             PersonLeadersEnum = "WIN_PERCENTAGE"
)

// Defines values for PitchCode.
const (
	PitchCodeAUTOMATICBALL                           PitchCode = "AUTOMATIC_BALL"
	PitchCodeAUTOMATICBALLCATCHERPITCHTIMERVIOLATION PitchCode = "AUTOMATIC_BALL_CATCHER_PITCH_TIMER_VIOLATION"
	PitchCodeAUTOMATICBALLDEFSHIFTVIOLATION          PitchCode = "AUTOMATIC_BALL_DEF_SHIFT_VIOLATION"
	PitchCodeAUTOMATICBALLINTENTIONAL                PitchCode = "AUTOMATIC_BALL_INTENTIONAL"
	PitchCodeAUTOMATICBALLPITCHERPITCHTIMERVIOLATION PitchCode = "AUTOMATIC_BALL_PITCHER_PITCH_TIMER_VIOLATION"
	PitchCodeAUTOMATICSTRIKE                         PitchCode = "AUTOMATIC_STRIKE"
	PitchCodeAUTOMATICSTRIKEBATTERTIMEOUTVIOLATION   PitchCode = "AUTOMATIC_STRIKE_BATTER_TIMEOUT_VIOLATION"
	PitchCodeAUTOMATICSTRIKEPITCHTIMERVIOLATION      PitchCode = "AUTOMATIC_STRIKE_PITCH_TIMER_VIOLATION"
	PitchCodeBALL                                    PitchCode = "BALL"
	PitchCodeBLOCKEDBALL                             PitchCode = "BLOCKED_BALL"
	PitchCodeBUNTFOULTIP                             PitchCode = "BUNT_FOUL_TIP"
	PitchCodeCALLEDSTRIKE                            PitchCode = "CALLED_STRIKE"
	PitchCodeFOUL                                    PitchCode = "FOUL"
	PitchCodeFOULBUNT                                PitchCode = "FOUL_BUNT"
	PitchCodeFOULPITCHOUT                            PitchCode = "FOUL_PITCHOUT"
	PitchCodeFOULTIP                                 PitchCode = "FOUL_TIP"
	PitchCodeHITBYPITCH                              PitchCode = "HIT_BY_PITCH"
	PitchCodeHITINTOPLAY                             PitchCode = "HIT_INTO_PLAY"
	PitchCodeHITINTOPLAYNOOUT                        PitchCode = "HIT_INTO_PLAY_NO_OUT"
	PitchCodeHITINTOPLAYSCORE                        PitchCode = "HIT_INTO_PLAY_SCORE"
	PitchCodeINTENTBALL                              PitchCode = "INTENT_BALL"
	PitchCodeMISSEDBUNT                              PitchCode = "MISSED_BUNT"
	PitchCodePITCHOUT                                PitchCode = "PITCHOUT"
	PitchCodePITCHOUTHITINTOPLAY                     PitchCode = "PITCHOUT_HIT_INTO_PLAY"
	PitchCodePITCHOUTHITINTOPLAYNOOUT                PitchCode = "PITCHOUT_HIT_INTO_PLAY_NO_OUT"
	PitchCodePITCHOUTHITINTOPLAYSCORE                PitchCode = "PITCHOUT_HIT_INTO_PLAY_SCORE"
	PitchCodeSWINGINGPITCHOUT                        PitchCode = "SWINGING_PITCHOUT"
	PitchCodeSWINGINGSTRIKE                          PitchCode = "SWINGING_STRIKE"
	PitchCodeSWINGINGSTRIKEBLOCKED                   PitchCode = "SWINGING_STRIKE_BLOCKED"
	PitchCodeUNKNOWN                                 PitchCode = "UNKNOWN"
	PitchCodeUNKNOWNSTRIKE                           PitchCode = "UNKNOWN_STRIKE"
)

// Defines values for PitchType.
const (
	PitchTypeAUTOMATICBALL   PitchType = "AUTOMATIC_BALL"
	PitchTypeAUTOMATICSTRIKE PitchType = "AUTOMATIC_STRIKE"
	PitchTypeCHANGEUP        PitchType = "CHANGE_UP"
	PitchTypeCURVEBALL       PitchType = "CURVE_BALL"
	PitchTypeCUTTER          PitchType = "CUTTER"
	PitchTypeEEPHUS          PitchType = "EEPHUS"
	PitchTypeFASTBALL        PitchType = "FASTBALL"
	PitchTypeFASTBALL2SEAM   PitchType = "FAST_BALL_2_SEAM"
	PitchTypeFASTBALL4SEAM   PitchType = "FAST_BALL_4_SEAM"
	PitchTypeFORKBALL        PitchType = "FORK_BALL"
	PitchTypeGYROBALL        PitchType = "GYRO_BALL"
	PitchTypeINTENTIONALBALL PitchType = "INTENTIONAL_BALL"
	PitchTypeKNUCKLEBALL     PitchType = "KNUCKLE_BALL"
	PitchTypeKNUCKLECURVE    PitchType = "KNUCKLE_CURVE"
	PitchTypeNOPITCH         PitchType = "NO_PITCH"
	PitchTypePITCHOUT        PitchType = "PITCHOUT"
	PitchTypeSCREWBALL       PitchType = "SCREW_BALL"
	PitchTypeSINKER          PitchType = "SINKER"
	PitchTypeSLIDER          PitchType = "SLIDER"
	PitchTypeSLOWCURVE       PitchType = "SLOW_CURVE"
	PitchTypeSLURVE          PitchType = "SLURVE"
	PitchTypeSLUTTER         PitchType = "SLUTTER"
	PitchTypeSN              PitchType = "SN"
	PitchTypeSPLITTER        PitchType = "SPLITTER"
	PitchTypeUNNKNOWN        PitchType = "UNNKNOWN"
)

// Defines values for PitcherDetailType.
const (
	PitcherDetailTypeATBAT                 PitcherDetailType = "AT_BAT"
	PitcherDetailTypeBALK                  PitcherDetailType = "BALK"
	PitcherDetailTypeBALL                  PitcherDetailType = "BALL"
	PitcherDetailTypeBALLBLOCKED           PitcherDetailType = "BALL_BLOCKED"
	PitcherDetailTypeBLOWNSAVE             PitcherDetailType = "BLOWN_SAVE"
	PitcherDetailTypeBUNTFOULTIP           PitcherDetailType = "BUNT_FOUL_TIP"
	PitcherDetailTypeCALLEDSTRIKE          PitcherDetailType = "CALLED_STRIKE"
	PitcherDetailTypeCATCHERINTERFERENCE   PitcherDetailType = "CATCHER_INTERFERENCE"
	PitcherDetailTypeCAUGHTSTEALING2B      PitcherDetailType = "CAUGHT_STEALING_2B"
	PitcherDetailTypeCAUGHTSTEALING3B      PitcherDetailType = "CAUGHT_STEALING_3B"
	PitcherDetailTypeCAUGHTSTEALINGHP      PitcherDetailType = "CAUGHT_STEALING_HP"
	PitcherDetailTypeCOMPLETEGAME          PitcherDetailType = "COMPLETE_GAME"
	PitcherDetailTypeDOUBLE                PitcherDetailType = "DOUBLE"
	PitcherDetailTypeEARNEDRUN             PitcherDetailType = "EARNED_RUN"
	PitcherDetailTypeFLYOUT                PitcherDetailType = "FLYOUT"
	PitcherDetailTypeFOUL                  PitcherDetailType = "FOUL"
	PitcherDetailTypeFOULBUNT              PitcherDetailType = "FOUL_BUNT"
	PitcherDetailTypeFOULPITCHOUT          PitcherDetailType = "FOUL_PITCHOUT"
	PitcherDetailTypeFOULTIP               PitcherDetailType = "FOUL_TIP"
	PitcherDetailTypeGAME                  PitcherDetailType = "GAME"
	PitcherDetailTypeGAMEFINISHED          PitcherDetailType = "GAME_FINISHED"
	PitcherDetailTypeGAMESTARTED           PitcherDetailType = "GAME_STARTED"
	PitcherDetailTypeGROUNDOUT             PitcherDetailType = "GROUNDOUT"
	PitcherDetailTypeHITBYPITCH            PitcherDetailType = "HIT_BY_PITCH"
	PitcherDetailTypeHITINTOPLAY           PitcherDetailType = "HIT_INTO_PLAY"
	PitcherDetailTypeHOLD                  PitcherDetailType = "HOLD"
	PitcherDetailTypeHOMERUN               PitcherDetailType = "HOME_RUN"
	PitcherDetailTypeINHERITEDRUNNER       PitcherDetailType = "INHERITED_RUNNER"
	PitcherDetailTypeINHERITEDRUNNERSCORED PitcherDetailType = "INHERITED_RUNNER_SCORED"
	PitcherDetailTypeINTENTBALL            PitcherDetailType = "INTENT_BALL"
	PitcherDetailTypeINTENTWALK            PitcherDetailType = "INTENT_WALK"
	PitcherDetailTypeLINEOUT               PitcherDetailType = "LINEOUT"
	PitcherDetailTypeLOSS                  PitcherDetailType = "LOSS"
	PitcherDetailTypeMISSEDBUNT            PitcherDetailType = "MISSED_BUNT"
	PitcherDetailTypeOUT                   PitcherDetailType = "OUT"
	PitcherDetailTypePICKOFF1B             PitcherDetailType = "PICKOFF_1B"
	PitcherDetailTypePICKOFF2B             PitcherDetailType = "PICKOFF_2B"
	PitcherDetailTypePICKOFF3B             PitcherDetailType = "PICKOFF_3B"
	PitcherDetailTypePITCHOUT              PitcherDetailType = "PITCHOUT"
	PitcherDetailTypePITCHOUTHITINTOPLAY   PitcherDetailType = "PITCHOUT_HIT_INTO_PLAY"
	PitcherDetailTypePLATEAPPEARANCE       PitcherDetailType = "PLATE_APPEARANCE"
	PitcherDetailTypePOPOUT                PitcherDetailType = "POPOUT"
	PitcherDetailTypeRBI                   PitcherDetailType = "RBI"
	PitcherDetailTypeREACHEDONINTERFERENCE PitcherDetailType = "REACHED_ON_INTERFERENCE"
	PitcherDetailTypeRELIEFNOOUT           PitcherDetailType = "RELIEF_NO_OUT"
	PitcherDetailTypeRUN                   PitcherDetailType = "RUN"
	PitcherDetailTypeSACBUNT               PitcherDetailType = "SAC_BUNT"
	PitcherDetailTypeSACFLY                PitcherDetailType = "SAC_FLY"
	PitcherDetailTypeSAVE                  PitcherDetailType = "SAVE"
	PitcherDetailTypeSHUTOUT               PitcherDetailType = "SHUTOUT"
	PitcherDetailTypeSINGLE                PitcherDetailType = "SINGLE"
	PitcherDetailTypeSTOLENBASE2B          PitcherDetailType = "STOLEN_BASE_2B"
	PitcherDetailTypeSTOLENBASE3B          PitcherDetailType = "STOLEN_BASE_3B"
	PitcherDetailTypeSTOLENBASEHP          PitcherDetailType = "STOLEN_BASE_HP"
	PitcherDetailTypeSTRIKEOUT             PitcherDetailType = "STRIKEOUT"
	PitcherDetailTypeSWINGINGPITCHOUT      PitcherDetailType = "SWINGING_PITCHOUT"
	PitcherDetailTypeSWINGINGSTRIKE        PitcherDetailType = "SWINGING_STRIKE"
	PitcherDetailTypeSWINGINGSTRIKEBLOCKED PitcherDetailType = "SWINGING_STRIKE_BLOCKED"
	PitcherDetailTypeTEAMEARNEDRUN         PitcherDetailType = "TEAM_EARNED_RUN"
	PitcherDetailTypeTEAMOUT               PitcherDetailType = "TEAM_OUT"
	PitcherDetailTypeTEAMUNEARNEDRUN       PitcherDetailType = "TEAM_UNEARNED_RUN"
	PitcherDetailTypeTRIPLE                PitcherDetailType = "TRIPLE"
	PitcherDetailTypeUNEARNEDRUN           PitcherDetailType = "UNEARNED_RUN"
	PitcherDetailTypeUNKNOWN               PitcherDetailType = "UNKNOWN"
	PitcherDetailTypeUNKNOWNSTRIKE         PitcherDetailType = "UNKNOWN_STRIKE"
	PitcherDetailTypeWALK                  PitcherDetailType = "WALK"
	PitcherDetailTypeWILDPITCH             PitcherDetailType = "WILD_PITCH"
	PitcherDetailTypeWIN                   PitcherDetailType = "WIN"
)

// Defines values for Platform.
const (
	ANDROIDPHONE  Platform = "ANDROID_PHONE"
	ANDROIDTABLET Platform = "ANDROID_TABLET"
	APPLETV       Platform = "APPLETV"
	CHROMECAST    Platform = "CHROMECAST"
	IOSPHONE      Platform = "IOS_PHONE"
	IOSTABLET     Platform = "IOS_TABLET"
	PLAYSTATION   Platform = "PLAYSTATION"
	ROKU          Platform = "ROKU"
	TVOS          Platform = "TV_OS"
	WEB           Platform = "WEB"
	XBOX360       Platform = "XBOX_360"
	XBOXONE       Platform = "XBOX_ONE"
)

// Defines values for PlayerActiveStatusEnum.
const (
	PlayerActiveStatusEnumACTIVE   PlayerActiveStatusEnum = "ACTIVE"
	PlayerActiveStatusEnumBOTH     PlayerActiveStatusEnum = "BOTH"
	PlayerActiveStatusEnumINACTIVE PlayerActiveStatusEnum = "INACTIVE"
	PlayerActiveStatusEnumPENDING  PlayerActiveStatusEnum = "PENDING"
)

// Defines values for PlayerPoolEnum.
const (
	PlayerPoolEnumALL               PlayerPoolEnum = "ALL"
	PlayerPoolEnumALLCURRENT        PlayerPoolEnum = "ALL_CURRENT"
	PlayerPoolEnumCURRENT           PlayerPoolEnum = "CURRENT"
	PlayerPoolEnumORGANIZATION      PlayerPoolEnum = "ORGANIZATION"
	PlayerPoolEnumORGANIZATIONNOMLB PlayerPoolEnum = "ORGANIZATION_NO_MLB"
	PlayerPoolEnumQUALIFIED         PlayerPoolEnum = "QUALIFIED"
	PlayerPoolEnumQUALIFIEDCURRENT  PlayerPoolEnum = "QUALIFIED_CURRENT"
	PlayerPoolEnumQUALIFIEDROOKIES  PlayerPoolEnum = "QUALIFIED_ROOKIES"
	PlayerPoolEnumROOKIES           PlayerPoolEnum = "ROOKIES"
)

// Defines values for Privilege.
const (
	PrivilegeADMIN                     Privilege = "ADMIN"
	PrivilegeANONYMOUS                 Privilege = "ANONYMOUS"
	PrivilegeAUDITUSER                 Privilege = "AUDIT_USER"
	PrivilegeBROADCAST                 Privilege = "BROADCAST"
	PrivilegeCANGETALLCLUBOWNED        Privilege = "CAN_GET_ALL_CLUB_OWNED"
	PrivilegeCANGETBALLTRACKINGDATA    Privilege = "CAN_GET_BALL_TRACKING_DATA"
	PrivilegeCANGETBATTRACKINGDATA     Privilege = "CAN_GET_BAT_TRACKING_DATA"
	PrivilegeCANGETHITTERBIOMECHANICS  Privilege = "CAN_GET_HITTER_BIOMECHANICS"
	PrivilegeCANGETPITCHERBIOMECHANICS Privilege = "CAN_GET_PITCHER_BIOMECHANICS"
	PrivilegeCANGETPLAYERTRACKINGDATA  Privilege = "CAN_GET_PLAYER_TRACKING_DATA"
	PrivilegeCANGETPOSETRACKINGDATA    Privilege = "CAN_GET_POSE_TRACKING_DATA"
	PrivilegeCANGETSKELETALDATA        Privilege = "CAN_GET_SKELETAL_DATA"
	PrivilegeCANGETSTATSEARCH          Privilege = "CAN_GET_STAT_SEARCH"
	PrivilegeCANGETWEATHERDATA         Privilege = "CAN_GET_WEATHER_DATA"
	PrivilegeCANUPDATEBATTRACKINGDATA  Privilege = "CAN_UPDATE_BAT_TRACKING_DATA"
	PrivilegeCANUPDATESKELETALDATA     Privilege = "CAN_UPDATE_SKELETAL_DATA"
	PrivilegeCANUPDATEWEATHERDATA      Privilege = "CAN_UPDATE_WEATHER_DATA"
	PrivilegeCOMPTIX                   Privilege = "COMPTIX"
	PrivilegeEDITORIAL                 Privilege = "EDITORIAL"
	PrivilegeENHANCEDBROADCAST         Privilege = "ENHANCED_BROADCAST"
	PrivilegeMANAGER                   Privilege = "MANAGER"
	PrivilegePRUSER                    Privilege = "PR_USER"
	PrivilegeSUPERUSER                 Privilege = "SUPER_USER"
	PrivilegeTEAM                      Privilege = "TEAM"
	PrivilegeTICKETING                 Privilege = "TICKETING"
	PrivilegeUSER                      Privilege = "USER"
)

// Defines values for PublicFacingEnum.
const (
	PublicFacingEnumALL             PublicFacingEnum = "ALL"
	PublicFacingEnumNONPUBLICFACING PublicFacingEnum = "NON_PUBLIC_FACING"
	PublicFacingEnumPUBLICFACING    PublicFacingEnum = "PUBLIC_FACING"
)

// Defines values for Role.
const (
	RoleADMIN             Role = "ADMIN"
	RoleAUDITUSER         Role = "AUDIT_USER"
	RoleBROADCAST         Role = "BROADCAST"
	RoleCOMPTIX           Role = "COMPTIX"
	RoleEDITORIAL         Role = "EDITORIAL"
	RoleENHANCEDBROADCAST Role = "ENHANCED_BROADCAST"
	RoleMANAGER           Role = "MANAGER"
	RolePRUSER            Role = "PR_USER"
	RoleROLEANONYMOUS     Role = "ROLE_ANONYMOUS"
	RoleSUPERUSER         Role = "SUPER_USER"
	RoleTEAM              Role = "TEAM"
	RoleTICKETING         Role = "TICKETING"
	RoleUSER              Role = "USER"
)

// Defines values for RoofType.
const (
	NoRoof                RoofType = "noRoof"
	RoofClosedNoPanel     RoofType = "roofClosedNoPanel"
	RoofClosedPanelClosed RoofType = "roofClosedPanelClosed"
	RoofClosedPanelOpen   RoofType = "roofClosedPanelOpen"
	RoofOpen              RoofType = "roofOpen"
	Unknown               RoofType = "unknown"
)

// Defines values for RosterType.
const (
	RosterTypeACTIVE            RosterType = "ACTIVE"
	RosterTypeALLTIME           RosterType = "ALL_TIME"
	RosterTypeCOACH             RosterType = "COACH"
	RosterTypeDEPTHCHART        RosterType = "DEPTH_CHART"
	RosterTypeFORTYMAN          RosterType = "FORTY_MAN"
	RosterTypeFULLROSTER        RosterType = "FULL_ROSTER"
	RosterTypeFULLSEASON        RosterType = "FULL_SEASON"
	RosterTypeGAMEDAY           RosterType = "GAMEDAY"
	RosterTypeNONROSTERINVITEES RosterType = "NON_ROSTER_INVITEES"
)

// Defines values for RunnerDetailType.
const (
	RunnerDetailTypeADVANCEDONFORCE           RunnerDetailType = "ADVANCED_ON_FORCE"
	RunnerDetailTypeADVANCEDONPLAY            RunnerDetailType = "ADVANCED_ON_PLAY"
	RunnerDetailTypeADVANCEDONTHROW           RunnerDetailType = "ADVANCED_ON_THROW"
	RunnerDetailTypeCAUGHTSTEALING2B          RunnerDetailType = "CAUGHT_STEALING_2B"
	RunnerDetailTypeCAUGHTSTEALING3B          RunnerDetailType = "CAUGHT_STEALING_3B"
	RunnerDetailTypeCAUGHTSTEALINGHOME        RunnerDetailType = "CAUGHT_STEALING_HOME"
	RunnerDetailTypeDEFENSIVEINDIFFERENCE     RunnerDetailType = "DEFENSIVE_INDIFFERENCE"
	RunnerDetailTypeDOUBLEDOFF                RunnerDetailType = "DOUBLED_OFF"
	RunnerDetailTypeENDBASE                   RunnerDetailType = "END_BASE"
	RunnerDetailTypeFIELDERSCHOICE            RunnerDetailType = "FIELDERS_CHOICE"
	RunnerDetailTypeFORCEDOUT                 RunnerDetailType = "FORCED_OUT"
	RunnerDetailTypeHITBYBATTEDBALL           RunnerDetailType = "HIT_BY_BATTED_BALL"
	RunnerDetailTypeINTERFERENCE              RunnerDetailType = "INTERFERENCE"
	RunnerDetailTypeLEFTEARLY                 RunnerDetailType = "LEFT_EARLY"
	RunnerDetailTypeOUTADVANCING              RunnerDetailType = "OUT_ADVANCING"
	RunnerDetailTypeOUTONAPPEAL               RunnerDetailType = "OUT_ON_APPEAL"
	RunnerDetailTypeOUTOVERRUNNING            RunnerDetailType = "OUT_OVER_RUNNING"
	RunnerDetailTypeOUTRETURNING              RunnerDetailType = "OUT_RETURNING"
	RunnerDetailTypeOUTSTRETCHING             RunnerDetailType = "OUT_STRETCHING"
	RunnerDetailTypePICKOFF1B                 RunnerDetailType = "PICKOFF_1B"
	RunnerDetailTypePICKOFF2B                 RunnerDetailType = "PICKOFF_2B"
	RunnerDetailTypePICKOFF3B                 RunnerDetailType = "PICKOFF_3B"
	RunnerDetailTypePICKOFFCAUGHTSTEALING2B   RunnerDetailType = "PICKOFF_CAUGHT_STEALING_2B"
	RunnerDetailTypePICKOFFCAUGHTSTEALING3B   RunnerDetailType = "PICKOFF_CAUGHT_STEALING_3B"
	RunnerDetailTypePICKOFFCAUGHTSTEALINGHOME RunnerDetailType = "PICKOFF_CAUGHT_STEALING_HOME"
	RunnerDetailTypePICKOFFERROR1B            RunnerDetailType = "PICKOFF_ERROR_1B"
	RunnerDetailTypePICKOFFERROR2B            RunnerDetailType = "PICKOFF_ERROR_2B"
	RunnerDetailTypePICKOFFERROR3B            RunnerDetailType = "PICKOFF_ERROR_3B"
	RunnerDetailTypeRUNDOWN                   RunnerDetailType = "RUNDOWN"
	RunnerDetailTypeRUNNERGOING               RunnerDetailType = "RUNNER_GOING"
	RunnerDetailTypeRUNNEROUT                 RunnerDetailType = "RUNNER_OUT"
	RunnerDetailTypeSEQUENCE                  RunnerDetailType = "SEQUENCE"
	RunnerDetailTypeSTARTBASE                 RunnerDetailType = "START_BASE"
	RunnerDetailTypeSTOLENBASE2B              RunnerDetailType = "STOLEN_BASE_2B"
	RunnerDetailTypeSTOLENBASE3B              RunnerDetailType = "STOLEN_BASE_3B"
	RunnerDetailTypeSTOLENBASEHOME            RunnerDetailType = "STOLEN_BASE_HOME"
	RunnerDetailTypeTAGGEDOUT                 RunnerDetailType = "TAGGED_OUT"
	RunnerDetailTypeTHROWNOUT                 RunnerDetailType = "THROWN_OUT"
	RunnerDetailTypeUNKNOWN                   RunnerDetailType = "UNKNOWN"
)

// Defines values for ScheduleEventTypes.
const (
	ScheduleEventTypesALLSTARWEEKENDEVENT       ScheduleEventTypes = "ALL_STAR_WEEKEND_EVENT"
	ScheduleEventTypesBALLPARKTOURS             ScheduleEventTypes = "BALLPARK_TOURS"
	ScheduleEventTypesCULTURALEVENTS            ScheduleEventTypes = "CULTURAL_EVENTS"
	ScheduleEventTypesEXHIBITION                ScheduleEventTypes = "EXHIBITION"
	ScheduleEventTypesFESTIVAL                  ScheduleEventTypes = "FESTIVAL"
	ScheduleEventTypesFULLSQUADREPORTS          ScheduleEventTypes = "FULL_SQUAD_REPORTS"
	ScheduleEventTypesIMPORTANTDATES            ScheduleEventTypes = "IMPORTANT_DATES"
	ScheduleEventTypesKIDSANDFAMILY             ScheduleEventTypes = "KIDS_AND_FAMILY"
	ScheduleEventTypesMUSIC                     ScheduleEventTypes = "MUSIC"
	ScheduleEventTypesOTHER                     ScheduleEventTypes = "OTHER"
	ScheduleEventTypesPITCHERSANDCATCHERSREPORT ScheduleEventTypes = "PITCHERS_AND_CATCHERS_REPORT"
	ScheduleEventTypesPOSTSEASONGAMES           ScheduleEventTypes = "POSTSEASON_GAMES"
	ScheduleEventTypesPROMOTIONLOGOBACKGROUND   ScheduleEventTypes = "PROMOTION_LOGO_BACKGROUND"
	ScheduleEventTypesPROMOTIONLOGOSINGEDATE    ScheduleEventTypes = "PROMOTION_LOGO_SINGE_DATE"
	ScheduleEventTypesSPRINGTRAININGGAMES       ScheduleEventTypes = "SPRING_TRAINING_GAMES"
	ScheduleEventTypesSTHEVENTS                 ScheduleEventTypes = "STH_EVENTS"
	ScheduleEventTypesSTUDIOEVENT               ScheduleEventTypes = "STUDIO_EVENT"
	ScheduleEventTypesTEAMEVENT                 ScheduleEventTypes = "TEAM_EVENT"
	ScheduleEventTypesTRACKINGDATAEVENTS        ScheduleEventTypes = "TRACKING_DATA_EVENTS"
)

// Defines values for ScheduleTypeEnum.
const (
	EVENTSCHEDULE ScheduleTypeEnum = "EVENTSCHEDULE"
	GAMESCHEDULE  ScheduleTypeEnum = "GAMESCHEDULE"
	XREF          ScheduleTypeEnum = "XREF"
)

// Defines values for Site.
const (
	SiteMILB Site = "MILB"
	SiteMLB  Site = "MLB"
)

// Defines values for SortOrderEnum.
const (
	ASC  SortOrderEnum = "ASC"
	DESC SortOrderEnum = "DESC"
)

// Defines values for SportActiveStatusEnum.
const (
	SportActiveStatusEnumACTIVE   SportActiveStatusEnum = "ACTIVE"
	SportActiveStatusEnumBOTH     SportActiveStatusEnum = "BOTH"
	SportActiveStatusEnumINACTIVE SportActiveStatusEnum = "INACTIVE"
	SportActiveStatusEnumPENDING  SportActiveStatusEnum = "PENDING"
)

// Defines values for SportTypeEnum.
const (
	SportTypeEnumALL        SportTypeEnum = "ALL"
	SportTypeEnumBASEBALL   SportTypeEnum = "BASEBALL"
	SportTypeEnumBASKETBALL SportTypeEnum = "BASKETBALL"
	SportTypeEnumGOLF       SportTypeEnum = "GOLF"
	SportTypeEnumHOCKEY     SportTypeEnum = "HOCKEY"
	SportTypeEnumUNKNOWN    SportTypeEnum = "UNKNOWN"
)

// Defines values for StandingsType.
const (
	BYCONFERENCE        StandingsType = "BY_CONFERENCE"
	BYDIVISION          StandingsType = "BY_DIVISION"
	BYLEAGUE            StandingsType = "BY_LEAGUE"
	BYORGANIZATION      StandingsType = "BY_ORGANIZATION"
	CURRENTHALF         StandingsType = "CURRENT_HALF"
	DIVISIONLEADERS     StandingsType = "DIVISION_LEADERS"
	FIRSTHALF           StandingsType = "FIRST_HALF"
	POSTSEASON          StandingsType = "POSTSEASON"
	REGULARSEASON       StandingsType = "REGULAR_SEASON"
	SECONDHALF          StandingsType = "SECOND_HALF"
	SPRINGTRAINING      StandingsType = "SPRING_TRAINING"
	WILDCARD            StandingsType = "WILD_CARD"
	WILDCARDWITHLEADERS StandingsType = "WILD_CARD_WITH_LEADERS"
)

// Defines values for StatField.
const (
	ADVANCED     StatField = "ADVANCED"
	EXPECTED     StatField = "EXPECTED"
	PERCENTILE   StatField = "PERCENTILE"
	RANKING      StatField = "RANKING"
	SABERMETRICS StatField = "SABERMETRICS"
	STANDARD     StatField = "STANDARD"
	TRACKING     StatField = "TRACKING"
)

// Defines values for StatGroup.
const (
	StatGroupCATCHING StatGroup = "CATCHING"
	StatGroupFIELDING StatGroup = "FIELDING"
	StatGroupGAME     StatGroup = "GAME"
	StatGroupHITTING  StatGroup = "HITTING"
	StatGroupPITCHING StatGroup = "PITCHING"
	StatGroupRUNNING  StatGroup = "RUNNING"
	StatGroupSTREAK   StatGroup = "STREAK"
	StatGroupTEAM     StatGroup = "TEAM"
)

// Defines values for StatType.
const (
	StatTypeADVANCED                  StatType = "ADVANCED"
	StatTypeATGAMESTART               StatType = "AT_GAME_START"
	StatTypeAVAILABLESTATS            StatType = "AVAILABLE_STATS"
	StatTypeBYDATERANGE               StatType = "BY_DATE_RANGE"
	StatTypeBYDATERANGEADVANCED       StatType = "BY_DATE_RANGE_ADVANCED"
	StatTypeBYDAYOFWEEK               StatType = "BY_DAY_OF_WEEK"
	StatTypeBYDAYOFWEEKPLAYOFFS       StatType = "BY_DAY_OF_WEEK_PLAYOFFS"
	StatTypeBYMONTH                   StatType = "BY_MONTH"
	StatTypeBYMONTHPLAYOFFS           StatType = "BY_MONTH_PLAYOFFS"
	StatTypeCAREER                    StatType = "CAREER"
	StatTypeCAREERADVANCED            StatType = "CAREER_ADVANCED"
	StatTypeCAREERPLAYOFFS            StatType = "CAREER_PLAYOFFS"
	StatTypeCAREERREGULARSEASON       StatType = "CAREER_REGULAR_SEASON"
	StatTypeCAREERSTATSPLITS          StatType = "CAREER_STAT_SPLITS"
	StatTypeEXPECTEDSTATISTICS        StatType = "EXPECTED_STATISTICS"
	StatTypeFIRSTYEARSTATS            StatType = "FIRST_YEAR_STATS"
	StatTypeGAMELOG                   StatType = "GAME_LOG"
	StatTypeGAMETYPESTATS             StatType = "GAME_TYPE_STATS"
	StatTypeHOMEANDAWAY               StatType = "HOME_AND_AWAY"
	StatTypeHOMEANDAWAYPLAYOFFS       StatType = "HOME_AND_AWAY_PLAYOFFS"
	StatTypeHOTCOLDZONES              StatType = "HOT_COLD_ZONES"
	StatTypeLASTXGAMES                StatType = "LAST_X_GAMES"
	StatTypeLASTYEARSTATS             StatType = "LAST_YEAR_STATS"
	StatTypeMETRICAVERAGES            StatType = "METRIC_AVERAGES"
	StatTypeMETRICLOG                 StatType = "METRIC_LOG"
	StatTypeOPPONENTSFACED            StatType = "OPPONENTS_FACED"
	StatTypeOUTSABOVEAVERAGE          StatType = "OUTS_ABOVE_AVERAGE"
	StatTypePITCHARSENAL              StatType = "PITCH_ARSENAL"
	StatTypePITCHLOG                  StatType = "PITCH_LOG"
	StatTypePLAYLOG                   StatType = "PLAY_LOG"
	StatTypePROJECTED                 StatType = "PROJECTED"
	StatTypePROJECTEDROS              StatType = "PROJECTED_ROS"
	StatTypeRANKINGS                  StatType = "RANKINGS"
	StatTypeRANKINGSBYYEAR            StatType = "RANKINGS_BY_YEAR"
	StatTypeSABERMETRICS              StatType = "SABERMETRICS"
	StatTypeSABERMETRICSMULTITEAM     StatType = "SABERMETRICS_MULTI_TEAM"
	StatTypeSEASON                    StatType = "SEASON"
	StatTypeSEASONADVANCED            StatType = "SEASON_ADVANCED"
	StatTypeSPRAYCHART                StatType = "SPRAY_CHART"
	StatTypeSTANDARD                  StatType = "STANDARD"
	StatTypeSTATSPLITS                StatType = "STAT_SPLITS"
	StatTypeSTATSPLITSADVANCED        StatType = "STAT_SPLITS_ADVANCED"
	StatTypeSTATSSINGLESEASON         StatType = "STATS_SINGLE_SEASON"
	StatTypeSTATSSINGLESEASONADVANCED StatType = "STATS_SINGLE_SEASON_ADVANCED"
	StatTypeTRACKINGSTATISTICS        StatType = "TRACKING_STATISTICS"
	StatTypeVSOPPONENTS               StatType = "VS_OPPONENTS"
	StatTypeVSPLAYER                  StatType = "VS_PLAYER"
	StatTypeVSPLAYER5Y                StatType = "VS_PLAYER_5Y"
	StatTypeVSPLAYERTOTAL             StatType = "VS_PLAYER_TOTAL"
	StatTypeVSTEAM                    StatType = "VS_TEAM"
	StatTypeVSTEAM5Y                  StatType = "VS_TEAM_5Y"
	StatTypeVSTEAMTOTAL               StatType = "VS_TEAM_TOTAL"
	StatTypeWINLOSS                   StatType = "WIN_LOSS"
	StatTypeWINLOSSPLAYOFFS           StatType = "WIN_LOSS_PLAYOFFS"
	StatTypeYEARBYYEAR                StatType = "YEAR_BY_YEAR"
	StatTypeYEARBYYEARADVANCED        StatType = "YEAR_BY_YEAR_ADVANCED"
	StatTypeYEARBYYEARPLAYOFFS        StatType = "YEAR_BY_YEAR_PLAYOFFS"
)

// Defines values for StreakLevelEnum.
const (
	StreakLevelEnumATBAT  StreakLevelEnum = "AT_BAT"
	StreakLevelEnumGAME   StreakLevelEnum = "GAME"
	StreakLevelEnumPITCH  StreakLevelEnum = "PITCH"
	StreakLevelEnumSEASON StreakLevelEnum = "SEASON"
)

// Defines values for StreakSpanEnum.
const (
	CAREER                StreakSpanEnum = "CAREER"
	CURRENTSTREAK         StreakSpanEnum = "CURRENT_STREAK"
	CURRENTSTREAKINSEASON StreakSpanEnum = "CURRENT_STREAK_IN_SEASON"
	NOTABLE               StreakSpanEnum = "NOTABLE"
	NOTABLEINSEASON       StreakSpanEnum = "NOTABLE_IN_SEASON"
	ONGOING               StreakSpanEnum = "ON_GOING"
	SEASON                StreakSpanEnum = "SEASON"
)

// Defines values for StreakStatEnum.
const (
	ATBATS               StreakStatEnum = "AT_BATS"
	BALKS                StreakStatEnum = "BALKS"
	BALLS                StreakStatEnum = "BALLS"
	BLOWNSAVES           StreakStatEnum = "BLOWN_SAVES"
	CAUGHTSTEALING       StreakStatEnum = "CAUGHT_STEALING"
	COMPLETEGAMES        StreakStatEnum = "COMPLETE_GAMES"
	DOUBLES              StreakStatEnum = "DOUBLES"
	EARNEDRUN            StreakStatEnum = "EARNED_RUN"
	ERRORS               StreakStatEnum = "ERRORS"
	EXTRABASEHITS        StreakStatEnum = "EXTRA_BASE_HITS"
	GAMESPLAYED          StreakStatEnum = "GAMES_PLAYED"
	GAMESSTARTED         StreakStatEnum = "GAMES_STARTED"
	GROUNDINTODOUBLEPLAY StreakStatEnum = "GROUND_INTO_DOUBLE_PLAY"
	HITBYPITCH           StreakStatEnum = "HIT_BY_PITCH"
	HITS                 StreakStatEnum = "HITS"
	HOLDS                StreakStatEnum = "HOLDS"
	HOMERUNS             StreakStatEnum = "HOME_RUNS"
	INTENTIONALWALKS     StreakStatEnum = "INTENTIONAL_WALKS"
	LEFTONBASE           StreakStatEnum = "LEFT_ON_BASE"
	LOSSES               StreakStatEnum = "LOSSES"
	ONBASE               StreakStatEnum = "ON_BASE"
	PASSEDBALLS          StreakStatEnum = "PASSED_BALLS"
	PICKOFFS             StreakStatEnum = "PICKOFFS"
	PITCHES              StreakStatEnum = "PITCHES"
	PLATEAPPEARANCES     StreakStatEnum = "PLATE_APPEARANCES"
	QUALITYSTARTS        StreakStatEnum = "QUALITY_STARTS"
	RUNS                 StreakStatEnum = "RUNS"
	RUNSBATTEDIN         StreakStatEnum = "RUNS_BATTED_IN"
	SAVES                StreakStatEnum = "SAVES"
	SHUTOUTS             StreakStatEnum = "SHUTOUTS"
	STOLENBASES          StreakStatEnum = "STOLEN_BASES"
	STRIKEOUTS           StreakStatEnum = "STRIKEOUTS"
	STRIKES              StreakStatEnum = "STRIKES"
	TOTALBASES           StreakStatEnum = "TOTAL_BASES"
	TRIPLES              StreakStatEnum = "TRIPLES"
	WALKOFFS             StreakStatEnum = "WALKOFFS"
	WALKS                StreakStatEnum = "WALKS"
	WINS                 StreakStatEnum = "WINS"
)

// Defines values for TeamActiveStatusEnum.
const (
	TeamActiveStatusEnumACTIVE   TeamActiveStatusEnum = "ACTIVE"
	TeamActiveStatusEnumBOTH     TeamActiveStatusEnum = "BOTH"
	TeamActiveStatusEnumINACTIVE TeamActiveStatusEnum = "INACTIVE"
	TeamActiveStatusEnumPENDING  TeamActiveStatusEnum = "PENDING"
)

// Defines values for TeamDesignationEnum.
const (
	AWAYTEAM TeamDesignationEnum = "AWAYTEAM"
	HOMETEAM TeamDesignationEnum = "HOMETEAM"
)

// Defines values for TrackingSystemOwner.
const (
	MLB     TrackingSystemOwner = "MLB"
	MLBCLUB TrackingSystemOwner = "MLB_CLUB"
	UNKNOWN TrackingSystemOwner = "UNKNOWN"
)

// Defines values for TrackingVendor.
const (
	CHYRONHEGO  TrackingVendor = "CHYRONHEGO"
	HAWKEYE     TrackingVendor = "HAWKEYE"
	SPORTVISION TrackingVendor = "SPORTVISION"
	TRACKMAN    TrackingVendor = "TRACKMAN"
)

// Defines values for TrackingVersion.
const (
	CLUBOWNED8CAM               TrackingVersion = "CLUB_OWNED_8_CAM"
	PITCHFX                     TrackingVersion = "PITCH_FX"
	STATCAST2015COMBINED        TrackingVersion = "STATCAST_2015_COMBINED"
	STATCAST2015RADARONLY20     TrackingVersion = "STATCAST_2015_RADAR_ONLY_20"
	STATCAST2017COMBINEDRADAR20 TrackingVersion = "STATCAST_2017_COMBINED_RADAR_20"
	STATCAST2017RADARONLY20     TrackingVersion = "STATCAST_2017_RADAR_ONLY_20"
	STATCAST2018COMBINEDRADAR25 TrackingVersion = "STATCAST_2018_COMBINED_RADAR_25"
	STATCAST2018RADARONLY25     TrackingVersion = "STATCAST_2018_RADAR_ONLY_25"
	STATCAST202012CAM           TrackingVersion = "STATCAST_2020_12_CAM"
	STATCAST20208CAM            TrackingVersion = "STATCAST_2020_8_CAM"
	STATCAST202312CAM           TrackingVersion = "STATCAST_2023_12_CAM"
	STATCAST20234CAM            TrackingVersion = "STATCAST_2023_4_CAM"
	TRACKMANV3                  TrackingVersion = "TRACKMAN_V3"
)

// Defines values for VenueTypeEnum.
const (
	CIRCUS      VenueTypeEnum = "CIRCUS"
	NBA         VenueTypeEnum = "NBA"
	NHL         VenueTypeEnum = "NHL"
	UNSPECIFIED VenueTypeEnum = "UNSPECIFIED"
)

// Defines values for VideoResolution.
const (
	ENUM4K VideoResolution = "ENUM_4K"
	HD     VideoResolution = "HD"
	SD     VideoResolution = "SD"
)

// About defines model for About.
type About struct {
	AtBatIndex       *int32     `json:"atBatIndex,omitempty"`
	CaptivatingIndex *int32     `json:"captivatingIndex,omitempty"`
	Copyright        *string    `json:"copyright,omitempty"`
	EndTime          *time.Time `json:"endTime,omitempty"`
	HalfInning       *string    `json:"halfInning,omitempty"`

	// HasOut Does the play include an out?
	HasOut        *bool      `json:"hasOut,omitempty"`
	HasReview     *bool      `json:"hasReview,omitempty"`
	Inning        *int32     `json:"inning,omitempty"`
	IsComplete    *bool      `json:"isComplete,omitempty"`
	IsScoringPlay *bool      `json:"isScoringPlay,omitempty"`
	IsTopInning   *bool      `json:"isTopInning,omitempty"`
	StartTime     *time.Time `json:"startTime,omitempty"`
}

// AdditionalBio defines model for AdditionalBio.
type AdditionalBio struct {
	HomeTown *string `json:"homeTown,omitempty"`
	Id       *int32  `json:"id,omitempty"`
}

// AdditionalBioRestObject defines model for AdditionalBioRestObject.
type AdditionalBioRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
	HomeTown  *string `json:"homeTown,omitempty"`
}

// AggregateSortTypeEnum defines model for AggregateSortTypeEnum.
type AggregateSortTypeEnum string

// AggregateSortTypeRestObject defines model for AggregateSortTypeRestObject.
type AggregateSortTypeRestObject struct {
	Code        *string `json:"code,omitempty"`
	Copyright   *string `json:"copyright,omitempty"`
	Description *string `json:"description,omitempty"`
}

// AllStarEnum defines model for AllStarEnum.
type AllStarEnum string

// AnalyticsGameMetadataRestObject defines model for AnalyticsGameMetadataRestObject.
type AnalyticsGameMetadataRestObject struct {
	AuditUpdatedAt   *string `json:"auditUpdatedAt,omitempty"`
	Copyright        *string `json:"copyright,omitempty"`
	GamePk           *string `json:"gamePk,omitempty"`
	Link             *string `json:"link,omitempty"`
	MetricsUpdatedAt *string `json:"metricsUpdatedAt,omitempty"`
	UpdatedAt        *string `json:"updatedAt,omitempty"`
	VideoUpdatedAt   *string `json:"videoUpdatedAt,omitempty"`
}

// AnalyticsGameMetadataWrapperRestObject defines model for AnalyticsGameMetadataWrapperRestObject.
type AnalyticsGameMetadataWrapperRestObject struct {
	Copyright  *string                            `json:"copyright,omitempty"`
	Games      *[]AnalyticsGameMetadataRestObject `json:"games,omitempty"`
	TotalItems *int64                             `json:"totalItems,omitempty"`
}

// AnalyticsPlayMetadataRestObject defines model for AnalyticsPlayMetadataRestObject.
type AnalyticsPlayMetadataRestObject struct {
	AtBatNumber          *int32                        `json:"atBatNumber,omitempty"`
	AuditUpdatedAt       *string                       `json:"auditUpdatedAt,omitempty"`
	CalculatedMetrics    *[]CalculatedMetricRestObject `json:"calculatedMetrics,omitempty"`
	ContextAverages      *[]CalculatedMetricRestObject `json:"contextAverages,omitempty"`
	ContextMetrics       *[]CalculatedMetricRestObject `json:"contextMetrics,omitempty"`
	Copyright            *string                       `json:"copyright,omitempty"`
	CreatedAt            *string                       `json:"createdAt,omitempty"`
	EndTime              *string                       `json:"endTime,omitempty"`
	GameDate             *string                       `json:"gameDate,omitempty"`
	GameMode             *GameModeTO                   `json:"gameMode,omitempty"`
	GamePk               *string                       `json:"gamePk,omitempty"`
	Guid                 *string                       `json:"guid,omitempty"`
	HasUpdates           *bool                         `json:"hasUpdates,omitempty"`
	HitSegment           *HitSegmentRestObject         `json:"hitSegment,omitempty"`
	Hydrations           *[]string                     `json:"hydrations,omitempty"`
	Inning               *int32                        `json:"inning,omitempty"`
	InvalidTracks        *[]CalculatedMetricRestObject `json:"invalidTracks,omitempty"`
	IsHit                *bool                         `json:"isHit,omitempty"`
	IsManual             *bool                         `json:"isManual,omitempty"`
	IsPickoff            *bool                         `json:"isPickoff,omitempty"`
	IsPitch              *bool                         `json:"isPitch,omitempty"`
	IsScrubbed           *bool                         `json:"isScrubbed,omitempty"`
	IsTopInning          *bool                         `json:"isTopInning,omitempty"`
	MetaData             *StatSplitsRestObject         `json:"metaData,omitempty"`
	MetricsUpdatedAt     *string                       `json:"metricsUpdatedAt,omitempty"`
	NumberOfMetricErrors *int32                        `json:"numberOfMetricErrors,omitempty"`
	ParsedFile           *string                       `json:"parsedFile,omitempty"`
	PickoffNumber        *int32                        `json:"pickoffNumber,omitempty"`
	PitchNumber          *int32                        `json:"pitchNumber,omitempty"`
	PitchSegment         *PitchSegmentRestObject       `json:"pitchSegment,omitempty"`
	PitchTime            *string                       `json:"pitchTime,omitempty"`
	PlayByPlay           *BaseballPlayRestObject       `json:"playByPlay,omitempty"`
	PlayResult           *PlayResultRestObject         `json:"playResult,omitempty"`
	RawFile              *string                       `json:"rawFile,omitempty"`
	StartTime            *string                       `json:"startTime,omitempty"`
	StrikeZoneInfo       *JsonNode                     `json:"strikeZoneInfo,omitempty"`
	Time                 *string                       `json:"time,omitempty"`
	TimeCode             *string                       `json:"timeCode,omitempty"`
	TimeCodeOffset       *string                       `json:"timeCodeOffset,omitempty"`
	UpdatedAt            *string                       `json:"updatedAt,omitempty"`
	Video                *IFeedRestObject              `json:"video,omitempty"`
	VideoUpdatedAt       *string                       `json:"videoUpdatedAt,omitempty"`
}

// AnalyticsPlayMetadataWrapperRestObject defines model for AnalyticsPlayMetadataWrapperRestObject.
type AnalyticsPlayMetadataWrapperRestObject struct {
	Copyright  *string                            `json:"copyright,omitempty"`
	Plays      *[]AnalyticsPlayMetadataRestObject `json:"plays,omitempty"`
	TotalItems *int64                             `json:"totalItems,omitempty"`
}

// AnalyticsRestObject defines model for AnalyticsRestObject.
type AnalyticsRestObject struct {
	BallSegments      *BallPositionalDataRestObject        `json:"ballSegments,omitempty"`
	Bat               *BatTrackingRestObject               `json:"bat,omitempty"`
	CalculatedMetrics *CalculatedMetricContainerRestObject `json:"calculatedMetrics,omitempty"`
	CalibrationData   *CalibrationContainerRestObject      `json:"calibrationData,omitempty"`
	ContextAverages   *[]CalculatedMetricRestObject        `json:"contextAverages,omitempty"`
	ContextMetrics    *[]CalculatedMetricRestObject        `json:"contextMetrics,omitempty"`
	Copyright         *string                              `json:"copyright,omitempty"`
	Diagram           *string                              `json:"diagram,omitempty"`
	Hydrations        *[]string                            `json:"hydrations,omitempty"`
	MetaData          *StatSplitsRestObject                `json:"metaData,omitempty"`
	PlayResult        *PlayResultRestObject                `json:"playResult,omitempty"`
	PositionMap       *map[string]BaseballPersonRestObject `json:"positionMap,omitempty"`
	SoftwareVersions  *JsonNode                            `json:"softwareVersions,omitempty"`
	StrikeZoneInfo    *JsonNode                            `json:"strikeZoneInfo,omitempty"`
	TargetPositions   *[]PositionalMapRestObject           `json:"targetPositions,omitempty"`
	TrackedEvents     *[]PlayEventRestObject               `json:"trackedEvents,omitempty"`
	Video             *IFeedRestObject                     `json:"video,omitempty"`
	Weather           *WeatherWrapperRestObject            `json:"weather,omitempty"`
}

// ApplicationRestObject defines model for ApplicationRestObject.
type ApplicationRestObject struct {
	AndroidPackage *string `json:"androidPackage,omitempty"`
	AndroidUrl     *string `json:"androidUrl,omitempty"`
	Copyright      *string `json:"copyright,omitempty"`
	Icon           *string `json:"icon,omitempty"`
	Intent         *string `json:"intent,omitempty"`
	IosPackage     *string `json:"iosPackage,omitempty"`
	IosUrl         *string `json:"iosUrl,omitempty"`
	Name           *string `json:"name,omitempty"`
	Primary        *bool   `json:"primary,omitempty"`
}

// Article defines model for Article.
type Article struct {
	Article  *JsonNode  `json:"article,omitempty"`
	Date     *time.Time `json:"date,omitempty"`
	PlayerId *string    `json:"playerId,omitempty"`
}

// AttendanceRecordRestObject defines model for AttendanceRecordRestObject.
type AttendanceRecordRestObject struct {
	AttendanceAverageAway    *int32                          `json:"attendanceAverageAway,omitempty"`
	AttendanceAverageHome    *int32                          `json:"attendanceAverageHome,omitempty"`
	AttendanceAverageYtd     *int32                          `json:"attendanceAverageYtd,omitempty"`
	AttendanceHigh           *int32                          `json:"attendanceHigh,omitempty"`
	AttendanceHighDate       *string                         `json:"attendanceHighDate,omitempty"`
	AttendanceHighGame       *BaseballScheduleItemRestObject `json:"attendanceHighGame,omitempty"`
	AttendanceLow            *int32                          `json:"attendanceLow,omitempty"`
	AttendanceLowDate        *string                         `json:"attendanceLowDate,omitempty"`
	AttendanceLowGame        *BaseballScheduleItemRestObject `json:"attendanceLowGame,omitempty"`
	AttendanceOpening7dayAvg *int32                          `json:"attendanceOpening7dayAvg,omitempty"`
	AttendanceOpeningAverage *int32                          `json:"attendanceOpeningAverage,omitempty"`
	AttendanceTotal          *int32                          `json:"attendanceTotal,omitempty"`
	AttendanceTotal7day      *int32                          `json:"attendanceTotal7day,omitempty"`
	AttendanceTotalAway      *int32                          `json:"attendanceTotalAway,omitempty"`
	AttendanceTotalHome      *int32                          `json:"attendanceTotalHome,omitempty"`
	AttendanceTotalYesterday *int32                          `json:"attendanceTotalYesterday,omitempty"`
	AttendanceTotalYtd       *int32                          `json:"attendanceTotalYtd,omitempty"`
	Copyright                *string                         `json:"copyright,omitempty"`
	GameType                 *GameTypeEnum                   `json:"gameType,omitempty"`
	GamesAwayTotal           *int32                          `json:"gamesAwayTotal,omitempty"`
	GamesHomeTotal           *int32                          `json:"gamesHomeTotal,omitempty"`
	GamesTotal               *int32                          `json:"gamesTotal,omitempty"`
	OpeningsTotal            *int32                          `json:"openingsTotal,omitempty"`
	OpeningsTotal7day        *int32                          `json:"openingsTotal7day,omitempty"`
	OpeningsTotalAway        *int32                          `json:"openingsTotalAway,omitempty"`
	OpeningsTotalHome        *int32                          `json:"openingsTotalHome,omitempty"`
	OpeningsTotalLost        *int32                          `json:"openingsTotalLost,omitempty"`
	OpeningsTotalYtd         *int32                          `json:"openingsTotalYtd,omitempty"`
	Team                     *BaseballTeamRestObject         `json:"team,omitempty"`
	Year                     *string                         `json:"year,omitempty"`
}

// AttendanceRestObject defines model for AttendanceRestObject.
type AttendanceRestObject struct {
	AggregateTotals *AttendanceRecordRestObject   `json:"aggregateTotals,omitempty"`
	Copyright       *string                       `json:"copyright,omitempty"`
	Records         *[]AttendanceRecordRestObject `json:"records,omitempty"`
}

// Award defines model for Award.
type Award struct {
	Date               *openapi_types.Date `json:"date,omitempty"`
	Description        *string             `json:"description,omitempty"`
	History            *string             `json:"history,omitempty"`
	HomePageUrl        *string             `json:"homePageUrl,omitempty"`
	Id                 *string             `json:"id,omitempty"`
	ImageUrl           *string             `json:"imageUrl,omitempty"`
	League             *League             `json:"league,omitempty"`
	Name               *string             `json:"name,omitempty"`
	Notes              *string             `json:"notes,omitempty"`
	OrganizationId     *int32              `json:"organizationId,omitempty"`
	Player             *BaseballPerson     `json:"player,omitempty"`
	RecipientType      *string             `json:"recipientType,omitempty"`
	RequestingUserRole *Role               `json:"requestingUserRole,omitempty"`
	Results            *[]AwardResult      `json:"results,omitempty"`
	Season             *string             `json:"season,omitempty"`
	ShortName          *string             `json:"shortName,omitempty"`
	SortOrder          *int32              `json:"sortOrder,omitempty"`
	Sport              *Sport              `json:"sport,omitempty"`
	Team               *BaseballTeam       `json:"team,omitempty"`
	UserPrivileges     *[]Privilege        `json:"userPrivileges,omitempty"`
	Votes              *int32              `json:"votes,omitempty"`
	VotesAvailable     *int32              `json:"votesAvailable,omitempty"`
	Winners            *[]AwardWinner      `json:"winners,omitempty"`
}

// AwardRestObject defines model for AwardRestObject.
type AwardRestObject struct {
	Copyright      *string                   `json:"copyright,omitempty"`
	Date           *openapi_types.Date       `json:"date,omitempty"`
	Description    *string                   `json:"description,omitempty"`
	History        *string                   `json:"history,omitempty"`
	HomePageUrl    *string                   `json:"homePageUrl,omitempty"`
	Hydrations     *[]string                 `json:"hydrations,omitempty"`
	Id             *string                   `json:"id,omitempty"`
	ImageUrl       *string                   `json:"imageUrl,omitempty"`
	League         *LeagueRestObject         `json:"league,omitempty"`
	Name           *string                   `json:"name,omitempty"`
	Notes          *string                   `json:"notes,omitempty"`
	Player         *BaseballPersonRestObject `json:"player,omitempty"`
	RecipientType  *string                   `json:"recipientType,omitempty"`
	Results        *[]AwardResultRestObject  `json:"results,omitempty"`
	Season         *string                   `json:"season,omitempty"`
	ShortName      *string                   `json:"shortName,omitempty"`
	SortOrder      *int32                    `json:"sortOrder,omitempty"`
	Sport          *SportRestObject          `json:"sport,omitempty"`
	Team           *BaseballTeamRestObject   `json:"team,omitempty"`
	Votes          *int32                    `json:"votes,omitempty"`
	VotesAvailable *int32                    `json:"votesAvailable,omitempty"`
}

// AwardResult defines model for AwardResult.
type AwardResult struct {
	RequestingUserRole *Role          `json:"requestingUserRole,omitempty"`
	SeasonId           *int32         `json:"seasonId,omitempty"`
	UserPrivileges     *[]Privilege   `json:"userPrivileges,omitempty"`
	Winners            *[]AwardWinner `json:"winners,omitempty"`
}

// AwardResultRestObject defines model for AwardResultRestObject.
type AwardResultRestObject struct {
	Copyright  *string                  `json:"copyright,omitempty"`
	Hydrations *[]string                `json:"hydrations,omitempty"`
	SeasonId   *int32                   `json:"seasonId,omitempty"`
	Winners    *[]AwardWinnerRestObject `json:"winners,omitempty"`
}

// AwardWinner defines model for AwardWinner.
type AwardWinner struct {
	AwardDate *openapi_types.Date `json:"awardDate,omitempty"`
	AwardId   *int32              `json:"awardId,omitempty"`
	Coach     *BaseballPerson     `json:"coach,omitempty"`
	CoachId   *int32              `json:"coachId,omitempty"`
	Empty     *bool               `json:"empty,omitempty"`
	NotEmpty  *bool               `json:"notEmpty,omitempty"`
	Person    *BaseballPerson     `json:"person,omitempty"`
	Player    *BaseballPerson     `json:"player,omitempty"`
	PlayerId  *int32              `json:"playerId,omitempty"`
	Rank      *string             `json:"rank,omitempty"`
	Season    *string             `json:"season,omitempty"`
	Team      *BaseballTeam       `json:"team,omitempty"`
	TeamId    *int32              `json:"teamId,omitempty"`
}

// AwardWinnerRestObject defines model for AwardWinnerRestObject.
type AwardWinnerRestObject struct {
	Coach     *BaseballPersonRestObject `json:"coach,omitempty"`
	Copyright *string                   `json:"copyright,omitempty"`
	Player    *BaseballPersonRestObject `json:"player,omitempty"`
	Rank      *string                   `json:"rank,omitempty"`
	Team      *BaseballTeamRestObject   `json:"team,omitempty"`
}

// AwardsRestObject defines model for AwardsRestObject.
type AwardsRestObject struct {
	Awards    *[]AwardRestObject `json:"awards,omitempty"`
	Copyright *string            `json:"copyright,omitempty"`
}

// BallPositionDataRestObject defines model for BallPositionDataRestObject.
type BallPositionDataRestObject struct {
	Confidence     *string                `json:"confidence,omitempty"`
	Copyright      *string                `json:"copyright,omitempty"`
	Position       *CoordinatesRestObject `json:"position,omitempty"`
	Time           *float64               `json:"time,omitempty"`
	TimeCode       *int64                 `json:"timeCode,omitempty"`
	TimeCodeOffset *float64               `json:"timeCodeOffset,omitempty"`
	Type           *string                `json:"type,omitempty"`
	Velocity       *CoordinatesRestObject `json:"velocity,omitempty"`
}

// BallPositionalDataRestObject defines model for BallPositionalDataRestObject.
type BallPositionalDataRestObject struct {
	Copyright       *string                       `json:"copyright,omitempty"`
	GenericSegments *[]SegmentRestObject          `json:"genericSegments,omitempty"`
	HitSegment      *HitSegmentRestObject         `json:"hitSegment,omitempty"`
	PitchSegment    *PitchSegmentRestObject       `json:"pitchSegment,omitempty"`
	Positions       *[]BallPositionDataRestObject `json:"positions,omitempty"`
}

// BaseballABSChallenge defines model for BaseballABSChallenge.
type BaseballABSChallenge struct {
	AwayChallengesRemaining      *int32        `json:"awayChallengesRemaining,omitempty"`
	AwayChallengesUsed           *int32        `json:"awayChallengesUsed,omitempty"`
	AwayChallengesUsedOverturned *int32        `json:"awayChallengesUsedOverturned,omitempty"`
	AwayChallengesUsedStands     *int32        `json:"awayChallengesUsedStands,omitempty"`
	ChallengingTeam              *BaseballTeam `json:"challengingTeam,omitempty"`
	HasChallenges                *bool         `json:"hasChallenges,omitempty"`
	HomeChallengesRemaining      *int32        `json:"homeChallengesRemaining,omitempty"`
	HomeChallengesUsed           *int32        `json:"homeChallengesUsed,omitempty"`
	HomeChallengesUsedOverturned *int32        `json:"homeChallengesUsedOverturned,omitempty"`
	HomeChallengesUsedStands     *int32        `json:"homeChallengesUsedStands,omitempty"`
	Limit9thInning               *int32        `json:"limit9thInning,omitempty"`
	ReviewReason                 *string       `json:"reviewReason,omitempty"`
}

// BaseballABSChallengeRestObject defines model for BaseballABSChallengeRestObject.
type BaseballABSChallengeRestObject struct {
	Away            *BaseballTeamReview     `json:"away,omitempty"`
	ChallengingTeam *BaseballTeamRestObject `json:"challengingTeam,omitempty"`
	Copyright       *string                 `json:"copyright,omitempty"`
	HasChallenges   *bool                   `json:"hasChallenges,omitempty"`
	Home            *BaseballTeamReview     `json:"home,omitempty"`
	Reason          *string                 `json:"reason,omitempty"`
}

// BaseballBoxscoreNoteRestObject defines model for BaseballBoxscoreNoteRestObject.
type BaseballBoxscoreNoteRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
	Label     *string `json:"label,omitempty"`
	Value     *string `json:"value,omitempty"`
}

// BaseballBoxscoreNoteWrapRestObject defines model for BaseballBoxscoreNoteWrapRestObject.
type BaseballBoxscoreNoteWrapRestObject struct {
	Copyright *string                           `json:"copyright,omitempty"`
	FieldList *[]BaseballBoxscoreNoteRestObject `json:"fieldList,omitempty"`
	Title     *string                           `json:"title,omitempty"`
}

// BaseballBoxscoreRestObject defines model for BaseballBoxscoreRestObject.
type BaseballBoxscoreRestObject struct {
	Copyright     *string                              `json:"copyright,omitempty"`
	Info          *[]BaseballBoxscoreNoteRestObject    `json:"info,omitempty"`
	Officials     *[]OfficialRestObject                `json:"officials,omitempty"`
	PitchingNotes *[]string                            `json:"pitchingNotes,omitempty"`
	Teams         *map[string]BaseballTeamBoxscore     `json:"teams,omitempty"`
	TopPerformers *[]BaseballPlayerGameScoreRestObject `json:"topPerformers,omitempty"`
}

// BaseballChallenge defines model for BaseballChallenge.
type BaseballChallenge struct {
	AwayChallengesRemaining *int32        `json:"awayChallengesRemaining,omitempty"`
	AwayChallengesUsed      *int32        `json:"awayChallengesUsed,omitempty"`
	ChallengingTeam         *BaseballTeam `json:"challengingTeam,omitempty"`
	HasChallenges           *bool         `json:"hasChallenges,omitempty"`
	HomeChallengesRemaining *int32        `json:"homeChallengesRemaining,omitempty"`
	HomeChallengesUsed      *int32        `json:"homeChallengesUsed,omitempty"`
	Limit9thInning          *int32        `json:"limit9thInning,omitempty"`
	ReviewReason            *string       `json:"reviewReason,omitempty"`
}

// BaseballDecision defines model for BaseballDecision.
type BaseballDecision struct {
	Empty              *bool                              `json:"empty,omitempty"`
	HydratedPeople     *map[string]map[string]interface{} `json:"hydratedPeople,omitempty"`
	Loser              *BaseballPerson                    `json:"loser,omitempty"`
	NotEmpty           *bool                              `json:"notEmpty,omitempty"`
	RequestingUserRole *Role                              `json:"requestingUserRole,omitempty"`
	Save               *BaseballPerson                    `json:"save,omitempty"`
	UserPrivileges     *[]Privilege                       `json:"userPrivileges,omitempty"`
	Winner             *BaseballPerson                    `json:"winner,omitempty"`
}

// BaseballDecisionRestObject defines model for BaseballDecisionRestObject.
type BaseballDecisionRestObject struct {
	Copyright  *string                   `json:"copyright,omitempty"`
	Hydrations *[]string                 `json:"hydrations,omitempty"`
	Loser      *BaseballPersonRestObject `json:"loser,omitempty"`
	Save       *BaseballPersonRestObject `json:"save,omitempty"`
	Winner     *BaseballPersonRestObject `json:"winner,omitempty"`
}

// BaseballDefenseRestObject defines model for BaseballDefenseRestObject.
type BaseballDefenseRestObject struct {
	Batter       *BaseballPersonRestObject `json:"batter,omitempty"`
	BattingOrder *int32                    `json:"battingOrder,omitempty"`
	Catcher      *BaseballPersonRestObject `json:"catcher,omitempty"`
	Center       *BaseballPersonRestObject `json:"center,omitempty"`
	Copyright    *string                   `json:"copyright,omitempty"`
	First        *BaseballPersonRestObject `json:"first,omitempty"`
	InHole       *BaseballPersonRestObject `json:"inHole,omitempty"`
	Left         *BaseballPersonRestObject `json:"left,omitempty"`
	OnDeck       *BaseballPersonRestObject `json:"onDeck,omitempty"`
	Pitcher      *BaseballPersonRestObject `json:"pitcher,omitempty"`
	Right        *BaseballPersonRestObject `json:"right,omitempty"`
	Second       *BaseballPersonRestObject `json:"second,omitempty"`
	Shortstop    *BaseballPersonRestObject `json:"shortstop,omitempty"`
	Team         *BaseballTeamRestObject   `json:"team,omitempty"`
	Third        *BaseballPersonRestObject `json:"third,omitempty"`
}

// BaseballDraftLatestRestObject defines model for BaseballDraftLatestRestObject.
type BaseballDraftLatestRestObject struct {
	Copyright *string                            `json:"copyright,omitempty"`
	NextUp    *[]BaseballDraftProspectRestObject `json:"nextUp,omitempty"`
	Number    *int32                             `json:"number,omitempty"`
	Pick      *BaseballDraftProspectRestObject   `json:"pick,omitempty"`
}

// BaseballDraftListRestObject defines model for BaseballDraftListRestObject.
type BaseballDraftListRestObject struct {
	Copyright *string                  `json:"copyright,omitempty"`
	Drafts    *BaseballDraftRestObject `json:"drafts,omitempty"`
}

// BaseballDraftProspect defines model for BaseballDraftProspect.
type BaseballDraftProspect struct {
	BisPlayerId        *int32           `json:"bisPlayerId,omitempty"`
	BisSchoolId        *int32           `json:"bisSchoolId,omitempty"`
	Comments           *string          `json:"comments,omitempty"`
	DisplayPickNumber  *int32           `json:"displayPickNumber,omitempty"`
	DraftPlayerId      *int32           `json:"draftPlayerId,omitempty"`
	DraftStatus        *DraftStatusEnum `json:"draftStatus,omitempty"`
	DraftType          *DraftTypeEnum   `json:"draftType,omitempty"`
	EnglishBlurb       *string          `json:"englishBlurb,omitempty"`
	HeadshotLink       *string          `json:"headshotLink,omitempty"`
	Home               *Location        `json:"home,omitempty"`
	Person             *BaseballPerson  `json:"person,omitempty"`
	PhotoFlag          *bool            `json:"photoFlag,omitempty"`
	PickNumber         *int32           `json:"pickNumber,omitempty"`
	PickRound          *string          `json:"pickRound,omitempty"`
	PickRoundLabel     *string          `json:"pickRoundLabel,omitempty"`
	PickValue          *string          `json:"pickValue,omitempty"`
	PickedTeamCode     *string          `json:"pickedTeamCode,omitempty"`
	Rank               *int32           `json:"rank,omitempty"`
	RequestingUserRole *Role            `json:"requestingUserRole,omitempty"`
	RoundPickNumber    *int32           `json:"roundPickNumber,omitempty"`
	School             *School          `json:"school,omitempty"`
	ScoutingReport     *string          `json:"scoutingReport,omitempty"`
	SigningBonus       *string          `json:"signingBonus,omitempty"`
	SpanishBlurb       *string          `json:"spanishBlurb,omitempty"`
	Team               *BaseballTeam    `json:"team,omitempty"`
	UserPrivileges     *[]Privilege     `json:"userPrivileges,omitempty"`
	WasLastPick        *bool            `json:"wasLastPick,omitempty"`
	WasPassed          *bool            `json:"wasPassed,omitempty"`
	WasSelected        *bool            `json:"wasSelected,omitempty"`
	Year               *string          `json:"year,omitempty"`
}

// BaseballDraftProspectRestObject defines model for BaseballDraftProspectRestObject.
type BaseballDraftProspectRestObject struct {
	BisPlayerId       *int32                    `json:"bisPlayerId,omitempty"`
	BisSchoolId       *int32                    `json:"bisSchoolId,omitempty"`
	Blurb             *string                   `json:"blurb,omitempty"`
	Copyright         *string                   `json:"copyright,omitempty"`
	DisplayPickNumber *int32                    `json:"displayPickNumber,omitempty"`
	DraftType         *DraftTypeEnumRestObject  `json:"draftType,omitempty"`
	HeadshotLink      *string                   `json:"headshotLink,omitempty"`
	Home              *LocationRestObject       `json:"home,omitempty"`
	IsDrafted         *bool                     `json:"isDrafted,omitempty"`
	IsPass            *bool                     `json:"isPass,omitempty"`
	Person            *BaseballPersonRestObject `json:"person,omitempty"`
	PickNumber        *int32                    `json:"pickNumber,omitempty"`
	PickRound         *string                   `json:"pickRound,omitempty"`
	PickValue         *string                   `json:"pickValue,omitempty"`
	Rank              *int32                    `json:"rank,omitempty"`
	RoundPickNumber   *int32                    `json:"roundPickNumber,omitempty"`
	School            *SchoolRestObject         `json:"school,omitempty"`
	ScoutingReport    *string                   `json:"scoutingReport,omitempty"`
	SigningBonus      *string                   `json:"signingBonus,omitempty"`
	Team              *BaseballTeamRestObject   `json:"team,omitempty"`
	Year              *string                   `json:"year,omitempty"`
}

// BaseballDraftRestObject defines model for BaseballDraftRestObject.
type BaseballDraftRestObject struct {
	Copyright *string                         `json:"copyright,omitempty"`
	DraftYear *int32                          `json:"draftYear,omitempty"`
	Rounds    *[]BaseballDraftRoundRestObject `json:"rounds,omitempty"`
}

// BaseballDraftRoundRestObject defines model for BaseballDraftRoundRestObject.
type BaseballDraftRoundRestObject struct {
	Copyright *string                            `json:"copyright,omitempty"`
	Picks     *[]BaseballDraftProspectRestObject `json:"picks,omitempty"`
	Round     *string                            `json:"round,omitempty"`
}

// BaseballGameAlert defines model for BaseballGameAlert.
type BaseballGameAlert struct {
	AlertId          *string       `json:"alertId,omitempty"`
	Category         *string       `json:"category,omitempty"`
	Description      *string       `json:"description,omitempty"`
	ShortDescription *string       `json:"shortDescription,omitempty"`
	Team             *BaseballTeam `json:"team,omitempty"`
	Type             *string       `json:"type,omitempty"`
}

// BaseballGameAlertRestObject defines model for BaseballGameAlertRestObject.
type BaseballGameAlertRestObject struct {
	AlertId          *string                 `json:"alertId,omitempty"`
	Category         *string                 `json:"category,omitempty"`
	Copyright        *string                 `json:"copyright,omitempty"`
	Description      *string                 `json:"description,omitempty"`
	ShortDescription *string                 `json:"shortDescription,omitempty"`
	Team             *BaseballTeamRestObject `json:"team,omitempty"`
	Type             *string                 `json:"type,omitempty"`
}

// BaseballGameContextRestObject defines model for BaseballGameContextRestObject.
type BaseballGameContextRestObject struct {
	AwayWinProbability           *float64                        `json:"awayWinProbability,omitempty"`
	CenterFieldSacFlyProbability *SacFlyProbability              `json:"centerFieldSacFlyProbability,omitempty"`
	Copyright                    *string                         `json:"copyright,omitempty"`
	ExpectedStatisticsData       *StatDataRestObject             `json:"expectedStatisticsData,omitempty"`
	Game                         *BaseballScheduleItemRestObject `json:"game,omitempty"`
	HomeWinProbability           *float64                        `json:"homeWinProbability,omitempty"`
	LeftFieldSacFlyProbability   *SacFlyProbability              `json:"leftFieldSacFlyProbability,omitempty"`
	RightFieldSacFlyProbability  *SacFlyProbability              `json:"rightFieldSacFlyProbability,omitempty"`
	RunnerOnThird                *BaseballPersonRestObject       `json:"runnerOnThird,omitempty"`
}

// BaseballGameDataGameRestObject defines model for BaseballGameDataGameRestObject.
type BaseballGameDataGameRestObject struct {
	CalendarEventID *string `json:"calendarEventID,omitempty"`
	Copyright       *string `json:"copyright,omitempty"`
	DoubleHeader    *string `json:"doubleHeader,omitempty"`
	GameNumber      *int32  `json:"gameNumber,omitempty"`
	GamedayType     *string `json:"gamedayType,omitempty"`
	Id              *string `json:"id,omitempty"`
	Pk              *int32  `json:"pk,omitempty"`
	Season          *string `json:"season,omitempty"`
	SeasonDisplay   *string `json:"seasonDisplay,omitempty"`
	Tiebreaker      *string `json:"tiebreaker,omitempty"`
	Type            *string `json:"type,omitempty"`
}

// BaseballGameDataRestObject defines model for BaseballGameDataRestObject.
type BaseballGameDataRestObject struct {
	AbsChallenges       *BaseballABSChallengeRestObject      `json:"absChallenges,omitempty"`
	Alerts              *[]BaseballGameAlertRestObject       `json:"alerts,omitempty"`
	Copyright           *string                              `json:"copyright,omitempty"`
	Datetime            *BaseballGameDateTimeRestObject      `json:"datetime,omitempty"`
	Flags               *BaseballGameFlagRestObject          `json:"flags,omitempty"`
	Game                *BaseballGameDataGameRestObject      `json:"game,omitempty"`
	GameInfo            *GameInfoRestObject                  `json:"gameInfo,omitempty"`
	MoundVisits         *MoundVisitsRestObject               `json:"moundVisits,omitempty"`
	OfficialScorer      *BaseballPersonRestObject            `json:"officialScorer,omitempty"`
	OfficialVenue       *VenueRestObject                     `json:"officialVenue,omitempty"`
	Players             *map[string]BaseballPersonRestObject `json:"players,omitempty"`
	PrimaryDatacaster   *BaseballPersonRestObject            `json:"primaryDatacaster,omitempty"`
	ProbablePitchers    *BaseballGameProbableRestObject      `json:"probablePitchers,omitempty"`
	Review              *BaseballReviewRestObject            `json:"review,omitempty"`
	RuleSettings        *[]RuleSettingsRestObject            `json:"ruleSettings,omitempty"`
	SecondaryDatacaster *BaseballPersonRestObject            `json:"secondaryDatacaster,omitempty"`
	Status              *GameStatusRestObject                `json:"status,omitempty"`
	Teams               *map[string]BaseballTeamRestObject   `json:"teams,omitempty"`
	Venue               *VenueRestObject                     `json:"venue,omitempty"`
	Weather             *WeatherRestObject                   `json:"weather,omitempty"`
}

// BaseballGameDateTimeRestObject defines model for BaseballGameDateTimeRestObject.
type BaseballGameDateTimeRestObject struct {
	Ampm                *string             `json:"ampm,omitempty"`
	Copyright           *string             `json:"copyright,omitempty"`
	DateTime            *time.Time          `json:"dateTime,omitempty"`
	DayNight            *string             `json:"dayNight,omitempty"`
	EndDateTime         *time.Time          `json:"endDateTime,omitempty"`
	OfficialDate        *openapi_types.Date `json:"officialDate,omitempty"`
	OriginalDate        *openapi_types.Date `json:"originalDate,omitempty"`
	ResumeDate          *openapi_types.Date `json:"resumeDate,omitempty"`
	ResumeDateTime      *time.Time          `json:"resumeDateTime,omitempty"`
	ResumedFromDate     *openapi_types.Date `json:"resumedFromDate,omitempty"`
	ResumedFromDateTime *time.Time          `json:"resumedFromDateTime,omitempty"`
	Time                *string             `json:"time,omitempty"`
}

// BaseballGameFlag defines model for BaseballGameFlag.
type BaseballGameFlag struct {
	AwayTeamNoHitter      *bool `json:"awayTeamNoHitter,omitempty"`
	AwayTeamPerfectGame   *bool `json:"awayTeamPerfectGame,omitempty"`
	HomeTeamNoHitter      *bool `json:"homeTeamNoHitter,omitempty"`
	HomeTeamPerfectGame   *bool `json:"homeTeamPerfectGame,omitempty"`
	IsAwayTeamNoHitter    *bool `json:"isAwayTeamNoHitter,omitempty"`
	IsAwayTeamPerfectGame *bool `json:"isAwayTeamPerfectGame,omitempty"`
	IsHomeTeamNoHitter    *bool `json:"isHomeTeamNoHitter,omitempty"`
	IsHomeTeamPerfectGame *bool `json:"isHomeTeamPerfectGame,omitempty"`
	IsNoHitter            *bool `json:"isNoHitter,omitempty"`
	IsPerfectGame         *bool `json:"isPerfectGame,omitempty"`
	NoHitter              *bool `json:"noHitter,omitempty"`
	PerfectGame           *bool `json:"perfectGame,omitempty"`
}

// BaseballGameFlagRestObject defines model for BaseballGameFlagRestObject.
type BaseballGameFlagRestObject struct {
	AwayTeamNoHitter    *bool   `json:"awayTeamNoHitter,omitempty"`
	AwayTeamPerfectGame *bool   `json:"awayTeamPerfectGame,omitempty"`
	Copyright           *string `json:"copyright,omitempty"`
	HomeTeamNoHitter    *bool   `json:"homeTeamNoHitter,omitempty"`
	HomeTeamPerfectGame *bool   `json:"homeTeamPerfectGame,omitempty"`
	NoHitter            *bool   `json:"noHitter,omitempty"`
	PerfectGame         *bool   `json:"perfectGame,omitempty"`
}

// BaseballGameLeaderRestObject defines model for BaseballGameLeaderRestObject.
type BaseballGameLeaderRestObject struct {
	Copyright *string                   `json:"copyright,omitempty"`
	Player    *BaseballPersonRestObject `json:"player,omitempty"`
	Value     *float64                  `json:"value,omitempty"`
}

// BaseballGameLeadersRestObject defines model for BaseballGameLeadersRestObject.
type BaseballGameLeadersRestObject struct {
	Copyright   *string                       `json:"copyright,omitempty"`
	HitDistance *BaseballGameLeaderRestObject `json:"hitDistance,omitempty"`
	HitSpeed    *BaseballGameLeaderRestObject `json:"hitSpeed,omitempty"`
	PitchSpeed  *BaseballGameLeaderRestObject `json:"pitchSpeed,omitempty"`
}

// BaseballGameLiveDataRestObject defines model for BaseballGameLiveDataRestObject.
type BaseballGameLiveDataRestObject struct {
	Boxscore  *BaseballBoxscoreRestObject    `json:"boxscore,omitempty"`
	Copyright *string                        `json:"copyright,omitempty"`
	Decisions *BaseballDecisionRestObject    `json:"decisions,omitempty"`
	Leaders   *BaseballGameLeadersRestObject `json:"leaders,omitempty"`
	Linescore *BaseballLinescoreRestObject   `json:"linescore,omitempty"`
	Plays     *BaseballPlayByPlayRestObject  `json:"plays,omitempty"`
}

// BaseballGameLiveLookinRestObject defines model for BaseballGameLiveLookinRestObject.
type BaseballGameLiveLookinRestObject struct {
	Copyright       *string               `json:"copyright,omitempty"`
	GamePk          *int32                `json:"gamePk,omitempty"`
	Headline        *string               `json:"headline,omitempty"`
	Kicker          *string               `json:"kicker,omitempty"`
	MediaPlaybackId *int64                `json:"mediaPlaybackId,omitempty"`
	Playbacks       *[]LiveLookinPlayback `json:"playbacks,omitempty"`
}

// BaseballGameMetaDataRestObject defines model for BaseballGameMetaDataRestObject.
type BaseballGameMetaDataRestObject struct {
	Copyright     *string   `json:"copyright,omitempty"`
	GameEvents    *[]string `json:"gameEvents,omitempty"`
	LogicalEvents *[]string `json:"logicalEvents,omitempty"`
	TimeStamp     *string   `json:"timeStamp,omitempty"`
	Wait          *int32    `json:"wait,omitempty"`
}

// BaseballGameProbableRestObject defines model for BaseballGameProbableRestObject.
type BaseballGameProbableRestObject struct {
	Away      *BaseballPersonRestObject `json:"away,omitempty"`
	Copyright *string                   `json:"copyright,omitempty"`
	Home      *BaseballPersonRestObject `json:"home,omitempty"`
}

// BaseballGameRestObject defines model for BaseballGameRestObject.
type BaseballGameRestObject struct {
	Copyright *string                         `json:"copyright,omitempty"`
	GameData  *BaseballGameDataRestObject     `json:"gameData,omitempty"`
	GamePk    *int32                          `json:"gamePk,omitempty"`
	Link      *string                         `json:"link,omitempty"`
	LiveData  *BaseballGameLiveDataRestObject `json:"liveData,omitempty"`
	MetaData  *BaseballGameMetaDataRestObject `json:"metaData,omitempty"`
}

// BaseballHit defines model for BaseballHit.
type BaseballHit struct {
	BatSpeed          *float64           `json:"batSpeed,omitempty"`
	Batter            *BaseballPerson    `json:"batter,omitempty"`
	CoordX            *float64           `json:"coordX,omitempty"`
	CoordY            *float64           `json:"coordY,omitempty"`
	Description       *string            `json:"description,omitempty"`
	Descriptions      *map[string]string `json:"descriptions,omitempty"`
	Hardness          *string            `json:"hardness,omitempty"`
	HitProbability    *float64           `json:"hitProbability,omitempty"`
	Inning            *int32             `json:"inning,omitempty"`
	IsBarrel          *bool              `json:"isBarrel,omitempty"`
	IsSwordSwing      *bool              `json:"isSwordSwing,omitempty"`
	LandingData       *StartEndData      `json:"landingData,omitempty"`
	LandingPosX       *float64           `json:"landingPosX,omitempty"`
	LandingPosY       *float64           `json:"landingPosY,omitempty"`
	LastMeasuredData  *StartEndData      `json:"lastMeasuredData,omitempty"`
	LaunchAngle       *float64           `json:"launchAngle,omitempty"`
	LaunchData        *LaunchData        `json:"launchData,omitempty"`
	LaunchSpeed       *float64           `json:"launchSpeed,omitempty"`
	Location          *string            `json:"location,omitempty"`
	Pitcher           *BaseballPerson    `json:"pitcher,omitempty"`
	ReducedConfidence *[]string          `json:"reducedConfidence,omitempty"`
	Team              *BaseballTeam      `json:"team,omitempty"`
	TotalDistance     *float64           `json:"totalDistance,omitempty"`
	Trajectory        *string            `json:"trajectory,omitempty"`
	TrajectoryData    *HitTrajectoryData `json:"trajectoryData,omitempty"`
	Type              *string            `json:"type,omitempty"`
}

// BaseballHitDataRestObject defines model for BaseballHitDataRestObject.
type BaseballHitDataRestObject struct {
	BatSpeed          *float64                     `json:"batSpeed,omitempty"`
	Coordinates       *Coordinates                 `json:"coordinates,omitempty"`
	Copyright         *string                      `json:"copyright,omitempty"`
	Hardness          *string                      `json:"hardness,omitempty"`
	HitProbability    *float64                     `json:"hitProbability,omitempty"`
	IsBarrel          *bool                        `json:"isBarrel,omitempty"`
	IsSwordSwing      *bool                        `json:"isSwordSwing,omitempty"`
	LandingData       *StartEndDataRestObject      `json:"landingData,omitempty"`
	LastMeasuredData  *StartEndDataRestObject      `json:"lastMeasuredData,omitempty"`
	LaunchAngle       *float64                     `json:"launchAngle,omitempty"`
	LaunchData        *LaunchDataRestObject        `json:"launchData,omitempty"`
	LaunchSpeed       *float64                     `json:"launchSpeed,omitempty"`
	Location          *string                      `json:"location,omitempty"`
	ReducedConfidence *[]string                    `json:"reducedConfidence,omitempty"`
	TotalDistance     *float64                     `json:"totalDistance,omitempty"`
	Trajectory        *string                      `json:"trajectory,omitempty"`
	TrajectoryData    *HitTrajectoryDataRestObject `json:"trajectoryData,omitempty"`
}

// BaseballHotColdZone defines model for BaseballHotColdZone.
type BaseballHotColdZone struct {
	Color     *string `json:"color,omitempty"`
	Sweetness *string `json:"sweetness,omitempty"`
	Temp      *string `json:"temp,omitempty"`
	Value     *string `json:"value,omitempty"`
	Zone      *string `json:"zone,omitempty"`
}

// BaseballHotColdZoneRestObject defines model for BaseballHotColdZoneRestObject.
type BaseballHotColdZoneRestObject struct {
	Color     *string `json:"color,omitempty"`
	Copyright *string `json:"copyright,omitempty"`
	Sweetness *string `json:"sweetness,omitempty"`
	Temp      *string `json:"temp,omitempty"`
	Value     *string `json:"value,omitempty"`
	Zone      *string `json:"zone,omitempty"`
}

// BaseballInning defines model for BaseballInning.
type BaseballInning struct {
	ErrorsAway     *int32  `json:"errorsAway,omitempty"`
	ErrorsHome     *int32  `json:"errorsHome,omitempty"`
	HitsAway       *int32  `json:"hitsAway,omitempty"`
	HitsHome       *int32  `json:"hitsHome,omitempty"`
	LeftOnBaseAway *int32  `json:"leftOnBaseAway,omitempty"`
	LeftOnBaseHome *int32  `json:"leftOnBaseHome,omitempty"`
	Num            *int32  `json:"num,omitempty"`
	OrdinalNum     *string `json:"ordinalNum,omitempty"`
	RunsAway       *int32  `json:"runsAway,omitempty"`
	RunsHome       *int32  `json:"runsHome,omitempty"`
}

// BaseballLinescore defines model for BaseballLinescore.
type BaseballLinescore struct {
	AwayErrors             *int32                             `json:"awayErrors,omitempty"`
	AwayHits               *int32                             `json:"awayHits,omitempty"`
	AwayIsWinner           *bool                              `json:"awayIsWinner,omitempty"`
	AwayLeftOnBase         *int32                             `json:"awayLeftOnBase,omitempty"`
	AwayScore              *int32                             `json:"awayScore,omitempty"`
	AwayTeam               *BaseballTeam                      `json:"awayTeam,omitempty"`
	Balls                  *int32                             `json:"balls,omitempty"`
	BatTeam                *BaseballTeam                      `json:"batTeam,omitempty"`
	BatTeamsLastPitcher    *BaseballPerson                    `json:"batTeamsLastPitcher,omitempty"`
	Batter                 *BaseballPerson                    `json:"batter,omitempty"`
	BatterPosition         *BaseballPosition                  `json:"batterPosition,omitempty"`
	BattingOrder           *int32                             `json:"battingOrder,omitempty"`
	Catcher                *BaseballPerson                    `json:"catcher,omitempty"`
	CenterField            *BaseballPerson                    `json:"centerField,omitempty"`
	CreatedAt              *time.Time                         `json:"createdAt,omitempty"`
	CurrentInning          *int32                             `json:"currentInning,omitempty"`
	CurrentInningOrdinal   *string                            `json:"currentInningOrdinal,omitempty"`
	FieldTeam              *BaseballTeam                      `json:"fieldTeam,omitempty"`
	FieldTeamsBattingOrder *int32                             `json:"fieldTeamsBattingOrder,omitempty"`
	FieldTeamsDueUpBatter  *BaseballPerson                    `json:"fieldTeamsDueUpBatter,omitempty"`
	FieldTeamsDueUpInHole  *BaseballPerson                    `json:"fieldTeamsDueUpInHole,omitempty"`
	FieldTeamsDueUpOnDeck  *BaseballPerson                    `json:"fieldTeamsDueUpOnDeck,omitempty"`
	FirstBase              *BaseballPerson                    `json:"firstBase,omitempty"`
	GamePk                 *int32                             `json:"gamePk,omitempty"`
	GameStatus             *IGameStatus                       `json:"gameStatus,omitempty"`
	HomeErrors             *int32                             `json:"homeErrors,omitempty"`
	HomeHits               *int32                             `json:"homeHits,omitempty"`
	HomeIsWinner           *bool                              `json:"homeIsWinner,omitempty"`
	HomeLeftOnBase         *int32                             `json:"homeLeftOnBase,omitempty"`
	HomeScore              *int32                             `json:"homeScore,omitempty"`
	HomeTeam               *BaseballTeam                      `json:"homeTeam,omitempty"`
	HydratedStats          *map[string]map[string]interface{} `json:"hydratedStats,omitempty"`
	InHole                 *BaseballPerson                    `json:"inHole,omitempty"`
	InningHalf             *string                            `json:"inningHalf,omitempty"`
	InningState            *string                            `json:"inningState,omitempty"`
	Innings                *[]BaseballInning                  `json:"innings,omitempty"`
	IsTopInning            *bool                              `json:"isTopInning,omitempty"`
	LeftField              *BaseballPerson                    `json:"leftField,omitempty"`
	Note                   *string                            `json:"note,omitempty"`
	OnDeck                 *BaseballPerson                    `json:"onDeck,omitempty"`
	OnFirst                *BaseballPerson                    `json:"onFirst,omitempty"`
	OnSecond               *BaseballPerson                    `json:"onSecond,omitempty"`
	OnThird                *BaseballPerson                    `json:"onThird,omitempty"`
	Outs                   *int32                             `json:"outs,omitempty"`
	Pitcher                *BaseballPerson                    `json:"pitcher,omitempty"`
	PlayersNotInField      *map[string]BaseballPosition       `json:"playersNotInField,omitempty"`
	PostOnFirst            *BaseballPerson                    `json:"postOnFirst,omitempty"`
	PostOnSecond           *BaseballPerson                    `json:"postOnSecond,omitempty"`
	PostOnThird            *BaseballPerson                    `json:"postOnThird,omitempty"`
	RequestingUserRole     *Role                              `json:"requestingUserRole,omitempty"`
	RightField             *BaseballPerson                    `json:"rightField,omitempty"`
	RunsAway               *int32                             `json:"runsAway,omitempty"`
	RunsHome               *int32                             `json:"runsHome,omitempty"`
	ScheduledInnings       *int32                             `json:"scheduledInnings,omitempty"`
	SecondBase             *BaseballPerson                    `json:"secondBase,omitempty"`
	Shortstop              *BaseballPerson                    `json:"shortstop,omitempty"`
	Strikes                *int32                             `json:"strikes,omitempty"`
	ThirdBase              *BaseballPerson                    `json:"thirdBase,omitempty"`
	Tie                    *bool                              `json:"tie,omitempty"`
	TopInning              *bool                              `json:"topInning,omitempty"`
	UserPrivileges         *[]Privilege                       `json:"userPrivileges,omitempty"`
}

// BaseballLinescoreRestObject defines model for BaseballLinescoreRestObject.
type BaseballLinescoreRestObject struct {
	Balls                *int32                               `json:"balls,omitempty"`
	Copyright            *string                              `json:"copyright,omitempty"`
	CurrentInning        *int32                               `json:"currentInning,omitempty"`
	CurrentInningOrdinal *string                              `json:"currentInningOrdinal,omitempty"`
	Defense              *BaseballDefenseRestObject           `json:"defense,omitempty"`
	InningHalf           *string                              `json:"inningHalf,omitempty"`
	InningState          *string                              `json:"inningState,omitempty"`
	Innings              *[]InningRestObject                  `json:"innings,omitempty"`
	IsTopInning          *bool                                `json:"isTopInning,omitempty"`
	Note                 *string                              `json:"note,omitempty"`
	Offense              *BaseballOffenseRestObject           `json:"offense,omitempty"`
	Outs                 *int32                               `json:"outs,omitempty"`
	ScheduledInnings     *int32                               `json:"scheduledInnings,omitempty"`
	Strikes              *int32                               `json:"strikes,omitempty"`
	Teams                *BaseballLinescoreTeamInfoRestObject `json:"teams,omitempty"`
	Tie                  *bool                                `json:"tie,omitempty"`
}

// BaseballLinescoreTeamInfoRestObject defines model for BaseballLinescoreTeamInfoRestObject.
type BaseballLinescoreTeamInfoRestObject struct {
	Away      *TeamInfo `json:"away,omitempty"`
	Copyright *string   `json:"copyright,omitempty"`
	Home      *TeamInfo `json:"home,omitempty"`
}

// BaseballLineup defines model for BaseballLineup.
type BaseballLineup struct {
	AwayPlayers        *[]BaseballPerson                  `json:"awayPlayers,omitempty"`
	HomePlayers        *[]BaseballPerson                  `json:"homePlayers,omitempty"`
	HydratedPeople     *map[string]map[string]interface{} `json:"hydratedPeople,omitempty"`
	RequestingUserRole *Role                              `json:"requestingUserRole,omitempty"`
	UserPrivileges     *[]Privilege                       `json:"userPrivileges,omitempty"`
}

// BaseballLineupRestObject defines model for BaseballLineupRestObject.
type BaseballLineupRestObject struct {
	AwayPlayers *[]BaseballPersonRestObject `json:"awayPlayers,omitempty"`
	Copyright   *string                     `json:"copyright,omitempty"`
	HomePlayers *[]BaseballPersonRestObject `json:"homePlayers,omitempty"`
}

// BaseballOffenseRestObject defines model for BaseballOffenseRestObject.
type BaseballOffenseRestObject struct {
	Batter *BaseballPersonRestObject `json:"batter,omitempty"`

	// BatterPosition The x-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The y-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The z-coordinate of the landing position for the ball's trajectory. This will always be z=0 by definition.
	BatterPosition *PositionRestObject       `json:"batterPosition,omitempty"`
	BattingOrder   *int32                    `json:"battingOrder,omitempty"`
	Copyright      *string                   `json:"copyright,omitempty"`
	First          *BaseballPersonRestObject `json:"first,omitempty"`
	InHole         *BaseballPersonRestObject `json:"inHole,omitempty"`
	OnDeck         *BaseballPersonRestObject `json:"onDeck,omitempty"`
	Pitcher        *BaseballPersonRestObject `json:"pitcher,omitempty"`
	PostOnFirst    *BaseballPersonRestObject `json:"postOnFirst,omitempty"`
	PostOnSecond   *BaseballPersonRestObject `json:"postOnSecond,omitempty"`
	PostOnThird    *BaseballPersonRestObject `json:"postOnThird,omitempty"`
	Second         *BaseballPersonRestObject `json:"second,omitempty"`
	Team           *BaseballTeamRestObject   `json:"team,omitempty"`
	Third          *BaseballPersonRestObject `json:"third,omitempty"`
}

// BaseballPerson defines model for BaseballPerson.
type BaseballPerson struct {
	AdditionalBio               *AdditionalBio                     `json:"additionalBio,omitempty"`
	Age                         *int32                             `json:"age,omitempty"`
	AlumniLastSeason            *string                            `json:"alumniLastSeason,omitempty"`
	Articles                    *[]Article                         `json:"articles,omitempty"`
	Awards                      *[]Award                           `json:"awards,omitempty"`
	BatSide                     *DynamicLookupEnum                 `json:"batSide,omitempty"`
	BatterPitcher               *string                            `json:"batterPitcher,omitempty"`
	BirthCity                   *string                            `json:"birthCity,omitempty"`
	BirthCountry                *string                            `json:"birthCountry,omitempty"`
	BirthDate                   *openapi_types.Date                `json:"birthDate,omitempty"`
	BirthStateProvince          *string                            `json:"birthStateProvince,omitempty"`
	BoxscoreName                *string                            `json:"boxscoreName,omitempty"`
	CurrentTeam                 *BaseballTeam                      `json:"currentTeam,omitempty"`
	DeathCity                   *string                            `json:"deathCity,omitempty"`
	DeathCountry                *string                            `json:"deathCountry,omitempty"`
	DeathDate                   *openapi_types.Date                `json:"deathDate,omitempty"`
	DeathStateProvince          *string                            `json:"deathStateProvince,omitempty"`
	DepthCharts                 *[]DepthChart                      `json:"depthCharts,omitempty"`
	Draft                       *[]PlayerDraftInfo                 `json:"draft,omitempty"`
	DraftProspects              *map[string]map[string]interface{} `json:"draftProspects,omitempty"`
	DraftYear                   *int32                             `json:"draftYear,omitempty"`
	Drafts                      *[]BaseballDraftProspect           `json:"drafts,omitempty"`
	EducationInfo               *EducationInfo                     `json:"educationInfo,omitempty"`
	Fielder                     *bool                              `json:"fielder,omitempty"`
	FirstLastName               *string                            `json:"firstLastName,omitempty"`
	FirstName                   *string                            `json:"firstName,omitempty"`
	FullFMLName                 *string                            `json:"fullFMLName,omitempty"`
	FullLFMName                 *string                            `json:"fullLFMName,omitempty"`
	FullName                    *string                            `json:"fullName,omitempty"`
	Gender                      *string                            `json:"gender,omitempty"`
	Height                      *int32                             `json:"height,omitempty"`
	HeightFeet                  *int32                             `json:"heightFeet,omitempty"`
	HeightInches                *int32                             `json:"heightInches,omitempty"`
	HydratedArticles            *map[string]map[string]interface{} `json:"hydratedArticles,omitempty"`
	HydratedAwards              *map[string]map[string]interface{} `json:"hydratedAwards,omitempty"`
	HydratedCurrentTeam         *map[string]map[string]interface{} `json:"hydratedCurrentTeam,omitempty"`
	HydratedDepthCharts         *map[string]map[string]interface{} `json:"hydratedDepthCharts,omitempty"`
	HydratedEducation           *map[string]map[string]interface{} `json:"hydratedEducation,omitempty"`
	HydratedMixedFeed           *map[string]map[string]interface{} `json:"hydratedMixedFeed,omitempty"`
	HydratedNextStarts          *map[string]map[string]interface{} `json:"hydratedNextStarts,omitempty"`
	HydratedPersonJobsEntries   *map[string]map[string]interface{} `json:"hydratedPersonJobsEntries,omitempty"`
	HydratedPersonRosterEntries *map[string]map[string]interface{} `json:"hydratedPersonRosterEntries,omitempty"`
	HydratedPlayerPhotos        *map[string]map[string]interface{} `json:"hydratedPlayerPhotos,omitempty"`
	HydratedRelatives           *map[string]map[string]interface{} `json:"hydratedRelatives,omitempty"`
	HydratedSocial              *map[string]map[string]interface{} `json:"hydratedSocial,omitempty"`
	HydratedStats               *map[string]map[string]interface{} `json:"hydratedStats,omitempty"`
	HydratedTeam                *map[string]map[string]interface{} `json:"hydratedTeam,omitempty"`
	HydratedVideos              *map[string]map[string]interface{} `json:"hydratedVideos,omitempty"`
	Id                          *int32                             `json:"id,omitempty"`
	InitLastName                *string                            `json:"initLastName,omitempty"`
	IsActive                    *bool                              `json:"isActive,omitempty"`
	IsAlternateCaptain          *bool                              `json:"isAlternateCaptain,omitempty"`
	IsCaptain                   *bool                              `json:"isCaptain,omitempty"`
	IsPlayer                    *bool                              `json:"isPlayer,omitempty"`
	IsRookie                    *bool                              `json:"isRookie,omitempty"`
	IsVerified                  *bool                              `json:"isVerified,omitempty"`
	LanguageId                  *int32                             `json:"languageId,omitempty"`
	LastFirstName               *string                            `json:"lastFirstName,omitempty"`
	LastInitName                *string                            `json:"lastInitName,omitempty"`
	LastName                    *string                            `json:"lastName,omitempty"`
	LastPlayedDate              *openapi_types.Date                `json:"lastPlayedDate,omitempty"`
	MiddleName                  *string                            `json:"middleName,omitempty"`
	MixedFeed                   *[]IFeed                           `json:"mixedFeed,omitempty"`
	MlbDebutDate                *openapi_types.Date                `json:"mlbDebutDate,omitempty"`
	NameFirstLast               *string                            `json:"nameFirstLast,omitempty"`
	NameMatrilineal             *string                            `json:"nameMatrilineal,omitempty"`
	NamePrefix                  *string                            `json:"namePrefix,omitempty"`
	NameSlug                    *string                            `json:"nameSlug,omitempty"`
	NameTitle                   *string                            `json:"nameTitle,omitempty"`
	Nationality                 *string                            `json:"nationality,omitempty"`
	NextStarts                  *[]BaseballScheduleItem            `json:"nextStarts,omitempty"`
	NickName                    *string                            `json:"nickName,omitempty"`
	NickNames                   *[]string                          `json:"nickNames,omitempty"`
	Note                        *string                            `json:"note,omitempty"`
	OtherNames                  *OtherNames                        `json:"otherNames,omitempty"`
	PhoneticName                *string                            `json:"phoneticName,omitempty"`
	Photos                      *[]Photo                           `json:"photos,omitempty"`
	PitchHand                   *DynamicLookupEnum                 `json:"pitchHand,omitempty"`
	Pitcher                     *bool                              `json:"pitcher,omitempty"`
	PrimaryNumber               *string                            `json:"primaryNumber,omitempty"`
	PrimaryPosition             *BaseballPosition                  `json:"primaryPosition,omitempty"`
	Pronunciation               *string                            `json:"pronunciation,omitempty"`
	Relatives                   *[]Relative                        `json:"relatives,omitempty"`
	RequestingUserRole          *Role                              `json:"requestingUserRole,omitempty"`
	RookieSeasons               *[]string                          `json:"rookieSeasons,omitempty"`
	RosterNumber                *string                            `json:"rosterNumber,omitempty"`
	SocialMediaInfo             *SocialMediaInfo                   `json:"socialMediaInfo,omitempty"`
	Stats                       *Stats                             `json:"stats,omitempty"`
	StrikeZoneBottom            *float64                           `json:"strikeZoneBottom,omitempty"`
	StrikeZoneTop               *float64                           `json:"strikeZoneTop,omitempty"`
	Transactions                *[]Transaction                     `json:"transactions,omitempty"`
	Twitter                     *string                            `json:"twitter,omitempty"`
	UseLastName                 *string                            `json:"useLastName,omitempty"`
	UseName                     *string                            `json:"useName,omitempty"`
	UserPrivileges              *[]Privilege                       `json:"userPrivileges,omitempty"`
	Videos                      *[]Video                           `json:"videos,omitempty"`
	Weight                      *int32                             `json:"weight,omitempty"`
	XrefIds                     *[]XrefId                          `json:"xrefIds,omitempty"`
}

// BaseballPersonRestObject defines model for BaseballPersonRestObject.
type BaseballPersonRestObject struct {
	Active             *bool                              `json:"active,omitempty"`
	AdditionalBio      *AdditionalBioRestObject           `json:"additionalBio,omitempty"`
	AlternateCaptain   *bool                              `json:"alternateCaptain,omitempty"`
	AlumniLastSeason   *string                            `json:"alumniLastSeason,omitempty"`
	Articles           *[]IFeedRestObject                 `json:"articles,omitempty"`
	Awards             *[]AwardRestObject                 `json:"awards,omitempty"`
	BatSide            *DynamicEnumRestObject             `json:"batSide,omitempty"`
	BirthCity          *string                            `json:"birthCity,omitempty"`
	BirthCountry       *string                            `json:"birthCountry,omitempty"`
	BirthDate          *openapi_types.Date                `json:"birthDate,omitempty"`
	BirthStateProvince *string                            `json:"birthStateProvince,omitempty"`
	BoxscoreName       *string                            `json:"boxscoreName,omitempty"`
	Captain            *bool                              `json:"captain,omitempty"`
	Copyright          *string                            `json:"copyright,omitempty"`
	CurrentAge         *int32                             `json:"currentAge,omitempty"`
	CurrentTeam        *BaseballTeamRestObject            `json:"currentTeam,omitempty"`
	DeathCity          *string                            `json:"deathCity,omitempty"`
	DeathCountry       *string                            `json:"deathCountry,omitempty"`
	DeathDate          *openapi_types.Date                `json:"deathDate,omitempty"`
	DeathStateProvince *string                            `json:"deathStateProvince,omitempty"`
	DepthCharts        *[]DepthChartRestObject            `json:"depthCharts,omitempty"`
	Draft              *[]PlayerDraftInfoRestObject       `json:"draft,omitempty"`
	DraftYear          *int32                             `json:"draftYear,omitempty"`
	Drafts             *[]BaseballDraftProspectRestObject `json:"drafts,omitempty"`
	Education          *EducationRestObject               `json:"education,omitempty"`
	FirstLastName      *string                            `json:"firstLastName,omitempty"`
	FirstName          *string                            `json:"firstName,omitempty"`
	FullFMLName        *string                            `json:"fullFMLName,omitempty"`
	FullLFMName        *string                            `json:"fullLFMName,omitempty"`
	FullName           *string                            `json:"fullName,omitempty"`
	Gender             *string                            `json:"gender,omitempty"`
	Height             *string                            `json:"height,omitempty"`
	Hydrations         *[]string                          `json:"hydrations,omitempty"`
	Id                 *int32                             `json:"id,omitempty"`
	InitLastName       *string                            `json:"initLastName,omitempty"`
	IsPlayer           *bool                              `json:"isPlayer,omitempty"`
	IsVerified         *bool                              `json:"isVerified,omitempty"`
	LastFirstName      *string                            `json:"lastFirstName,omitempty"`
	LastInitName       *string                            `json:"lastInitName,omitempty"`
	LastName           *string                            `json:"lastName,omitempty"`
	LastPlayedDate     *openapi_types.Date                `json:"lastPlayedDate,omitempty"`
	Link               *string                            `json:"link,omitempty"`
	MiddleName         *string                            `json:"middleName,omitempty"`
	MixedFeed          *[]IFeedRestObject                 `json:"mixedFeed,omitempty"`
	MlbDebutDate       *openapi_types.Date                `json:"mlbDebutDate,omitempty"`
	NameFirstLast      *string                            `json:"nameFirstLast,omitempty"`
	NameMatrilineal    *string                            `json:"nameMatrilineal,omitempty"`
	// Deprecated:
	NamePrefix    *string                `json:"namePrefix,omitempty"`
	NameSlug      *string                `json:"nameSlug,omitempty"`
	NameSuffix    *string                `json:"nameSuffix,omitempty"`
	NameTitle     *string                `json:"nameTitle,omitempty"`
	Nationality   *string                `json:"nationality,omitempty"`
	NickName      *string                `json:"nickName,omitempty"`
	Nicknames     *[]string              `json:"nicknames,omitempty"`
	Note          *string                `json:"note,omitempty"`
	OtherNames    *OtherNamesRestObject  `json:"otherNames,omitempty"`
	Photos        *[]PhotoRestObject     `json:"photos,omitempty"`
	PitchHand     *DynamicEnumRestObject `json:"pitchHand,omitempty"`
	PrimaryNumber *string                `json:"primaryNumber,omitempty"`

	// PrimaryPosition The x-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The y-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The z-coordinate of the landing position for the ball's trajectory. This will always be z=0 by definition.
	PrimaryPosition  *PositionRestObject         `json:"primaryPosition,omitempty"`
	Pronunciation    *string                     `json:"pronunciation,omitempty"`
	Relatives        *[]BaseballPersonRestObject `json:"relatives,omitempty"`
	Rookie           *bool                       `json:"rookie,omitempty"`
	RookieSeasons    *[]string                   `json:"rookieSeasons,omitempty"`
	Social           *SocialMediaRestObject      `json:"social,omitempty"`
	Stats            *[]StatContainerRestObject  `json:"stats,omitempty"`
	StrikeZoneBottom *float64                    `json:"strikeZoneBottom,omitempty"`
	StrikeZoneTop    *float64                    `json:"strikeZoneTop,omitempty"`
	Transactions     *[]TransactionRestObject    `json:"transactions,omitempty"`
	UseLastName      *string                     `json:"useLastName,omitempty"`
	UseName          *string                     `json:"useName,omitempty"`
	Videos           *[]IFeedRestObject          `json:"videos,omitempty"`
	Weight           *int32                      `json:"weight,omitempty"`
	XrefIds          *[]XrefIdRestObject         `json:"xrefIds,omitempty"`
}

// BaseballPitch defines model for BaseballPitch.
type BaseballPitch struct {
	BallColor            *string  `json:"ballColor,omitempty"`
	BreakAngle           *float64 `json:"breakAngle,omitempty"`
	BreakHorizontal      *float64 `json:"breakHorizontal,omitempty"`
	BreakLength          *float64 `json:"breakLength,omitempty"`
	BreakVertical        *float64 `json:"breakVertical,omitempty"`
	BreakVerticalInduced *float64 `json:"breakVerticalInduced,omitempty"`
	BreakX               *float64 `json:"breakX,omitempty"`
	BreakY               *float64 `json:"breakY,omitempty"`
	BreakZ               *float64 `json:"breakZ,omitempty"`
	EndSpeed             *float64 `json:"endSpeed,omitempty"`
	Extension            *float64 `json:"extension,omitempty"`
	GetaX                *float64 `json:"getaX,omitempty"`
	GetaY                *float64 `json:"getaY,omitempty"`
	GetaZ                *float64 `json:"getaZ,omitempty"`
	GetpX                *float64 `json:"getpX,omitempty"`
	GetpZ                *float64 `json:"getpZ,omitempty"`
	GetvX0               *float64 `json:"getvX0,omitempty"`
	GetvY0               *float64 `json:"getvY0,omitempty"`
	GetvZ0               *float64 `json:"getvZ0,omitempty"`
	NastyFactor          *float64 `json:"nastyFactor,omitempty"`
	PfxX                 *float64 `json:"pfxX,omitempty"`
	PfxZ                 *float64 `json:"pfxZ,omitempty"`
	PlateTime            *float64 `json:"plateTime,omitempty"`
	SpinDirection        *int32   `json:"spinDirection,omitempty"`
	SpinRate             *int32   `json:"spinRate,omitempty"`
	StartSpeed           *float64 `json:"startSpeed,omitempty"`
	StrikeZoneBottom     *float64 `json:"strikeZoneBottom,omitempty"`
	StrikeZoneDepth      *float64 `json:"strikeZoneDepth,omitempty"`
	StrikeZoneTop        *float64 `json:"strikeZoneTop,omitempty"`
	StrikeZoneWidth      *float64 `json:"strikeZoneWidth,omitempty"`
	TrailColor           *string  `json:"trailColor,omitempty"`
	TypeConfidence       *float64 `json:"typeConfidence,omitempty"`
	X                    *float64 `json:"x,omitempty"`
	X0                   *float64 `json:"x0,omitempty"`
	Y                    *float64 `json:"y,omitempty"`
	Y0                   *float64 `json:"y0,omitempty"`
	Z0                   *float64 `json:"z0,omitempty"`
	Zone                 *int32   `json:"zone,omitempty"`
}

// BaseballPitchDataRestObject defines model for BaseballPitchDataRestObject.
type BaseballPitchDataRestObject struct {
	Breaks           *Breaks      `json:"breaks,omitempty"`
	Coordinates      *Coordinates `json:"coordinates,omitempty"`
	Copyright        *string      `json:"copyright,omitempty"`
	EndSpeed         *float64     `json:"endSpeed,omitempty"`
	Extension        *float64     `json:"extension,omitempty"`
	NastyFactor      *float64     `json:"nastyFactor,omitempty"`
	PlateTime        *float64     `json:"plateTime,omitempty"`
	StartSpeed       *float64     `json:"startSpeed,omitempty"`
	StrikeZoneBottom *float64     `json:"strikeZoneBottom,omitempty"`
	StrikeZoneDepth  *float64     `json:"strikeZoneDepth,omitempty"`
	StrikeZoneTop    *float64     `json:"strikeZoneTop,omitempty"`
	StrikeZoneWidth  *float64     `json:"strikeZoneWidth,omitempty"`
	TypeConfidence   *float64     `json:"typeConfidence,omitempty"`
	Zone             *int32       `json:"zone,omitempty"`
}

// BaseballPlay defines model for BaseballPlay.
type BaseballPlay struct {
	ActionIndex                  *[]int32                  `json:"actionIndex,omitempty"`
	AtBat                        *bool                     `json:"atBat,omitempty"`
	AtBatIndex                   *int32                    `json:"atBatIndex,omitempty"`
	AwayScore                    *int32                    `json:"awayScore,omitempty"`
	Balls                        *int32                    `json:"balls,omitempty"`
	BatSide                      *DynamicLookupEnum        `json:"batSide,omitempty"`
	Batter                       *BaseballPerson           `json:"batter,omitempty"`
	BatterHotColdZoneStats       *Stats                    `json:"batterHotColdZoneStats,omitempty"`
	BatterHotColdZones           *[]BaseballHotColdZone    `json:"batterHotColdZones,omitempty"`
	BatterResultEvent            *EventType                `json:"batterResultEvent,omitempty"`
	CaptivatingIndex             *int32                    `json:"captivatingIndex,omitempty"`
	ChallengeTeamId              *int32                    `json:"challengeTeamId,omitempty"`
	Complete                     *bool                     `json:"complete,omitempty"`
	Credits                      *[]PlayCredit             `json:"credits,omitempty"`
	DefensiveAlignmentId         *string                   `json:"defensiveAlignmentId,omitempty"`
	Description                  *string                   `json:"description,omitempty"`
	Descriptions                 *map[string]string        `json:"descriptions,omitempty"`
	DoublePlay                   *bool                     `json:"doublePlay,omitempty"`
	EndTime                      *time.Time                `json:"endTime,omitempty"`
	EventType                    *string                   `json:"eventType,omitempty"`
	EventTypeEnum                *EventType                `json:"eventTypeEnum,omitempty"`
	Flags                        *[]PlayCredit             `json:"flags,omitempty"`
	GroundIntoDoublePlay         *bool                     `json:"groundIntoDoublePlay,omitempty"`
	GroundIntoTriplePlay         *bool                     `json:"groundIntoTriplePlay,omitempty"`
	GroundOut                    *bool                     `json:"groundOut,omitempty"`
	HalfInning                   *string                   `json:"halfInning,omitempty"`
	HasOut                       *bool                     `json:"hasOut,omitempty"`
	HasReview                    *bool                     `json:"hasReview,omitempty"`
	Hit                          *bool                     `json:"hit,omitempty"`
	HitTrajectory                *HitTrajectory            `json:"hitTrajectory,omitempty"`
	HomeScore                    *int32                    `json:"homeScore,omitempty"`
	InPlayEvent                  *BaseballPlayEvent        `json:"inPlayEvent,omitempty"`
	Inning                       *int32                    `json:"inning,omitempty"`
	IsComplete                   *bool                     `json:"isComplete,omitempty"`
	IsDoublePlay                 *bool                     `json:"isDoublePlay,omitempty"`
	IsGroundIntoDoublePlay       *bool                     `json:"isGroundIntoDoublePlay,omitempty"`
	IsGroundIntoTriplePlay       *bool                     `json:"isGroundIntoTriplePlay,omitempty"`
	IsScoringPlay                *bool                     `json:"isScoringPlay,omitempty"`
	IsTriplePlay                 *bool                     `json:"isTriplePlay,omitempty"`
	NumErrors                    *int32                    `json:"numErrors,omitempty"`
	NumLeftOnBase                *int32                    `json:"numLeftOnBase,omitempty"`
	NumLeftOnBaseScoring         *int32                    `json:"numLeftOnBaseScoring,omitempty"`
	NumLeftOnBaseScoringPosition *int32                    `json:"numLeftOnBaseScoringPosition,omitempty"`
	NumRbi                       *int32                    `json:"numRbi,omitempty"`
	NumRuns                      *int32                    `json:"numRuns,omitempty"`
	OffensiveAlignmentId         *string                   `json:"offensiveAlignmentId,omitempty"`
	Outs                         *int32                    `json:"outs,omitempty"`
	PayoffEvent                  *BaseballPlayEvent        `json:"payoffEvent,omitempty"`
	PitchHand                    *DynamicLookupEnum        `json:"pitchHand,omitempty"`
	PitchIndex                   *[]int32                  `json:"pitchIndex,omitempty"`
	Pitcher                      *BaseballPerson           `json:"pitcher,omitempty"`
	PitcherHotColdZoneStats      *Stats                    `json:"pitcherHotColdZoneStats,omitempty"`
	PitcherHotColdZones          *[]BaseballHotColdZone    `json:"pitcherHotColdZones,omitempty"`
	PlateAppearance              *bool                     `json:"plateAppearance,omitempty"`
	PlayEvents                   *[]BaseballPlayEvent      `json:"playEvents,omitempty"`
	RequestingUserRole           *Role                     `json:"requestingUserRole,omitempty"`
	ResponsibleBatter            *BaseballPerson           `json:"responsibleBatter,omitempty"`
	ResponsiblePitcher           *BaseballPerson           `json:"responsiblePitcher,omitempty"`
	Result                       *string                   `json:"result,omitempty"`
	ResultMap                    *map[string]string        `json:"resultMap,omitempty"`
	Results                      *map[string]string        `json:"results,omitempty"`
	ReviewInProgress             *bool                     `json:"reviewInProgress,omitempty"`
	ReviewOverturned             *bool                     `json:"reviewOverturned,omitempty"`
	ReviewType                   *string                   `json:"reviewType,omitempty"`
	Reviews                      *[]BaseballReview         `json:"reviews,omitempty"`
	RunnerIndex                  *[]map[string]interface{} `json:"runnerIndex,omitempty"`
	RunnerMovements              *[]BaseballRunnerMovement `json:"runnerMovements,omitempty"`
	RunnerOn1b                   *BaseballPerson           `json:"runnerOn1b,omitempty"`
	RunnerOn2b                   *BaseballPerson           `json:"runnerOn2b,omitempty"`
	RunnerOn3b                   *BaseballPerson           `json:"runnerOn3b,omitempty"`
	ScoringPlay                  *bool                     `json:"scoringPlay,omitempty"`
	SplitsBatter                 *string                   `json:"splitsBatter,omitempty"`
	SplitsMenOnBase              *string                   `json:"splitsMenOnBase,omitempty"`
	SplitsPitcher                *string                   `json:"splitsPitcher,omitempty"`
	StartTime                    *time.Time                `json:"startTime,omitempty"`
	Strikes                      *int32                    `json:"strikes,omitempty"`
	Summary                      *BaseballPlay             `json:"summary,omitempty"`
	TeamNumLeftOnBase            *int32                    `json:"teamNumLeftOnBase,omitempty"`
	TopInning                    *bool                     `json:"topInning,omitempty"`
	TriplePlay                   *bool                     `json:"triplePlay,omitempty"`
	UserPrivileges               *[]Privilege              `json:"userPrivileges,omitempty"`
}

// BaseballPlayByPlayRestObject defines model for BaseballPlayByPlayRestObject.
type BaseballPlayByPlayRestObject struct {
	AllPlays      *[]BaseballPlayRestObject `json:"allPlays,omitempty"`
	Copyright     *string                   `json:"copyright,omitempty"`
	CurrentPlay   *BaseballPlayRestObject   `json:"currentPlay,omitempty"`
	PlaysByInning *[]InningPlay             `json:"playsByInning,omitempty"`
	ScoringPlays  *[]int32                  `json:"scoringPlays,omitempty"`
}

// BaseballPlayEvent defines model for BaseballPlayEvent.
type BaseballPlayEvent struct {
	ActionPlayId                        *string            `json:"actionPlayId,omitempty"`
	AtBatNumber                         *int32             `json:"atBatNumber,omitempty"`
	AwayScore                           *int32             `json:"awayScore,omitempty"`
	Balls                               *int32             `json:"balls,omitempty"`
	Base                                *int32             `json:"base,omitempty"`
	BaseRunningPlay                     *bool              `json:"baseRunningPlay,omitempty"`
	BatSide                             *DynamicLookupEnum `json:"batSide,omitempty"`
	BattingOrder                        *string            `json:"battingOrder,omitempty"`
	ChallengeTeamId                     *int32             `json:"challengeTeamId,omitempty"`
	Code                                *string            `json:"code,omitempty"`
	Credits                             *[]PlayCredit      `json:"credits,omitempty"`
	DefensiveAlignmentId                *string            `json:"defensiveAlignmentId,omitempty"`
	DefensiveLineupId                   *string            `json:"defensiveLineupId,omitempty"`
	Description                         *string            `json:"description,omitempty"`
	DescriptionMap                      *map[string]string `json:"descriptionMap,omitempty"`
	Descriptions                        *map[string]string `json:"descriptions,omitempty"`
	DisengagementNum                    *int32             `json:"disengagementNum,omitempty"`
	DoublePlay                          *bool              `json:"doublePlay,omitempty"`
	EndTime                             *time.Time         `json:"endTime,omitempty"`
	Event                               *string            `json:"event,omitempty"`
	EventMap                            *map[string]string `json:"eventMap,omitempty"`
	EventTypeEnum                       *EventType         `json:"eventTypeEnum,omitempty"`
	Events                              *map[string]string `json:"events,omitempty"`
	FromCatcher                         *bool              `json:"fromCatcher,omitempty"`
	HasReview                           *bool              `json:"hasReview,omitempty"`
	Hit                                 *BaseballHit       `json:"hit,omitempty"`
	HomeScore                           *int32             `json:"homeScore,omitempty"`
	Index                               *int32             `json:"index,omitempty"`
	InjuryType                          *string            `json:"injuryType,omitempty"`
	Inning                              *int32             `json:"inning,omitempty"`
	IsAtBat                             *bool              `json:"isAtBat,omitempty"`
	IsBall                              *bool              `json:"isBall,omitempty"`
	IsBaseHit                           *bool              `json:"isBaseHit,omitempty"`
	IsDoublePlay                        *bool              `json:"isDoublePlay,omitempty"`
	IsInPlay                            *bool              `json:"isInPlay,omitempty"`
	IsOut                               *bool              `json:"isOut,omitempty"`
	IsPitch                             *bool              `json:"isPitch,omitempty"`
	IsPlateAppearance                   *bool              `json:"isPlateAppearance,omitempty"`
	IsStrike                            *bool              `json:"isStrike,omitempty"`
	IsTopInning                         *bool              `json:"isTopInning,omitempty"`
	NumInheritedRunners                 *int32             `json:"numInheritedRunners,omitempty"`
	NumberOfPeopleOnBase                *int32             `json:"numberOfPeopleOnBase,omitempty"`
	NumberOfPeopleOnBaseScoringPosition *int32             `json:"numberOfPeopleOnBaseScoringPosition,omitempty"`
	OffensiveAlignmentId                *string            `json:"offensiveAlignmentId,omitempty"`
	OffensiveLineupId                   *string            `json:"offensiveLineupId,omitempty"`
	Outs                                *int32             `json:"outs,omitempty"`
	PfxId                               *string            `json:"pfxId,omitempty"`
	PickoffNumber                       *int32             `json:"pickoffNumber,omitempty"`
	Pitch                               *BaseballPitch     `json:"pitch,omitempty"`
	PitchCall                           *DynamicLookupEnum `json:"pitchCall,omitempty"`
	PitchHand                           *DynamicLookupEnum `json:"pitchHand,omitempty"`
	PitchNumber                         *int32             `json:"pitchNumber,omitempty"`
	PitchType                           *DynamicLookupEnum `json:"pitchType,omitempty"`
	PlayId                              *string            `json:"playId,omitempty"`
	Player                              *BaseballPerson    `json:"player,omitempty"`
	Players                             *BaseballLinescore `json:"players,omitempty"`
	Position                            *BaseballPosition  `json:"position,omitempty"`
	PostBalls                           *int32             `json:"postBalls,omitempty"`
	PostOuts                            *int32             `json:"postOuts,omitempty"`
	PostRunnerOn1b                      *bool              `json:"postRunnerOn1b,omitempty"`
	PostRunnerOn2b                      *bool              `json:"postRunnerOn2b,omitempty"`
	PostRunnerOn3b                      *bool              `json:"postRunnerOn3b,omitempty"`
	PostStrikes                         *int32             `json:"postStrikes,omitempty"`
	PreBalls                            *int32             `json:"preBalls,omitempty"`
	PreOuts                             *int32             `json:"preOuts,omitempty"`
	PreStrikes                          *int32             `json:"preStrikes,omitempty"`
	ReplacedPlayer                      *BaseballPerson    `json:"replacedPlayer,omitempty"`
	ReviewInProgress                    *bool              `json:"reviewInProgress,omitempty"`
	ReviewOverturned                    *bool              `json:"reviewOverturned,omitempty"`
	ReviewType                          *string            `json:"reviewType,omitempty"`
	Reviews                             *[]BaseballReview  `json:"reviews,omitempty"`
	RunnerGoing                         *bool              `json:"runnerGoing,omitempty"`
	RunnerOn1b                          *bool              `json:"runnerOn1b,omitempty"`
	RunnerOn2b                          *bool              `json:"runnerOn2b,omitempty"`
	RunnerOn3b                          *bool              `json:"runnerOn3b,omitempty"`
	Scored                              *bool              `json:"scored,omitempty"`
	StartTime                           *time.Time         `json:"startTime,omitempty"`
	Strikes                             *int32             `json:"strikes,omitempty"`
	Substitution                        *bool              `json:"substitution,omitempty"`
	Summary                             *BaseballPlayEvent `json:"summary,omitempty"`
	Type                                *string            `json:"type,omitempty"`
	Umpire                              *BaseballPerson    `json:"umpire,omitempty"`
	Umpires                             *[]Official        `json:"umpires,omitempty"`
	Violation                           *BaseballViolation `json:"violation,omitempty"`
}

// BaseballPlayEventRestObject defines model for BaseballPlayEventRestObject.
type BaseballPlayEventRestObject struct {
	ActionPlayId      *string                      `json:"actionPlayId,omitempty"`
	AtBatNumber       *int32                       `json:"atBatNumber,omitempty"`
	Base              *int32                       `json:"base,omitempty"`
	BattingOrder      *string                      `json:"battingOrder,omitempty"`
	Copyright         *string                      `json:"copyright,omitempty"`
	Count             *Count                       `json:"count,omitempty"`
	Credits           *[]PlayCreditRestObject      `json:"credits,omitempty"`
	Defense           *BaseballDefenseRestObject   `json:"defense,omitempty"`
	Details           *Details                     `json:"details,omitempty"`
	EndTime           *time.Time                   `json:"endTime,omitempty"`
	HitData           *BaseballHitDataRestObject   `json:"hitData,omitempty"`
	Index             *int32                       `json:"index,omitempty"`
	InjuryType        *string                      `json:"injuryType,omitempty"`
	IsBaseRunningPlay *bool                        `json:"isBaseRunningPlay,omitempty"`
	IsPitch           *bool                        `json:"isPitch,omitempty"`
	IsSubstitution    *bool                        `json:"isSubstitution,omitempty"`
	Offense           *BaseballOffenseRestObject   `json:"offense,omitempty"`
	Officials         *[]OfficialRestObject        `json:"officials,omitempty"`
	PfxId             *string                      `json:"pfxId,omitempty"`
	PickoffNumber     *int32                       `json:"pickoffNumber,omitempty"`
	PitchData         *BaseballPitchDataRestObject `json:"pitchData,omitempty"`
	PitchNumber       *int32                       `json:"pitchNumber,omitempty"`
	PlayId            *string                      `json:"playId,omitempty"`
	Player            *BaseballPersonRestObject    `json:"player,omitempty"`

	// Position The x-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The y-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The z-coordinate of the landing position for the ball's trajectory. This will always be z=0 by definition.
	Position       *PositionRestObject       `json:"position,omitempty"`
	PostCount      *Count                    `json:"postCount,omitempty"`
	PreCount       *Count                    `json:"preCount,omitempty"`
	ReplacedPlayer *BaseballPersonRestObject `json:"replacedPlayer,omitempty"`
	ReviewDetails  *ReviewDetails            `json:"reviewDetails,omitempty"`
	StartTime      *time.Time                `json:"startTime,omitempty"`
	Type           *string                   `json:"type,omitempty"`
	Umpire         *BaseballPersonRestObject `json:"umpire,omitempty"`
}

// BaseballPlayRestObject defines model for BaseballPlayRestObject.
type BaseballPlayRestObject struct {
	About         *About                         `json:"about,omitempty"`
	ActionIndex   *[]int32                       `json:"actionIndex,omitempty"`
	AtBatIndex    *int32                         `json:"atBatIndex,omitempty"`
	Copyright     *string                        `json:"copyright,omitempty"`
	Count         *Count                         `json:"count,omitempty"`
	Credits       *[]PlayCreditRestObject        `json:"credits,omitempty"`
	Flags         *[]PlayCreditRestObject        `json:"flags,omitempty"`
	Hydrations    *[]string                      `json:"hydrations,omitempty"`
	Matchup       *Matchup                       `json:"matchup,omitempty"`
	PitchIndex    *[]int32                       `json:"pitchIndex,omitempty"`
	PlayEndTime   *time.Time                     `json:"playEndTime,omitempty"`
	PlayEvents    *[]BaseballPlayEventRestObject `json:"playEvents,omitempty"`
	Result        *Result                        `json:"result,omitempty"`
	ReviewDetails *ReviewDetails                 `json:"reviewDetails,omitempty"`
	RunnerIndex   *[]int32                       `json:"runnerIndex,omitempty"`
	Runners       *[]RunnerMovement              `json:"runners,omitempty"`
}

// BaseballPlayerGameScoreRestObject defines model for BaseballPlayerGameScoreRestObject.
type BaseballPlayerGameScoreRestObject struct {
	Copyright         *string                        `json:"copyright,omitempty"`
	GameScore         *int32                         `json:"gameScore,omitempty"`
	HittingGameScore  *int32                         `json:"hittingGameScore,omitempty"`
	PitchingGameScore *int32                         `json:"pitchingGameScore,omitempty"`
	Player            *BaseballRosterEntryRestObject `json:"player,omitempty"`
	Type              *string                        `json:"type,omitempty"`
}

// BaseballPosition defines model for BaseballPosition.
type BaseballPosition string

// BaseballReview defines model for BaseballReview.
type BaseballReview struct {
	ChallengeTeamId  *int32  `json:"challengeTeamId,omitempty"`
	ReviewInProgress *bool   `json:"reviewInProgress,omitempty"`
	ReviewOverturned *bool   `json:"reviewOverturned,omitempty"`
	ReviewType       *string `json:"reviewType,omitempty"`
}

// BaseballReviewRestObject defines model for BaseballReviewRestObject.
type BaseballReviewRestObject struct {
	Away            *BaseballTeamReview     `json:"away,omitempty"`
	ChallengingTeam *BaseballTeamRestObject `json:"challengingTeam,omitempty"`
	Copyright       *string                 `json:"copyright,omitempty"`
	HasChallenges   *bool                   `json:"hasChallenges,omitempty"`
	Home            *BaseballTeamReview     `json:"home,omitempty"`
	Reason          *string                 `json:"reason,omitempty"`
}

// BaseballRoster defines model for BaseballRoster.
type BaseballRoster struct {
	HydratedPeople     *map[string]map[string]interface{} `json:"hydratedPeople,omitempty"`
	RequestingUserRole *Role                              `json:"requestingUserRole,omitempty"`
	Roster             *[]BaseballRosterEntry             `json:"roster,omitempty"`
	RosterType         *RosterType                        `json:"rosterType,omitempty"`
	TeamId             *int32                             `json:"teamId,omitempty"`
	UserPrivileges     *[]Privilege                       `json:"userPrivileges,omitempty"`
}

// BaseballRosterEntry defines model for BaseballRosterEntry.
type BaseballRosterEntry struct {
	AllPositions              *[]BaseballPosition                `json:"allPositions,omitempty"`
	AlternateCaptain          *bool                              `json:"alternateCaptain,omitempty"`
	BattingOrder              *string                            `json:"battingOrder,omitempty"`
	Captain                   *bool                              `json:"captain,omitempty"`
	ClassId                   *int32                             `json:"classId,omitempty"`
	EndDate                   *openapi_types.Date                `json:"endDate,omitempty"`
	HydratedRosterEntriesTeam *map[string]map[string]interface{} `json:"hydratedRosterEntriesTeam,omitempty"`
	IsActive                  *bool                              `json:"isActive,omitempty"`
	IsActiveFortyMan          *bool                              `json:"isActiveFortyMan,omitempty"`
	IsCurrentBatter           *bool                              `json:"isCurrentBatter,omitempty"`
	IsCurrentPitcher          *bool                              `json:"isCurrentPitcher,omitempty"`
	IsOnBench                 *bool                              `json:"isOnBench,omitempty"`
	IsSubstitute              *bool                              `json:"isSubstitute,omitempty"`
	JerseyNumber              *string                            `json:"jerseyNumber,omitempty"`
	Job                       *string                            `json:"job,omitempty"`
	JobId                     *string                            `json:"jobId,omitempty"`
	Note                      *string                            `json:"note,omitempty"`
	ParentTeamId              *int32                             `json:"parentTeamId,omitempty"`
	Person                    *BaseballPerson                    `json:"person,omitempty"`
	PitchingOrder             *int32                             `json:"pitchingOrder,omitempty"`
	Position                  *BaseballPosition                  `json:"position,omitempty"`
	QualifiedForGamePitched   *bool                              `json:"qualifiedForGamePitched,omitempty"`
	RequestingUserRole        *Role                              `json:"requestingUserRole,omitempty"`
	Season                    *string                            `json:"season,omitempty"`
	SeasonStats               *BaseballStats                     `json:"seasonStats,omitempty"`
	SportId                   *int32                             `json:"sportId,omitempty"`
	StartDate                 *openapi_types.Date                `json:"startDate,omitempty"`
	StatContainer             *[]StatContainer                   `json:"statContainer,omitempty"`
	Stats                     *BaseballStats                     `json:"stats,omitempty"`
	Status                    *DynamicLookupEnum                 `json:"status,omitempty"`
	StatusDate                *openapi_types.Date                `json:"statusDate,omitempty"`
	Team                      *BaseballTeam                      `json:"team,omitempty"`
	Title                     *string                            `json:"title,omitempty"`
	UserPrivileges            *[]Privilege                       `json:"userPrivileges,omitempty"`
}

// BaseballRosterEntryRestObject defines model for BaseballRosterEntryRestObject.
type BaseballRosterEntryRestObject struct {
	AllPositions     *[]PositionRestObject     `json:"allPositions,omitempty"`
	AlternateCaptain *bool                     `json:"alternateCaptain,omitempty"`
	BattingOrder     *string                   `json:"battingOrder,omitempty"`
	Captain          *bool                     `json:"captain,omitempty"`
	EndDate          *openapi_types.Date       `json:"endDate,omitempty"`
	GameStatus       *GameStatusRestObject     `json:"gameStatus,omitempty"`
	IsActive         *bool                     `json:"isActive,omitempty"`
	IsActiveFortyMan *bool                     `json:"isActiveFortyMan,omitempty"`
	JerseyNumber     *string                   `json:"jerseyNumber,omitempty"`
	Job              *string                   `json:"job,omitempty"`
	JobId            *string                   `json:"jobId,omitempty"`
	Note             *string                   `json:"note,omitempty"`
	ParentTeamId     *int32                    `json:"parentTeamId,omitempty"`
	Person           *BaseballPersonRestObject `json:"person,omitempty"`

	// Position The x-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The y-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The z-coordinate of the landing position for the ball's trajectory. This will always be z=0 by definition.
	Position    *PositionRestObject     `json:"position,omitempty"`
	SeasonStats *StatsRestObject        `json:"seasonStats,omitempty"`
	StartDate   *openapi_types.Date     `json:"startDate,omitempty"`
	Stats       *StatsRestObject        `json:"stats,omitempty"`
	Status      *DynamicEnumRestObject  `json:"status,omitempty"`
	StatusDate  *openapi_types.Date     `json:"statusDate,omitempty"`
	Team        *BaseballTeamRestObject `json:"team,omitempty"`
	Title       *string                 `json:"title,omitempty"`
}

// BaseballRunnerMovement defines model for BaseballRunnerMovement.
type BaseballRunnerMovement struct {
	Credits            *[]PlayCredit      `json:"credits,omitempty"`
	Earned             *bool              `json:"earned,omitempty"`
	EndBase            *string            `json:"endBase,omitempty"`
	EndBaseInt         *int32             `json:"endBaseInt,omitempty"`
	EventType          *string            `json:"eventType,omitempty"`
	EventTypeEnum      *EventType         `json:"eventTypeEnum,omitempty"`
	Events             *map[string]string `json:"events,omitempty"`
	IsEarned           *bool              `json:"isEarned,omitempty"`
	IsRbi              *bool              `json:"isRbi,omitempty"`
	IsScoringEvent     *bool              `json:"isScoringEvent,omitempty"`
	MovementReason     *string            `json:"movementReason,omitempty"`
	MovementReasonEnum *RunnerDetailType  `json:"movementReasonEnum,omitempty"`
	OriginBase         *int32             `json:"originBase,omitempty"`
	Out                *bool              `json:"out,omitempty"`
	OutBase            *string            `json:"outBase,omitempty"`
	OutNumber          *int32             `json:"outNumber,omitempty"`
	PlayIndex          *int32             `json:"playIndex,omitempty"`
	Rbi                *bool              `json:"rbi,omitempty"`
	ResponsiblePitcher *BaseballPerson    `json:"responsiblePitcher,omitempty"`
	Runner             *BaseballPerson    `json:"runner,omitempty"`
	ScoringEvent       *bool              `json:"scoringEvent,omitempty"`
	Sequence           *int32             `json:"sequence,omitempty"`
	StartBase          *string            `json:"startBase,omitempty"`
	StartBaseInt       *int32             `json:"startBaseInt,omitempty"`
	TeamUnearned       *bool              `json:"teamUnearned,omitempty"`
}

// BaseballSchedule defines model for BaseballSchedule.
type BaseballSchedule struct {
	Abschallenges                  *map[string]map[string]interface{} `json:"abschallenges,omitempty"`
	Alerts                         *map[string]map[string]interface{} `json:"alerts,omitempty"`
	BaseballLineups                *map[string]map[string]interface{} `json:"baseballLineups,omitempty"`
	BaseballSchedule               *[]BaseballScheduleItem            `json:"baseballSchedule,omitempty"`
	Challenges                     *map[string]map[string]interface{} `json:"challenges,omitempty"`
	Flags                          *map[string]map[string]interface{} `json:"flags,omitempty"`
	GamePreviewStoryLegacy         *BaseballScheduleItem              `json:"gamePreviewStoryLegacy,omitempty"`
	GameTypes                      *[]GameTypeEnum                    `json:"gameTypes,omitempty"`
	Games                          *[]BaseballScheduleItem            `json:"games,omitempty"`
	HomeRuns                       *map[string]map[string]interface{} `json:"homeRuns,omitempty"`
	HydratedEventDivisionsAsString *map[string]map[string]interface{} `json:"hydratedEventDivisionsAsString,omitempty"`
	HydratedEventLeaguesAsString   *map[string]map[string]interface{} `json:"hydratedEventLeaguesAsString,omitempty"`
	HydratedEventSportsAsString    *map[string]map[string]interface{} `json:"hydratedEventSportsAsString,omitempty"`
	HydratedEventVenuesAsString    *map[string]map[string]interface{} `json:"hydratedEventVenuesAsString,omitempty"`
	HydratedPeople                 *map[string]map[string]interface{} `json:"hydratedPeople,omitempty"`
	HydratedProbablePitchers       *map[string]map[string]interface{} `json:"hydratedProbablePitchers,omitempty"`
	HydratedStats                  *map[string]map[string]interface{} `json:"hydratedStats,omitempty"`
	HydratedTeamLeaders            *map[string]map[string]interface{} `json:"hydratedTeamLeaders,omitempty"`
	HydratedTeamLeadersInPreview   *map[string]map[string]interface{} `json:"hydratedTeamLeadersInPreview,omitempty"`
	HydratedTeamsAsString          *map[string]map[string]interface{} `json:"hydratedTeamsAsString,omitempty"`
	HydratedVenuesAsString         *map[string]map[string]interface{} `json:"hydratedVenuesAsString,omitempty"`
	IncludeEventTickets            *bool                              `json:"includeEventTickets,omitempty"`
	IncludeSiteBroadcasts          *bool                              `json:"includeSiteBroadcasts,omitempty"`
	LiveLookins                    *map[string]map[string]interface{} `json:"liveLookins,omitempty"`
	PreviousPlay                   *map[string]map[string]interface{} `json:"previousPlay,omitempty"`
	ProbableOfficials              *map[string]map[string]interface{} `json:"probableOfficials,omitempty"`
	ProbablePitchersNotes          *map[string]map[string]interface{} `json:"probablePitchersNotes,omitempty"`
	RefreshInterval                *int32                             `json:"refreshInterval,omitempty"`
	RequestingUserRole             *Role                              `json:"requestingUserRole,omitempty"`
	ScheduleEvents                 *[]ScheduleEvent                   `json:"scheduleEvents,omitempty"`
	ScheduleItems                  *[]BaseballScheduleItem            `json:"scheduleItems,omitempty"`
	TeamsWithGames                 *[]int32                           `json:"teamsWithGames,omitempty"`
	UserPrivileges                 *[]Privilege                       `json:"userPrivileges,omitempty"`
}

// BaseballScheduleItem defines model for BaseballScheduleItem.
type BaseballScheduleItem struct {
	AbsChallenge            *BaseballABSChallenge  `json:"absChallenge,omitempty"`
	Alerts                  *[]BaseballGameAlert   `json:"alerts,omitempty"`
	AtBatPromotions         *[]Promotion           `json:"atBatPromotions,omitempty"`
	AtBatTicketLinks        *[]BaseballTicket      `json:"atBatTicketLinks,omitempty"`
	AtBatTickets            *[]BaseballTicket      `json:"atBatTickets,omitempty"`
	AwayGamesBack           *string                `json:"awayGamesBack,omitempty"`
	AwayIsWinner            *bool                  `json:"awayIsWinner,omitempty"`
	AwayLeagueId            *int32                 `json:"awayLeagueId,omitempty"`
	AwayLosses              *int32                 `json:"awayLosses,omitempty"`
	AwayOvertimeLosses      *int32                 `json:"awayOvertimeLosses,omitempty"`
	AwayProbable            *BaseballPerson        `json:"awayProbable,omitempty"`
	AwayScore               *int32                 `json:"awayScore,omitempty"`
	AwaySeriesNumber        *int32                 `json:"awaySeriesNumber,omitempty"`
	AwaySplitSquad          *bool                  `json:"awaySplitSquad,omitempty"`
	AwayTeam                *BaseballTeam          `json:"awayTeam,omitempty"`
	AwayTies                *int32                 `json:"awayTies,omitempty"`
	AwayWildCardGamesBack   *string                `json:"awayWildCardGamesBack,omitempty"`
	AwayWins                *int32                 `json:"awayWins,omitempty"`
	BaseballLineup          *BaseballLineup        `json:"baseballLineup,omitempty"`
	Broadcasts              *[]GameDateBroadcast   `json:"broadcasts,omitempty"`
	CacheKey                *string                `json:"cacheKey,omitempty"`
	CalendarDate            *openapi_types.Date    `json:"calendarDate,omitempty"`
	CalendarEventId         *string                `json:"calendarEventId,omitempty"`
	Challenge               *BaseballChallenge     `json:"challenge,omitempty"`
	Cms                     *GameCms               `json:"cms,omitempty"`
	CoachingVideo           *[]MediaSourceType     `json:"coachingVideo,omitempty"`
	Day                     *string                `json:"day,omitempty"`
	Decisions               *BaseballDecision      `json:"decisions,omitempty"`
	Description             *string                `json:"description,omitempty"`
	DoubleHeader            *string                `json:"doubleHeader,omitempty"`
	DoubleHeaderGameOneTime *time.Time             `json:"doubleHeaderGameOneTime,omitempty"`
	DoubleHeaderTeamPairKey *string                `json:"doubleHeaderTeamPairKey,omitempty"`
	EditorialGameType       *string                `json:"editorialGameType,omitempty"`
	EditorialSeason         *string                `json:"editorialSeason,omitempty"`
	EndDateTime             *time.Time             `json:"endDateTime,omitempty"`
	Flags                   *BaseballGameFlag      `json:"flags,omitempty"`
	GameDate                *time.Time             `json:"gameDate,omitempty"`
	GameGuid                *string                `json:"gameGuid,omitempty"`
	GameId                  *string                `json:"gameId,omitempty"`
	GameInfo                *GameTO                `json:"gameInfo,omitempty"`
	GameNumber              *int32                 `json:"gameNumber,omitempty"`
	GamePk                  *int32                 `json:"gamePk,omitempty"`
	GameStatus              *IGameStatus           `json:"gameStatus,omitempty"`
	GameType                *GameTypeEnum          `json:"gameType,omitempty"`
	GamedayType             *string                `json:"gamedayType,omitempty"`
	GamesInSeries           *int32                 `json:"gamesInSeries,omitempty"`
	HomeGamesBack           *string                `json:"homeGamesBack,omitempty"`
	HomeIsWinner            *bool                  `json:"homeIsWinner,omitempty"`
	HomeLeagueId            *int32                 `json:"homeLeagueId,omitempty"`
	HomeLosses              *int32                 `json:"homeLosses,omitempty"`
	HomeOvertimeLosses      *int32                 `json:"homeOvertimeLosses,omitempty"`
	HomeProbable            *BaseballPerson        `json:"homeProbable,omitempty"`
	HomeRuns                *[]BaseballPlay        `json:"homeRuns,omitempty"`
	HomeScore               *int32                 `json:"homeScore,omitempty"`
	HomeSeriesNumber        *int32                 `json:"homeSeriesNumber,omitempty"`
	HomeSplitSquad          *bool                  `json:"homeSplitSquad,omitempty"`
	HomeTeam                *BaseballTeam          `json:"homeTeam,omitempty"`
	HomeTies                *int32                 `json:"homeTies,omitempty"`
	HomeWildCardGamesBack   *string                `json:"homeWildCardGamesBack,omitempty"`
	HomeWins                *int32                 `json:"homeWins,omitempty"`
	Hydratable              *bool                  `json:"hydratable,omitempty"`
	IfNecessary             *string                `json:"ifNecessary,omitempty"`
	IfNecessaryDescription  *string                `json:"ifNecessaryDescription,omitempty"`
	InningBreakLength       *int32                 `json:"inningBreakLength,omitempty"`
	IsDefaultGame           *bool                  `json:"isDefaultGame,omitempty"`
	IsDoNotSortAsDH         *bool                  `json:"isDoNotSortAsDH,omitempty"`
	IsFeaturedGame          *bool                  `json:"isFeaturedGame,omitempty"`
	IsNightGame             *bool                  `json:"isNightGame,omitempty"`
	IsTie                   *bool                  `json:"isTie,omitempty"`
	Linescore               *BaseballLinescore     `json:"linescore,omitempty"`
	LinescoreOverrides      *BaseballLinescore     `json:"linescoreOverrides,omitempty"`
	LiveLookin              *LiveLookin            `json:"liveLookin,omitempty"`
	LocalAmPm               *string                `json:"localAmPm,omitempty"`
	LocalDate               *openapi_types.Date    `json:"localDate,omitempty"`
	LocalTime               *string                `json:"localTime,omitempty"`
	LosingTeam              *BaseballTeam          `json:"losingTeam,omitempty"`
	NightGame               *bool                  `json:"nightGame,omitempty"`
	OfficialDate            *openapi_types.Date    `json:"officialDate,omitempty"`
	Officials               *[]Official            `json:"officials,omitempty"`
	PostseasonSeries        *PostseasonSeries      `json:"postseasonSeries,omitempty"`
	PostseasonSeriesId      *string                `json:"postseasonSeriesId,omitempty"`
	PregameOfficials        *[]Official            `json:"pregameOfficials,omitempty"`
	PreviousPlay            *BaseballPlay          `json:"previousPlay,omitempty"`
	Promotions              *[]Promotion           `json:"promotions,omitempty"`
	PublicFacing            *PublicFacingEnum      `json:"publicFacing,omitempty"`
	RadioBroadcasts         *[]GameDateBroadcast   `json:"radioBroadcasts,omitempty"`
	RecordSource            *string                `json:"recordSource,omitempty"`
	RescheduleDate          *time.Time             `json:"rescheduleDate,omitempty"`
	RescheduleGameDate      *openapi_types.Date    `json:"rescheduleGameDate,omitempty"`
	RescheduledFrom         *time.Time             `json:"rescheduledFrom,omitempty"`
	RescheduledFromDate     *openapi_types.Date    `json:"rescheduledFromDate,omitempty"`
	ResumeDate              *time.Time             `json:"resumeDate,omitempty"`
	ResumeGameDate          *openapi_types.Date    `json:"resumeGameDate,omitempty"`
	ResumeVenue             *Venue                 `json:"resumeVenue,omitempty"`
	ResumedFrom             *time.Time             `json:"resumedFrom,omitempty"`
	ResumedFromDate         *openapi_types.Date    `json:"resumedFromDate,omitempty"`
	ResumedFromVenue        *Venue                 `json:"resumedFromVenue,omitempty"`
	ReverseHomeAwayStatus   *bool                  `json:"reverseHomeAwayStatus,omitempty"`
	ScheduledInnings        *int32                 `json:"scheduledInnings,omitempty"`
	ScoringPlays            *[]BaseballPlay        `json:"scoringPlays,omitempty"`
	Season                  *string                `json:"season,omitempty"`
	SeriesDescription       *string                `json:"seriesDescription,omitempty"`
	SeriesGameNumber        *int32                 `json:"seriesGameNumber,omitempty"`
	SeriesStatus            *SeriesStatus          `json:"seriesStatus,omitempty"`
	SortDate                *time.Time             `json:"sortDate,omitempty"`
	SortGameId              *string                `json:"sortGameId,omitempty"`
	SortGameNo              *string                `json:"sortGameNo,omitempty"`
	SortNumber              *int32                 `json:"sortNumber,omitempty"`
	SortTeam                *string                `json:"sortTeam,omitempty"`
	SortTime                *string                `json:"sortTime,omitempty"`
	Sponsorships            *[]Promotion           `json:"sponsorships,omitempty"`
	SportId                 *int32                 `json:"sportId,omitempty"`
	StatusFlags             *StatusFlags           `json:"statusFlags,omitempty"`
	StatusInd               *string                `json:"statusInd,omitempty"`
	Story                   *GameStory             `json:"story,omitempty"`
	Tickets                 *[]BaseballTicket      `json:"tickets,omitempty"`
	Tie                     *bool                  `json:"tie,omitempty"`
	Tiebreaker              *string                `json:"tiebreaker,omitempty"`
	TrackingSystemOwner     *TrackingSystemOwner   `json:"trackingSystemOwner,omitempty"`
	TrackingVersion         *TrackingVersion       `json:"trackingVersion,omitempty"`
	UnmodifiedCalendarDate  *openapi_types.Date    `json:"unmodifiedCalendarDate,omitempty"`
	VendorWeatherForecast   *VendorWeatherForecast `json:"vendorWeatherForecast,omitempty"`
	Venue                   *Venue                 `json:"venue,omitempty"`
	Weather                 *Weather               `json:"weather,omitempty"`
	WinningTeam             *BaseballTeam          `json:"winningTeam,omitempty"`
	XrefIds                 *[]XrefId              `json:"xrefIds,omitempty"`
}

// BaseballScheduleItemRestObject defines model for BaseballScheduleItemRestObject.
type BaseballScheduleItemRestObject struct {
	AbsChallenge           *BaseballABSChallengeRestObject                `json:"absChallenge,omitempty"`
	Alerts                 *[]BaseballGameAlertRestObject                 `json:"alerts,omitempty"`
	AtBatPromotions        *[]PromotionRestObject                         `json:"atBatPromotions,omitempty"`
	AtBatTickets           *[]BaseballTicketRestObject                    `json:"atBatTickets,omitempty"`
	Broadcasts             *[]GameDateBroadcastRestObject                 `json:"broadcasts,omitempty"`
	CalendarEventID        *string                                        `json:"calendarEventID,omitempty"`
	CoachingVideo          *[]string                                      `json:"coachingVideo,omitempty"`
	Content                *GameContentRestObject                         `json:"content,omitempty"`
	Copyright              *string                                        `json:"copyright,omitempty"`
	Day                    *string                                        `json:"day,omitempty"`
	DayNight               *string                                        `json:"dayNight,omitempty"`
	Decisions              *BaseballDecisionRestObject                    `json:"decisions,omitempty"`
	Description            *string                                        `json:"description,omitempty"`
	DoubleHeader           *string                                        `json:"doubleHeader,omitempty"`
	EndDateTime            *time.Time                                     `json:"endDateTime,omitempty"`
	Flags                  *BaseballGameFlagRestObject                    `json:"flags,omitempty"`
	GameDate               *time.Time                                     `json:"gameDate,omitempty"`
	GameGuid               *string                                        `json:"gameGuid,omitempty"`
	GameId                 *string                                        `json:"gameId,omitempty"`
	GameInfo               *GameInfoRestObject                            `json:"gameInfo,omitempty"`
	GameNumber             *int32                                         `json:"gameNumber,omitempty"`
	GamePk                 *int32                                         `json:"gamePk,omitempty"`
	GameType               *string                                        `json:"gameType,omitempty"`
	GamedayType            *string                                        `json:"gamedayType,omitempty"`
	GamesInSeries          *int32                                         `json:"gamesInSeries,omitempty"`
	HomeRuns               *[]BaseballPlayRestObject                      `json:"homeRuns,omitempty"`
	IfNecessary            *string                                        `json:"ifNecessary,omitempty"`
	IfNecessaryDescription *string                                        `json:"ifNecessaryDescription,omitempty"`
	InningBreakLength      *int32                                         `json:"inningBreakLength,omitempty"`
	IsDefaultGame          *bool                                          `json:"isDefaultGame,omitempty"`
	IsFeaturedGame         *bool                                          `json:"isFeaturedGame,omitempty"`
	IsTie                  *bool                                          `json:"isTie,omitempty"`
	Linescore              *BaseballLinescoreRestObject                   `json:"linescore,omitempty"`
	Lineups                *BaseballLineupRestObject                      `json:"lineups,omitempty"`
	Link                   *string                                        `json:"link,omitempty"`
	LiveLookin             *BaseballGameLiveLookinRestObject              `json:"liveLookin,omitempty"`
	OfficialDate           *openapi_types.Date                            `json:"officialDate,omitempty"`
	Officials              *[]OfficialRestObject                          `json:"officials,omitempty"`
	PregameOfficials       *[]OfficialRestObject                          `json:"pregameOfficials,omitempty"`
	PreviousPlay           *BaseballPlayRestObject                        `json:"previousPlay,omitempty"`
	Promotions             *[]PromotionRestObject                         `json:"promotions,omitempty"`
	PublicFacing           *bool                                          `json:"publicFacing,omitempty"`
	RadioBroadcasts        *[]GameDateBroadcastRestObject                 `json:"radioBroadcasts,omitempty"`
	RecordSource           *string                                        `json:"recordSource,omitempty"`
	RescheduleDate         *time.Time                                     `json:"rescheduleDate,omitempty"`
	RescheduleGameDate     *openapi_types.Date                            `json:"rescheduleGameDate,omitempty"`
	RescheduledFrom        *time.Time                                     `json:"rescheduledFrom,omitempty"`
	RescheduledFromDate    *openapi_types.Date                            `json:"rescheduledFromDate,omitempty"`
	ResumeDate             *time.Time                                     `json:"resumeDate,omitempty"`
	ResumeGameDate         *openapi_types.Date                            `json:"resumeGameDate,omitempty"`
	ResumedFrom            *time.Time                                     `json:"resumedFrom,omitempty"`
	ResumedFromDate        *openapi_types.Date                            `json:"resumedFromDate,omitempty"`
	ReverseHomeAwayStatus  *bool                                          `json:"reverseHomeAwayStatus,omitempty"`
	Review                 *BaseballReviewRestObject                      `json:"review,omitempty"`
	RuleSettings           *[]RuleSettingsRestObject                      `json:"ruleSettings,omitempty"`
	ScheduledInnings       *int32                                         `json:"scheduledInnings,omitempty"`
	ScoringPlays           *[]BaseballPlayRestObject                      `json:"scoringPlays,omitempty"`
	Season                 *string                                        `json:"season,omitempty"`
	SeasonDisplay          *string                                        `json:"seasonDisplay,omitempty"`
	SeriesDescription      *string                                        `json:"seriesDescription,omitempty"`
	SeriesGameNumber       *int32                                         `json:"seriesGameNumber,omitempty"`
	SeriesStatus           *SeriesStatusRestObject                        `json:"seriesStatus,omitempty"`
	SortNumber             *int32                                         `json:"sortNumber,omitempty"`
	Sponsorships           *[]PromotionRestObject                         `json:"sponsorships,omitempty"`
	Status                 *GameStatusRestObject                          `json:"status,omitempty"`
	StatusFlags            *StatusFlagsRestObject                         `json:"statusFlags,omitempty"`
	Story                  *GameStoryRestObject                           `json:"story,omitempty"`
	Teams                  *map[string]BaseballScheduleItemTeamRestObject `json:"teams,omitempty"`
	Tickets                *[]BaseballTicketRestObject                    `json:"tickets,omitempty"`
	Tiebreaker             *string                                        `json:"tiebreaker,omitempty"`
	TrackingVersion        *TrackingVersionRestObject                     `json:"trackingVersion,omitempty"`
	Venue                  *VenueRestObject                               `json:"venue,omitempty"`
	Weather                *WeatherRestObject                             `json:"weather,omitempty"`
	WeatherForecast        *VendorWeatherForecastRestObject               `json:"weatherForecast,omitempty"`
	XrefIds                *[]XrefIdRestObject                            `json:"xrefIds,omitempty"`
}

// BaseballScheduleItemTeamRestObject defines model for BaseballScheduleItemTeamRestObject.
type BaseballScheduleItemTeamRestObject struct {
	Copyright       *string                   `json:"copyright,omitempty"`
	IsWinner        *bool                     `json:"isWinner,omitempty"`
	LeagueRecord    *WinLossRecordRestObject  `json:"leagueRecord,omitempty"`
	ProbablePitcher *BaseballPersonRestObject `json:"probablePitcher,omitempty"`
	Score           *int32                    `json:"score,omitempty"`
	SeedNumber      *int32                    `json:"seedNumber,omitempty"`
	SeriesNumber    *int32                    `json:"seriesNumber,omitempty"`
	SplitSquad      *bool                     `json:"splitSquad,omitempty"`
	SpringLeague    *LeagueRestObject         `json:"springLeague,omitempty"`
	Team            *BaseballTeamRestObject   `json:"team,omitempty"`
}

// BaseballStats defines model for BaseballStats.
type BaseballStats struct {
	AllStats      *[]StatContainer `json:"allStats,omitempty"`
	BattingStats  *BattingData     `json:"battingStats,omitempty"`
	FieldingStats *FieldingData    `json:"fieldingStats,omitempty"`
	GameStats     *GameStatData    `json:"gameStats,omitempty"`
	PitchingStats *PitchingData    `json:"pitchingStats,omitempty"`
	TeamStats     *TeamStatData    `json:"teamStats,omitempty"`
}

// BaseballStatsEnum defines model for BaseballStatsEnum.
type BaseballStatsEnum string

// BaseballStatsTypeRestObject defines model for BaseballStatsTypeRestObject.
type BaseballStatsTypeRestObject struct {
	HighLowTypes *[]HighLowTypeEnum  `json:"highLowTypes,omitempty"`
	IsCounting   *bool               `json:"isCounting,omitempty"`
	Label        *string             `json:"label,omitempty"`
	LookupParam  *string             `json:"lookupParam,omitempty"`
	Name         *string             `json:"name,omitempty"`
	OrgTypes     *[]OrganizationType `json:"orgTypes,omitempty"`
	StatGroups   *[]StatGroup        `json:"statGroups,omitempty"`
	StreakLevels *[]StreakLevelEnum  `json:"streakLevels,omitempty"`
}

// BaseballTeam defines model for BaseballTeam.
type BaseballTeam struct {
	Abbreviation                *string                            `json:"abbreviation,omitempty"`
	Active                      *bool                              `json:"active,omitempty"`
	AllStarStatus               *AllStarEnum                       `json:"allStarStatus,omitempty"`
	CacheKey                    *string                            `json:"cacheKey,omitempty"`
	ClubName                    *string                            `json:"clubName,omitempty"`
	Conference                  *Conference                        `json:"conference,omitempty"`
	Content                     *TeamContentCms                    `json:"content,omitempty"`
	DeviceProperties            *JsonNode                          `json:"deviceProperties,omitempty"`
	Division                    *Division                          `json:"division,omitempty"`
	FileCode                    *string                            `json:"fileCode,omitempty"`
	FirstYearOfPlay             *string                            `json:"firstYearOfPlay,omitempty"`
	Franchise                   *Franchise                         `json:"franchise,omitempty"`
	FranchiseName               *string                            `json:"franchiseName,omitempty"`
	HomeAway                    *string                            `json:"homeAway,omitempty"`
	HydratedDeviceProperties    *map[string]map[string]interface{} `json:"hydratedDeviceProperties,omitempty"`
	HydratedGamePromotions      *map[string]map[string]interface{} `json:"hydratedGamePromotions,omitempty"`
	HydratedGamePromotionsAtBat *map[string]map[string]interface{} `json:"hydratedGamePromotionsAtBat,omitempty"`
	HydratedGameSponsorships    *map[string]map[string]interface{} `json:"hydratedGameSponsorships,omitempty"`
	HydratedGameTickets         *map[string]map[string]interface{} `json:"hydratedGameTickets,omitempty"`
	HydratedGameTicketsAtBat    *map[string]map[string]interface{} `json:"hydratedGameTicketsAtBat,omitempty"`
	HydratedSocial              *map[string]map[string]interface{} `json:"hydratedSocial,omitempty"`
	Id                          *int32                             `json:"id,omitempty"`
	League                      *League                            `json:"league,omitempty"`
	LeagueId                    *int32                             `json:"leagueId,omitempty"`
	Location                    *Location                          `json:"location,omitempty"`
	LocationName                *string                            `json:"locationName,omitempty"`
	Name                        *string                            `json:"name,omitempty"`
	NameLanguageHistoryEnd      *openapi_types.Date                `json:"nameLanguageHistoryEnd,omitempty"`
	NameLanguageHistoryStart    *openapi_types.Date                `json:"nameLanguageHistoryStart,omitempty"`
	NextGameSchedule            *BaseballSchedule                  `json:"nextGameSchedule,omitempty"`
	NextSchedule                *BaseballSchedule                  `json:"nextSchedule,omitempty"`
	OtherTeamNames              *OtherTeamNames                    `json:"otherTeamNames,omitempty"`
	ParentOrgId                 *int32                             `json:"parentOrgId,omitempty"`
	ParentOrgName               *string                            `json:"parentOrgName,omitempty"`
	Placeholder                 *bool                              `json:"placeholder,omitempty"`
	PlayoffInfo                 *TeamPlayoffs                      `json:"playoffInfo,omitempty"`
	PreviousGameSchedule        *BaseballSchedule                  `json:"previousGameSchedule,omitempty"`
	PreviousSchedule            *BaseballSchedule                  `json:"previousSchedule,omitempty"`
	Record                      *BaseballTeamStandingsRecord       `json:"record,omitempty"`
	RequestingUserRole          *Role                              `json:"requestingUserRole,omitempty"`
	Roster                      *BaseballRoster                    `json:"roster,omitempty"`
	Season                      *int32                             `json:"season,omitempty"`
	SeedNumber                  *int32                             `json:"seedNumber,omitempty"`
	ShortName                   *string                            `json:"shortName,omitempty"`
	SocialMediaInfo             *SocialMediaInfo                   `json:"socialMediaInfo,omitempty"`
	Sport                       *Sport                             `json:"sport,omitempty"`
	SpringLeague                *League                            `json:"springLeague,omitempty"`
	SpringVenue                 *Venue                             `json:"springVenue,omitempty"`
	StrSeason                   *string                            `json:"strSeason,omitempty"`
	TeamCode                    *string                            `json:"teamCode,omitempty"`
	TeamDesignation             *TeamDesignationEnum               `json:"teamDesignation,omitempty"`
	TeamLeaders                 *[]Leaders                         `json:"teamLeaders,omitempty"`
	TeamName                    *string                            `json:"teamName,omitempty"`
	TeamSeq                     *int32                             `json:"teamSeq,omitempty"`
	TeamStats                   *[]StatContainer                   `json:"teamStats,omitempty"`
	Tickets                     *[]BaseballTicket                  `json:"tickets,omitempty"`
	Twitter                     *string                            `json:"twitter,omitempty"`
	UserPrivileges              *[]Privilege                       `json:"userPrivileges,omitempty"`
	Venue                       *Venue                             `json:"venue,omitempty"`
	XrefIds                     *[]XrefId                          `json:"xrefIds,omitempty"`
}

// BaseballTeamBoxscore defines model for BaseballTeamBoxscore.
type BaseballTeamBoxscore struct {
	Batters      *[]int32                                  `json:"batters,omitempty"`
	BattingOrder *[]int32                                  `json:"battingOrder,omitempty"`
	Bench        *[]int32                                  `json:"bench,omitempty"`
	Bullpen      *[]int32                                  `json:"bullpen,omitempty"`
	Info         *[]BaseballBoxscoreNoteWrapRestObject     `json:"info,omitempty"`
	Note         *[]BaseballBoxscoreNoteRestObject         `json:"note,omitempty"`
	Pitchers     *[]int32                                  `json:"pitchers,omitempty"`
	Players      *map[string]BaseballRosterEntryRestObject `json:"players,omitempty"`
	Team         *BaseballTeamRestObject                   `json:"team,omitempty"`
	TeamStats    *StatsRestObject                          `json:"teamStats,omitempty"`
}

// BaseballTeamRestObject defines model for BaseballTeamRestObject.
type BaseballTeamRestObject struct {
	Abbreviation         *string                        `json:"abbreviation,omitempty"`
	Active               *bool                          `json:"active,omitempty"`
	AllStarStatus        *AllStarEnum                   `json:"allStarStatus,omitempty"`
	ClubName             *string                        `json:"clubName,omitempty"`
	Conference           *ConferenceRestObject          `json:"conference,omitempty"`
	Content              *TeamContentCms                `json:"content,omitempty"`
	Copyright            *string                        `json:"copyright,omitempty"`
	DeviceProperties     *JsonNode                      `json:"deviceProperties,omitempty"`
	Division             *DivisionRestObject            `json:"division,omitempty"`
	FileCode             *string                        `json:"fileCode,omitempty"`
	FirstYearOfPlay      *string                        `json:"firstYearOfPlay,omitempty"`
	Franchise            *FranchiseRestObject           `json:"franchise,omitempty"`
	FranchiseName        *string                        `json:"franchiseName,omitempty"`
	HomeAway             *string                        `json:"homeAway,omitempty"`
	Hydrations           *[]string                      `json:"hydrations,omitempty"`
	Id                   *int32                         `json:"id,omitempty"`
	League               *LeagueRestObject              `json:"league,omitempty"`
	Link                 *string                        `json:"link,omitempty"`
	Location             *LocationRestObject            `json:"location,omitempty"`
	LocationName         *string                        `json:"locationName,omitempty"`
	Name                 *string                        `json:"name,omitempty"`
	NextGameSchedule     *ScheduleRestObject            `json:"nextGameSchedule,omitempty"`
	NextSchedule         *ScheduleRestObject            `json:"nextSchedule,omitempty"`
	ParentOrgId          *int32                         `json:"parentOrgId,omitempty"`
	ParentOrgName        *string                        `json:"parentOrgName,omitempty"`
	Placeholder          *bool                          `json:"placeholder,omitempty"`
	PlayoffInfo          *TeamPlayoffs                  `json:"playoffInfo,omitempty"`
	PreviousGameSchedule *ScheduleRestObject            `json:"previousGameSchedule,omitempty"`
	PreviousSchedule     *ScheduleRestObject            `json:"previousSchedule,omitempty"`
	Record               *TeamStandingsRecordRestObject `json:"record,omitempty"`
	Roster               *RosterRestObject              `json:"roster,omitempty"`
	Season               *int32                         `json:"season,omitempty"`
	ShortName            *string                        `json:"shortName,omitempty"`
	Social               *SocialMediaRestObject         `json:"social,omitempty"`
	Sport                *SportRestObject               `json:"sport,omitempty"`
	SpringLeague         *LeagueRestObject              `json:"springLeague,omitempty"`
	SpringVenue          *VenueRestObject               `json:"springVenue,omitempty"`
	TeamCode             *string                        `json:"teamCode,omitempty"`
	TeamDesignation      *string                        `json:"teamDesignation,omitempty"`
	TeamLeaders          *[]LeadersRestObject           `json:"teamLeaders,omitempty"`
	TeamName             *string                        `json:"teamName,omitempty"`
	TeamStats            *[]StatContainerRestObject     `json:"teamStats,omitempty"`
	TriCode              *string                        `json:"triCode,omitempty"`
	Venue                *VenueRestObject               `json:"venue,omitempty"`
	XrefIds              *[]XrefIdRestObject            `json:"xrefIds,omitempty"`
}

// BaseballTeamReview defines model for BaseballTeamReview.
type BaseballTeamReview struct {
	Copyright      *string `json:"copyright,omitempty"`
	Remaining      *int32  `json:"remaining,omitempty"`
	UsedFailed     *int32  `json:"usedFailed,omitempty"`
	UsedSuccessful *int32  `json:"usedSuccessful,omitempty"`
}

// BaseballTeamStandingsRecord defines model for BaseballTeamStandingsRecord.
type BaseballTeamStandingsRecord struct {
	Away                        *string          `json:"away,omitempty"`
	ClinchIndicator             *string          `json:"clinchIndicator,omitempty"`
	Clinched                    *bool            `json:"clinched,omitempty"`
	Conference                  *Conference      `json:"conference,omitempty"`
	ConferenceGamesBack         *string          `json:"conferenceGamesBack,omitempty"`
	ConferenceRank              *string          `json:"conferenceRank,omitempty"`
	ConferenceRecords           *[]WinLossRecord `json:"conferenceRecords,omitempty"`
	Day                         *string          `json:"day,omitempty"`
	DivisionChamp               *bool            `json:"divisionChamp,omitempty"`
	DivisionGamesBack           *string          `json:"divisionGamesBack,omitempty"`
	DivisionOdds                *float64         `json:"divisionOdds,omitempty"`
	DivisionRank                *string          `json:"divisionRank,omitempty"`
	DivisionRecords             *[]WinLossRecord `json:"divisionRecords,omitempty"`
	EliminationNumber           *string          `json:"eliminationNumber,omitempty"`
	EliminationNumberConference *string          `json:"eliminationNumberConference,omitempty"`
	EliminationNumberDivision   *string          `json:"eliminationNumberDivision,omitempty"`
	EliminationNumberLeague     *string          `json:"eliminationNumberLeague,omitempty"`
	EliminationNumberSport      *string          `json:"eliminationNumberSport,omitempty"`
	EliminationNumberWildcard   *string          `json:"eliminationNumberWildcard,omitempty"`
	ExpectedRecords             *[]WinLossRecord `json:"expectedRecords,omitempty"`
	ExpectedWinLoss             *string          `json:"expectedWinLoss,omitempty"`
	ExpectedWinLossSeason       *string          `json:"expectedWinLossSeason,omitempty"`
	ExtraInnings                *string          `json:"extraInnings,omitempty"`
	GamesBack                   *string          `json:"gamesBack,omitempty"`
	GamesPlayed                 *int32           `json:"gamesPlayed,omitempty"`
	Grass                       *string          `json:"grass,omitempty"`
	HasPlayoffPoints            *bool            `json:"hasPlayoffPoints,omitempty"`
	HasWildcard                 *bool            `json:"hasWildcard,omitempty"`
	Home                        *string          `json:"home,omitempty"`
	IsDivisionLeader            *bool            `json:"isDivisionLeader,omitempty"`
	IsWildCardTeam              *bool            `json:"isWildCardTeam,omitempty"`
	LastTen                     *string          `json:"lastTen,omitempty"`
	LastUpdated                 *time.Time       `json:"lastUpdated,omitempty"`
	LeagueGamesBack             *string          `json:"leagueGamesBack,omitempty"`
	LeagueRank                  *string          `json:"leagueRank,omitempty"`
	LeagueRecords               *[]WinLossRecord `json:"leagueRecords,omitempty"`
	Losses                      *int32           `json:"losses,omitempty"`
	MagicNumber                 *string          `json:"magicNumber,omitempty"`
	Night                       *string          `json:"night,omitempty"`
	OneRunGames                 *string          `json:"oneRunGames,omitempty"`
	OverallRecords              *[]WinLossRecord `json:"overallRecords,omitempty"`
	Place                       *int32           `json:"place,omitempty"`
	PlayoffOdds                 *float64         `json:"playoffOdds,omitempty"`
	Points                      *int32           `json:"points,omitempty"`
	RunDifferental              *int32           `json:"runDifferental,omitempty"`
	RunsAllowed                 *int32           `json:"runsAllowed,omitempty"`
	RunsScored                  *int32           `json:"runsScored,omitempty"`
	Season                      *string          `json:"season,omitempty"`
	SplitRecords                *[]WinLossRecord `json:"splitRecords,omitempty"`
	SportGamesBack              *string          `json:"sportGamesBack,omitempty"`
	SportRank                   *string          `json:"sportRank,omitempty"`
	SpringLeagueGamesBack       *string          `json:"springLeagueGamesBack,omitempty"`
	SpringLeagueRank            *string          `json:"springLeagueRank,omitempty"`
	Streak                      *string          `json:"streak,omitempty"`
	Team                        *BaseballTeam    `json:"team,omitempty"`
	Ties                        *int32           `json:"ties,omitempty"`
	Turf                        *string          `json:"turf,omitempty"`
	VsCentral                   *string          `json:"vsCentral,omitempty"`
	VsEast                      *string          `json:"vsEast,omitempty"`
	VsInterleague               *string          `json:"vsInterleague,omitempty"`
	VsLeft                      *string          `json:"vsLeft,omitempty"`
	VsLeftAwayLoss              *string          `json:"vsLeftAwayLoss,omitempty"`
	VsLeftAwayWin               *string          `json:"vsLeftAwayWin,omitempty"`
	VsLeftHomeLoss              *string          `json:"vsLeftHomeLoss,omitempty"`
	VsLeftHomeWin               *string          `json:"vsLeftHomeWin,omitempty"`
	VsRight                     *string          `json:"vsRight,omitempty"`
	VsRightAwayLoss             *string          `json:"vsRightAwayLoss,omitempty"`
	VsRightAwayWin              *string          `json:"vsRightAwayWin,omitempty"`
	VsRightHomeLoss             *string          `json:"vsRightHomeLoss,omitempty"`
	VsRightHomeWin              *string          `json:"vsRightHomeWin,omitempty"`
	VsWest                      *string          `json:"vsWest,omitempty"`
	VsWinners                   *string          `json:"vsWinners,omitempty"`
	WildCardGamesBack           *string          `json:"wildCardGamesBack,omitempty"`
	WildCardLeader              *bool            `json:"wildCardLeader,omitempty"`
	WildCardRank                *string          `json:"wildCardRank,omitempty"`
	WildcardOdds                *float64         `json:"wildcardOdds,omitempty"`
	WildcardPlace               *int32           `json:"wildcardPlace,omitempty"`
	WinningPercentage           *float64         `json:"winningPercentage,omitempty"`
	Wins                        *int32           `json:"wins,omitempty"`
}

// BaseballTeamUniformRestObject defines model for BaseballTeamUniformRestObject.
type BaseballTeamUniformRestObject struct {
	Copyright     *string              `json:"copyright,omitempty"`
	Id            *int32               `json:"id,omitempty"`
	Link          *string              `json:"link,omitempty"`
	TeamName      *string              `json:"teamName,omitempty"`
	UniformAssets *[]UniformRestObject `json:"uniformAssets,omitempty"`
}

// BaseballTicket defines model for BaseballTicket.
type BaseballTicket struct {
	AwayTicketLink *string    `json:"awayTicketLink,omitempty"`
	HomeTicketLink *string    `json:"homeTicketLink,omitempty"`
	OnSaleEndDate  *time.Time `json:"onSaleEndDate,omitempty"`
	ScheduleId     *int32     `json:"scheduleId,omitempty"`
	TicketLink     *string    `json:"ticketLink,omitempty"`
	TicketType     *string    `json:"ticketType,omitempty"`
}

// BaseballTicketRestObject defines model for BaseballTicketRestObject.
type BaseballTicketRestObject struct {
	Copyright   *string            `json:"copyright,omitempty"`
	TicketLink  *string            `json:"ticketLink,omitempty"`
	TicketLinks *map[string]string `json:"ticketLinks,omitempty"`
	TicketType  *string            `json:"ticketType,omitempty"`
}

// BaseballViolation defines model for BaseballViolation.
type BaseballViolation struct {
	ViolationDescription *string         `json:"violationDescription,omitempty"`
	ViolationPlayer      *BaseballPerson `json:"violationPlayer,omitempty"`
	ViolationSubType     *string         `json:"violationSubType,omitempty"`
	ViolationType        *string         `json:"violationType,omitempty"`
}

// BasicWeatherWrapperRestObject defines model for BasicWeatherWrapperRestObject.
type BasicWeatherWrapperRestObject struct {
	Copyright *string                      `json:"copyright,omitempty"`
	Data      *WeatherConditionsRestObject `json:"data,omitempty"`
	Units     *JsonNode                    `json:"units,omitempty"`
}

// BatImpactRestObject defines model for BatImpactRestObject.
type BatImpactRestObject struct {
	// AttackAngle The angle of the bat's path, at impact, relative to horizontal. A negative value represents swinging downward, a positive value upward.
	AttackAngle *float64 `json:"attackAngle,omitempty"`

	// ContactPoint Location of impact point.
	ContactPoint *ContactPointPositionRestObject `json:"contactPoint,omitempty"`
	Copyright    *string                         `json:"copyright,omitempty"`

	// HandlePosition Location of the handle of the bat during impact. The distance from head to handle is currently fixed at 32.677 inches.
	HandlePosition *HandlePositionRestObject `json:"handlePosition,omitempty"`

	// HeadPosition Location of the head of the bat during impact.
	HeadPosition *HeadPositionRestObject   `json:"headPosition,omitempty"`
	Speed        *BatImpactSpeedRestObject `json:"speed,omitempty"`

	// TimeStamp TimeStamp when bat and ball either intersect in case of contact, or in cases where they dont collide, timeStamp where ball is closest to any point along the bat.
	TimeStamp *string                      `json:"timeStamp,omitempty"`
	Velocity  *BatImpactVelocityRestObject `json:"velocity,omitempty"`
}

// BatImpactSpeedRestObject defines model for BatImpactSpeedRestObject.
type BatImpactSpeedRestObject struct {
	// After Speed of impact point right after contact.
	After *float64 `json:"after,omitempty"`

	// Before Speed of impact point right before contact.
	Before    *float64 `json:"before,omitempty"`
	Copyright *string  `json:"copyright,omitempty"`
}

// BatImpactVelocityRestObject defines model for BatImpactVelocityRestObject.
type BatImpactVelocityRestObject struct {
	// After Velocity of the given point, right after impact.
	After *BatImpactVelocityRestObjectAfter `json:"after,omitempty"`

	// Before Velocity of the given point, right before impact.
	Before    *BatImpactVelocityRestObjectBefore `json:"before,omitempty"`
	Copyright *string                            `json:"copyright,omitempty"`
}

// BatImpactVelocityRestObjectAfter Velocity of the given point, right after impact.
type BatImpactVelocityRestObjectAfter struct {
	Copyright *string `json:"copyright,omitempty"`

	// X Represents the horizontal dimension, negative toward third base, positive toward first base.
	X *float64 `json:"x,omitempty"`

	// Y Represents the depth dimension, negative toward the backstop, positive toward pitchers mound.
	Y *float64 `json:"y,omitempty"`

	// Z Represents the vertical dimension, from the ground upward.
	Z *float64 `json:"z,omitempty"`
}

// BatImpactVelocityRestObjectBefore Velocity of the given point, right before impact.
type BatImpactVelocityRestObjectBefore struct {
	Copyright *string `json:"copyright,omitempty"`

	// X Represents the horizontal dimension, negative toward third base, positive toward first base.
	X *float64 `json:"x,omitempty"`

	// Y Represents the depth dimension, negative toward the backstop, positive toward pitchers mound.
	Y *float64 `json:"y,omitempty"`

	// Z Represents the vertical dimension, from the ground upward.
	Z *float64 `json:"z,omitempty"`
}

// BatPositionRestObject defines model for BatPositionRestObject.
type BatPositionRestObject struct {
	Copyright *string `json:"copyright,omitempty"`

	// PositionId Identifier for which part of the bat the positions/timeStamp represent. For now this will only be the head and the handle, but is subject to change in the future.
	PositionId *string `json:"positionId,omitempty"`

	// Positions Locations of the head of the bat at the given timeStamps.
	Positions *[]PositionRestObject `json:"positions,omitempty"`
}

// BatSweetSpotRestObject defines model for BatSweetSpotRestObject.
type BatSweetSpotRestObject struct {
	// AxialOffset Distance from the sweetSpot to the impact point along the bat. Negative is towards the handle of the bat, positive towards the head.
	AxialOffset *float64 `json:"axialOffset,omitempty"`
	Copyright   *string  `json:"copyright,omitempty"`

	// DistanceFromHead Distance along the bat from the sweetSpot towards the head. Will be constant for all swings.
	DistanceFromHead *float64 `json:"distanceFromHead,omitempty"`

	// RadialOffset Distance from the sweetSpot to the impact point perpendicular to the bat. Negative is below the center of the bat, positive is above.
	RadialOffset *float64 `json:"radialOffset,omitempty"`

	// SpeedBeforeImpact The speed of the sweetSpot right before contact.
	SpeedBeforeImpact *float64                     `json:"speedBeforeImpact,omitempty"`
	Velocity          *BatImpactVelocityRestObject `json:"velocity,omitempty"`
}

// BatTrackingRestObject defines model for BatTrackingRestObject.
type BatTrackingRestObject struct {
	BatPositions *[]BatPositionRestObject `json:"batPositions,omitempty"`
	Copyright    *string                  `json:"copyright,omitempty"`

	// GamePk Unique game identifier.
	GamePk *int32               `json:"gamePk,omitempty"`
	Impact *BatImpactRestObject `json:"impact,omitempty"`

	// PlayId Unique play identifier (per game).
	PlayId    *string                      `json:"playId,omitempty"`
	SweetSpot *BatSweetSpotRestObject      `json:"sweetSpot,omitempty"`
	System    *BatTrackingSystemRestObject `json:"system,omitempty"`
	Units     *JsonNode                    `json:"units,omitempty"`
}

// BatTrackingSystemRestObject defines model for BatTrackingSystemRestObject.
type BatTrackingSystemRestObject struct {
	Configuration *string `json:"configuration,omitempty"`
	Copyright     *string `json:"copyright,omitempty"`
}

// BatterDetailType defines model for BatterDetailType.
type BatterDetailType string

// BattingData defines model for BattingData.
type BattingData struct {
	AirOuts                      *int32             `json:"airOuts,omitempty"`
	Assists                      *int32             `json:"assists,omitempty"`
	AtBats                       *int32             `json:"atBats,omitempty"`
	AtBatsPerHomeRun             *string            `json:"atBatsPerHomeRun,omitempty"`
	AtBatsPerHomeRunOrNull       *string            `json:"atBatsPerHomeRunOrNull,omitempty"`
	Average                      *string            `json:"average,omitempty"`
	Babip                        *string            `json:"babip,omitempty"`
	BallsInPlay                  *int32             `json:"ballsInPlay,omitempty"`
	BattingOrder                 *string            `json:"battingOrder,omitempty"`
	CatchersInterference         *int32             `json:"catchersInterference,omitempty"`
	CaughtStealing               *int32             `json:"caughtStealing,omitempty"`
	Chances                      *int32             `json:"chances,omitempty"`
	Doubles                      *int32             `json:"doubles,omitempty"`
	ExtraBaseHits                *int32             `json:"extraBaseHits,omitempty"`
	FlyHits                      *int32             `json:"flyHits,omitempty"`
	FlyOuts                      *int32             `json:"flyOuts,omitempty"`
	Games                        *int32             `json:"games,omitempty"`
	GamesPlayedOnBothTeams       *int32             `json:"gamesPlayedOnBothTeams,omitempty"`
	GamesStarted                 *int32             `json:"gamesStarted,omitempty"`
	Gidp                         *int32             `json:"gidp,omitempty"`
	GidpOpportunites             *int32             `json:"gidpOpportunites,omitempty"`
	Gitp                         *int32             `json:"gitp,omitempty"`
	GoAo                         *string            `json:"goAo,omitempty"`
	GroundHits                   *int32             `json:"groundHits,omitempty"`
	GroundOuts                   *int32             `json:"groundOuts,omitempty"`
	HitByPitch                   *int32             `json:"hitByPitch,omitempty"`
	Hits                         *int32             `json:"hits,omitempty"`
	HomeRuns                     *int32             `json:"homeRuns,omitempty"`
	IntentionalWalks             *int32             `json:"intentionalWalks,omitempty"`
	LeftOnBase                   *int32             `json:"leftOnBase,omitempty"`
	LineHits                     *int32             `json:"lineHits,omitempty"`
	LineOuts                     *int32             `json:"lineOuts,omitempty"`
	Note                         *string            `json:"note,omitempty"`
	NumberOfPitches              *int32             `json:"numberOfPitches,omitempty"`
	OnBasePercentage             *string            `json:"onBasePercentage,omitempty"`
	OnBasePlusSlugging           *string            `json:"onBasePlusSlugging,omitempty"`
	Outs                         *int32             `json:"outs,omitempty"`
	Pickoffs                     *int32             `json:"pickoffs,omitempty"`
	PitchesPerPlateAppearance    *float64           `json:"pitchesPerPlateAppearance,omitempty"`
	PitchesPerPlateAppearanceStr *string            `json:"pitchesPerPlateAppearanceStr,omitempty"`
	PlateAppearances             *int32             `json:"plateAppearances,omitempty"`
	PopHits                      *int32             `json:"popHits,omitempty"`
	PopOuts                      *int32             `json:"popOuts,omitempty"`
	Putouts                      *int32             `json:"putouts,omitempty"`
	RequestingUserRole           *Role              `json:"requestingUserRole,omitempty"`
	Runs                         *int32             `json:"runs,omitempty"`
	RunsBattedIn                 *int32             `json:"runsBattedIn,omitempty"`
	SacBunts                     *int32             `json:"sacBunts,omitempty"`
	SacFlies                     *int32             `json:"sacFlies,omitempty"`
	Singles                      *int32             `json:"singles,omitempty"`
	Slugging                     *string            `json:"slugging,omitempty"`
	StolenBasePercentage         *string            `json:"stolenBasePercentage,omitempty"`
	StolenBasePercentageOrNull   *string            `json:"stolenBasePercentageOrNull,omitempty"`
	StolenBases                  *int32             `json:"stolenBases,omitempty"`
	Streak                       *int32             `json:"streak,omitempty"`
	Strikeouts                   *int32             `json:"strikeouts,omitempty"`
	Summary                      *map[string]string `json:"summary,omitempty"`
	SwingsAndMisses              *int32             `json:"swingsAndMisses,omitempty"`
	TotalBases                   *int32             `json:"totalBases,omitempty"`
	TotalSwings                  *int32             `json:"totalSwings,omitempty"`
	Triples                      *int32             `json:"triples,omitempty"`
	UserPrivileges               *[]Privilege       `json:"userPrivileges,omitempty"`
	Walks                        *int32             `json:"walks,omitempty"`
	WildPitches                  *int32             `json:"wildPitches,omitempty"`
}

// Breaks defines model for Breaks.
type Breaks struct {
	BreakAngle           *float64 `json:"breakAngle,omitempty"`
	BreakHorizontal      *float64 `json:"breakHorizontal,omitempty"`
	BreakLength          *float64 `json:"breakLength,omitempty"`
	BreakVertical        *float64 `json:"breakVertical,omitempty"`
	BreakVerticalInduced *float64 `json:"breakVerticalInduced,omitempty"`
	BreakX               *float64 `json:"breakX,omitempty"`
	BreakY               *float64 `json:"breakY,omitempty"`
	BreakZ               *float64 `json:"breakZ,omitempty"`
	SpinDirection        *int32   `json:"spinDirection,omitempty"`
	SpinRate             *int32   `json:"spinRate,omitempty"`
}

// BroadcastAvailability defines model for BroadcastAvailability.
type BroadcastAvailability string

// BroadcastAvailabilityRestObject defines model for BroadcastAvailabilityRestObject.
type BroadcastAvailabilityRestObject struct {
	AvailabilityCode *string `json:"availabilityCode,omitempty"`
	AvailabilityId   *int32  `json:"availabilityId,omitempty"`
	AvailabilityText *string `json:"availabilityText,omitempty"`
	Copyright        *string `json:"copyright,omitempty"`
}

// Broadcaster defines model for Broadcaster.
type Broadcaster struct {
	ActiveStatus          *bool                  `json:"activeStatus,omitempty"`
	BroadcastAvailability *BroadcastAvailability `json:"broadcastAvailability,omitempty"`
	BroadcasterComment    *string                `json:"broadcasterComment,omitempty"`
	BroadcasterDesc       *string                `json:"broadcasterDesc,omitempty"`
	BroadcasterId         *int32                 `json:"broadcasterId,omitempty"`
	BroadcasterText       *string                `json:"broadcasterText,omitempty"`
	BroadcasterTypeCode   *string                `json:"broadcasterTypeCode,omitempty"`
	BroadcasterTypeDesc   *string                `json:"broadcasterTypeDesc,omitempty"`
	BroadcasterTypeId     *int32                 `json:"broadcasterTypeId,omitempty"`
	BroadcasterTypeText   *string                `json:"broadcasterTypeText,omitempty"`
	CallSign              *string                `json:"callSign,omitempty"`
	IsNationalStatus      *bool                  `json:"isNationalStatus,omitempty"`
	Language              *Language              `json:"language,omitempty"`
	MvpdAuthBroadcast     *bool                  `json:"mvpdAuthBroadcast,omitempty"`
	PrimaryTeamId         *int32                 `json:"primaryTeamId,omitempty"`
	SortOrder             *int32                 `json:"sortOrder,omitempty"`
}

// BroadcasterActiveStatusEnum defines model for BroadcasterActiveStatusEnum.
type BroadcasterActiveStatusEnum string

// BroadcasterRestObject defines model for BroadcasterRestObject.
type BroadcasterRestObject struct {
	ActiveStatus     *bool                            `json:"activeStatus,omitempty"`
	Availability     *BroadcastAvailabilityRestObject `json:"availability,omitempty"`
	CallSign         *string                          `json:"callSign,omitempty"`
	Copyright        *string                          `json:"copyright,omitempty"`
	Id               *int32                           `json:"id,omitempty"`
	IsNational       *bool                            `json:"isNational,omitempty"`
	Language         *string                          `json:"language,omitempty"`
	MvpdAuthRequired *bool                            `json:"mvpdAuthRequired,omitempty"`
	Name             *string                          `json:"name,omitempty"`
	SourceComment    *string                          `json:"sourceComment,omitempty"`
	TeamId           *int32                           `json:"teamId,omitempty"`
	Type             *string                          `json:"type,omitempty"`
}

// BroadcasterXrefId defines model for BroadcasterXrefId.
type BroadcasterXrefId struct {
	BroadcasterId *int32  `json:"broadcasterId,omitempty"`
	Season        *string `json:"season,omitempty"`
	XrefId        *string `json:"xrefId,omitempty"`
	XrefIdTwo     *string `json:"xrefIdTwo,omitempty"`
	XrefType      *string `json:"xrefType,omitempty"`
}

// CalculatedMetricContainerRestObject defines model for CalculatedMetricContainerRestObject.
type CalculatedMetricContainerRestObject struct {
	Copyright      *string                       `json:"copyright,omitempty"`
	InvalidMetrics *[]CalculatedMetricRestObject `json:"invalidMetrics,omitempty"`
	Metrics        *[]CalculatedMetricRestObject `json:"metrics,omitempty"`
	Warnings       *[]MetricWarningRestObject    `json:"warnings,omitempty"`
}

// CalculatedMetricRestObject defines model for CalculatedMetricRestObject.
type CalculatedMetricRestObject struct {
	AdditionalFields          *JsonNode `json:"additionalFields,omitempty"`
	AverageValue              *float64  `json:"averageValue,omitempty"`
	Base                      *string   `json:"base,omitempty"`
	CompetitiveValue          *float64  `json:"competitiveValue,omitempty"`
	Copyright                 *string   `json:"copyright,omitempty"`
	Description               *string   `json:"description,omitempty"`
	Estimated                 *bool     `json:"estimated,omitempty"`
	Group                     *string   `json:"group,omitempty"`
	IsEstimated               *bool     `json:"isEstimated,omitempty"`
	IsHeldOn                  *bool     `json:"isHeldOn,omitempty"`
	IsRadarTracked            *bool     `json:"isRadarTracked,omitempty"`
	MaxValue                  *float64  `json:"maxValue,omitempty"`
	MetricId                  *int32    `json:"metricId,omitempty"`
	MinValue                  *float64  `json:"minValue,omitempty"`
	Name                      *string   `json:"name,omitempty"`
	NumCompetitiveOccurrences *int32    `json:"numCompetitiveOccurrences,omitempty"`
	NumOccurrences            *int32    `json:"numOccurrences,omitempty"`
	Percentile50Value         *float64  `json:"percentile50Value,omitempty"`
	Percentile75Value         *float64  `json:"percentile75Value,omitempty"`
	Percentile90Value         *float64  `json:"percentile90Value,omitempty"`
	PlayId                    *string   `json:"playId,omitempty"`
	PlayerId                  *int32    `json:"playerId,omitempty"`
	PositionId                *int32    `json:"positionId,omitempty"`
	Rank                      *int32    `json:"rank,omitempty"`
	SupportLevel              *string   `json:"supportLevel,omitempty"`
	TimeCode                  *int64    `json:"timeCode,omitempty"`
	Unit                      *string   `json:"unit,omitempty"`
	Value                     *JsonNode `json:"value,omitempty"`
	ValueUnrounded            *string   `json:"valueUnrounded,omitempty"`
}

// CalendarTypes defines model for CalendarTypes.
type CalendarTypes string

// CalibrationContainerRestObject defines model for CalibrationContainerRestObject.
type CalibrationContainerRestObject struct {
	Copyright *string                `json:"copyright,omitempty"`
	Optical   *CalibrationRestObject `json:"optical,omitempty"`
	Radar     *CalibrationRestObject `json:"radar,omitempty"`
}

// CalibrationRestObject defines model for CalibrationRestObject.
type CalibrationRestObject struct {
	CalibrationId   *string    `json:"calibrationId,omitempty"`
	CalibrationTime *time.Time `json:"calibrationTime,omitempty"`
	Copyright       *string    `json:"copyright,omitempty"`
}

// CalmDeviation Weather deviation data in calm conditions. `distance`: Calculated deviation in distance of the standard 80-ft-apex flyball hit in calm conditions. `horizontal`: Calculated deviation in horizontal distance of the standard 80-ft-apex flyball hit in calm conditions. A negative deviation means the ball ended up more towards left field.
type CalmDeviation struct {
	Apex       *float64 `json:"apex,omitempty"`
	Copyright  *string  `json:"copyright,omitempty"`
	Distance   *float64 `json:"distance,omitempty"`
	Height     *float64 `json:"height,omitempty"`
	Horizontal *float64 `json:"horizontal,omitempty"`
	Time       *float64 `json:"time,omitempty"`
}

// Conference defines model for Conference.
type Conference struct {
	Id   *int32  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// ConferenceRestObject defines model for ConferenceRestObject.
type ConferenceRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
	Id        *int32  `json:"id,omitempty"`
	Link      *string `json:"link,omitempty"`
	Name      *string `json:"name,omitempty"`
}

// ConferencesRestObject defines model for ConferencesRestObject.
type ConferencesRestObject struct {
	Conferences *[]ConferenceRestObject `json:"conferences,omitempty"`
	Copyright   *string                 `json:"copyright,omitempty"`
}

// ContactPointPositionRestObject Location of impact point.
type ContactPointPositionRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
	TimeStamp *string `json:"timeStamp,omitempty"`

	// X Location in the horizontal dimension, negative toward third base, positive toward first base.
	X *float64 `json:"x,omitempty"`

	// Y Location in the depth dimension, negative toward the backstop, positive toward pitchers mound.
	Y *float64 `json:"y,omitempty"`

	// Z Location in the vertical dimension, from the ground upward.
	Z *float64 `json:"z,omitempty"`
}

// ContentSummary defines model for ContentSummary.
type ContentSummary struct {
	FeaturedMedia      *FeaturedMedia `json:"featuredMedia,omitempty"`
	HasHighlightsVideo *bool          `json:"hasHighlightsVideo,omitempty"`
	HasPreviewArticle  *bool          `json:"hasPreviewArticle,omitempty"`
	HasRecapArticle    *bool          `json:"hasRecapArticle,omitempty"`
	HasWrapArticle     *bool          `json:"hasWrapArticle,omitempty"`
}

// Coordinate defines model for Coordinate.
type Coordinate struct {
	X *float64 `json:"x,omitempty"`
	Y *float64 `json:"y,omitempty"`
}

// CoordinateRestObject defines model for CoordinateRestObject.
type CoordinateRestObject struct {
	Coordinates *[]string `json:"coordinates,omitempty"`
	Copyright   *string   `json:"copyright,omitempty"`
	Label       *string   `json:"label,omitempty"`
	Latitude    *float64  `json:"latitude,omitempty"`
	Longitude   *float64  `json:"longitude,omitempty"`
	Type        *string   `json:"type,omitempty"`
}

// Coordinates defines model for Coordinates.
type Coordinates struct {
	X *float64 `json:"x,omitempty"`
	Y *float64 `json:"y,omitempty"`
	Z *float64 `json:"z,omitempty"`
}

// CoordinatesRestObject defines model for CoordinatesRestObject.
type CoordinatesRestObject struct {
	Copyright *string `json:"copyright,omitempty"`

	// X Represents the horizontal dimension, negative toward third base, positive toward first base.
	X *float64 `json:"x,omitempty"`

	// Y Represents the depth dimension, negative toward the backstop, positive toward pitchers mound.
	Y *float64 `json:"y,omitempty"`

	// Z Represents the vertical dimension, from the ground upward.
	Z *float64 `json:"z,omitempty"`
}

// Count defines model for Count.
type Count struct {
	Balls       *int32  `json:"balls,omitempty"`
	Copyright   *string `json:"copyright,omitempty"`
	Inning      *int32  `json:"inning,omitempty"`
	IsTopInning *bool   `json:"isTopInning,omitempty"`
	Outs        *int32  `json:"outs,omitempty"`
	RunnerOn1b  *bool   `json:"runnerOn1b,omitempty"`
	RunnerOn2b  *bool   `json:"runnerOn2b,omitempty"`
	RunnerOn3b  *bool   `json:"runnerOn3b,omitempty"`
	Strikes     *int32  `json:"strikes,omitempty"`
}

// DepthChart defines model for DepthChart.
type DepthChart struct {
	Depth              *int32             `json:"depth,omitempty"`
	Position           *BaseballPosition  `json:"position,omitempty"`
	RequestingUserRole *Role              `json:"requestingUserRole,omitempty"`
	Status             *DynamicLookupEnum `json:"status,omitempty"`
	Team               *BaseballTeam      `json:"team,omitempty"`
	UserPrivileges     *[]Privilege       `json:"userPrivileges,omitempty"`
}

// DepthChartRestObject defines model for DepthChartRestObject.
type DepthChartRestObject struct {
	Depth *int32 `json:"depth,omitempty"`

	// Position The x-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The y-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The z-coordinate of the landing position for the ball's trajectory. This will always be z=0 by definition.
	Position *PositionRestObject     `json:"position,omitempty"`
	Status   *DynamicEnumRestObject  `json:"status,omitempty"`
	Team     *BaseballTeamRestObject `json:"team,omitempty"`
}

// Designation defines model for Designation.
type Designation struct {
	Designation *TeamDesignationEnum `json:"designation,omitempty"`
	Id          *int32               `json:"id,omitempty"`
}

// DesignationRestObject defines model for DesignationRestObject.
type DesignationRestObject struct {
	Copyright   *string `json:"copyright,omitempty"`
	Designation *string `json:"designation,omitempty"`
	Id          *int32  `json:"id,omitempty"`
}

// Details defines model for Details.
type Details struct {
	AwayScore        *int32                 `json:"awayScore,omitempty"`
	BallColor        *string                `json:"ballColor,omitempty"`
	BatSide          *DynamicEnumRestObject `json:"batSide,omitempty"`
	Call             *DynamicEnumRestObject `json:"call,omitempty"`
	Code             *string                `json:"code,omitempty"`
	Copyright        *string                `json:"copyright,omitempty"`
	Description      *string                `json:"description,omitempty"`
	DisengagementNum *int32                 `json:"disengagementNum,omitempty"`
	Event            *string                `json:"event,omitempty"`
	EventType        *string                `json:"eventType,omitempty"`
	FromCatcher      *bool                  `json:"fromCatcher,omitempty"`
	HasReview        *bool                  `json:"hasReview,omitempty"`
	HomeScore        *int32                 `json:"homeScore,omitempty"`
	IsAtBat          *bool                  `json:"isAtBat,omitempty"`
	IsBall           *bool                  `json:"isBall,omitempty"`
	IsBaseHit        *bool                  `json:"isBaseHit,omitempty"`
	IsInPlay         *bool                  `json:"isInPlay,omitempty"`

	// IsOut Does the play event include an out?
	IsOut             *bool                  `json:"isOut,omitempty"`
	IsPlateAppearance *bool                  `json:"isPlateAppearance,omitempty"`
	IsScoringPlay     *bool                  `json:"isScoringPlay,omitempty"`
	IsStrike          *bool                  `json:"isStrike,omitempty"`
	PitchHand         *DynamicEnumRestObject `json:"pitchHand,omitempty"`
	RunnerGoing       *bool                  `json:"runnerGoing,omitempty"`
	TrailColor        *string                `json:"trailColor,omitempty"`
	Type              *DynamicEnumRestObject `json:"type,omitempty"`
	Violation         *ViolationRestObject   `json:"violation,omitempty"`
}

// Division defines model for Division.
type Division struct {
	Abbreviation        *string                            `json:"abbreviation,omitempty"`
	Active              *bool                              `json:"active,omitempty"`
	Conference          *Conference                        `json:"conference,omitempty"`
	ConferenceId        *int32                             `json:"conferenceId,omitempty"`
	HasWildcard         *bool                              `json:"hasWildcard,omitempty"`
	HydratedConferences *map[string]map[string]interface{} `json:"hydratedConferences,omitempty"`
	HydratedLeagues     *map[string]map[string]interface{} `json:"hydratedLeagues,omitempty"`
	Id                  *int32                             `json:"id,omitempty"`
	League              *League                            `json:"league,omitempty"`
	Name                *string                            `json:"name,omitempty"`
	NameShort           *string                            `json:"nameShort,omitempty"`
	NumPlayoffTeams     *int32                             `json:"numPlayoffTeams,omitempty"`
	RequestingUserRole  *Role                              `json:"requestingUserRole,omitempty"`
	Season              *string                            `json:"season,omitempty"`
	SortOrder           *int32                             `json:"sortOrder,omitempty"`
	Sport               *Sport                             `json:"sport,omitempty"`
	SportCode           *string                            `json:"sportCode,omitempty"`
	UserPrivileges      *[]Privilege                       `json:"userPrivileges,omitempty"`
}

// DivisionRestObject defines model for DivisionRestObject.
type DivisionRestObject struct {
	Abbreviation    *string               `json:"abbreviation,omitempty"`
	Active          *bool                 `json:"active,omitempty"`
	Conference      *ConferenceRestObject `json:"conference,omitempty"`
	Copyright       *string               `json:"copyright,omitempty"`
	HasWildcard     *bool                 `json:"hasWildcard,omitempty"`
	Id              *int32                `json:"id,omitempty"`
	League          *LeagueRestObject     `json:"league,omitempty"`
	Link            *string               `json:"link,omitempty"`
	Name            *string               `json:"name,omitempty"`
	NameShort       *string               `json:"nameShort,omitempty"`
	NumPlayoffTeams *int32                `json:"numPlayoffTeams,omitempty"`
	Season          *string               `json:"season,omitempty"`
	SortOrder       *int32                `json:"sortOrder,omitempty"`
	Sport           *SportRestObject      `json:"sport,omitempty"`
}

// DivisionsRestObject defines model for DivisionsRestObject.
type DivisionsRestObject struct {
	Copyright *string               `json:"copyright,omitempty"`
	Divisions *[]DivisionRestObject `json:"divisions,omitempty"`
}

// DraftStatusEnum defines model for DraftStatusEnum.
type DraftStatusEnum string

// DraftTypeEnum defines model for DraftTypeEnum.
type DraftTypeEnum string

// DraftTypeEnumRestObject defines model for DraftTypeEnumRestObject.
type DraftTypeEnumRestObject struct {
	Code        *string `json:"code,omitempty"`
	Copyright   *string `json:"copyright,omitempty"`
	Description *string `json:"description,omitempty"`
}

// Duration defines model for Duration.
type Duration struct {
	Millis          *int64 `json:"millis,omitempty"`
	StandardDays    *int64 `json:"standardDays,omitempty"`
	StandardHours   *int64 `json:"standardHours,omitempty"`
	StandardMinutes *int64 `json:"standardMinutes,omitempty"`
	StandardSeconds *int64 `json:"standardSeconds,omitempty"`
}

// DynamicEnumRestObject defines model for DynamicEnumRestObject.
type DynamicEnumRestObject struct {
	Code        *string `json:"code,omitempty"`
	Copyright   *string `json:"copyright,omitempty"`
	Description *string `json:"description,omitempty"`
	SortOrder   *int32  `json:"sortOrder,omitempty"`
}

// DynamicLookupEnum defines model for DynamicLookupEnum.
type DynamicLookupEnum struct {
	Description *string `json:"description,omitempty"`
	LookupKey   *string `json:"lookupKey,omitempty"`
	LookupType  *string `json:"lookupType,omitempty"`
	SortOrder   *int32  `json:"sortOrder,omitempty"`
}

// Editorial defines model for Editorial.
type Editorial struct {
	Articles  *JsonNode `json:"articles,omitempty"`
	Preview   *JsonNode `json:"preview,omitempty"`
	Probables *JsonNode `json:"probables,omitempty"`
	Recap     *JsonNode `json:"recap,omitempty"`
	Wrap      *JsonNode `json:"wrap,omitempty"`
}

// EducationInfo defines model for EducationInfo.
type EducationInfo struct {
	Colleges    *[]School `json:"colleges,omitempty"`
	Highschools *[]School `json:"highschools,omitempty"`
}

// EducationRestObject defines model for EducationRestObject.
type EducationRestObject struct {
	Colleges    *[]SchoolRestObject `json:"colleges,omitempty"`
	Copyright   *string             `json:"copyright,omitempty"`
	Highschools *[]SchoolRestObject `json:"highschools,omitempty"`
}

// EventSequenceRestObject defines model for EventSequenceRestObject.
type EventSequenceRestObject struct {
	Copyright  *string `json:"copyright,omitempty"`
	EventGroup *string `json:"eventGroup,omitempty"`
	EventType  *string `json:"eventType,omitempty"`
}

// EventStatus defines model for EventStatus.
type EventStatus struct {
	AbstractGameState *string `json:"abstractGameState,omitempty"`
	Code              *string `json:"code,omitempty"`
	DetailedState     *string `json:"detailedState,omitempty"`
	StartTimeTBD      *bool   `json:"startTimeTBD,omitempty"`
}

// EventType defines model for EventType.
type EventType string

// ExpandEnum defines model for ExpandEnum.
type ExpandEnum string

// FeaturedMedia defines model for FeaturedMedia.
type FeaturedMedia struct {
	Id *string `json:"id,omitempty"`
}

// FieldInfo defines model for FieldInfo.
type FieldInfo struct {
	Capacity    *int32  `json:"capacity,omitempty"`
	Center      *int32  `json:"center,omitempty"`
	Left        *int32  `json:"left,omitempty"`
	LeftCenter  *int32  `json:"leftCenter,omitempty"`
	LeftLine    *int32  `json:"leftLine,omitempty"`
	Right       *int32  `json:"right,omitempty"`
	RightCenter *int32  `json:"rightCenter,omitempty"`
	RightLine   *int32  `json:"rightLine,omitempty"`
	RoofType    *string `json:"roofType,omitempty"`
	TurfType    *string `json:"turfType,omitempty"`
}

// FieldInfoRestObject defines model for FieldInfoRestObject.
type FieldInfoRestObject struct {
	Capacity    *int32  `json:"capacity,omitempty"`
	Center      *int32  `json:"center,omitempty"`
	Copyright   *string `json:"copyright,omitempty"`
	Left        *int32  `json:"left,omitempty"`
	LeftCenter  *int32  `json:"leftCenter,omitempty"`
	LeftLine    *int32  `json:"leftLine,omitempty"`
	Right       *int32  `json:"right,omitempty"`
	RightCenter *int32  `json:"rightCenter,omitempty"`
	RightLine   *int32  `json:"rightLine,omitempty"`
	RoofType    *string `json:"roofType,omitempty"`
	TurfType    *string `json:"turfType,omitempty"`
}

// FieldZoneRestObject defines model for FieldZoneRestObject.
type FieldZoneRestObject struct {
	// Calm Weather deviation data in calm conditions. `distance`: Calculated deviation in distance of the standard 80-ft-apex flyball hit in calm conditions. `horizontal`: Calculated deviation in horizontal distance of the standard 80-ft-apex flyball hit in calm conditions. A negative deviation means the ball ended up more towards left field.
	Calm      *CalmDeviation           `json:"calm,omitempty"`
	Copyright *string                  `json:"copyright,omitempty"`
	FieldZone *FieldZoneTypeRestObject `json:"fieldZone,omitempty"`

	// Indoor Weather deviation data in indoor conditions. `distance`: Calculated deviation in distance of the standard 80-ft-apex flyball hit in indoor conditions. `horizontal`: Calculated deviation in horizontal distance of the standard 80-ft-apex flyball hit in indoor conditions. A negative deviation means the ball ended up more towards left field.
	Indoor *IndoorDeviation `json:"indoor,omitempty"`
}

// FieldZoneTypeRestObject defines model for FieldZoneTypeRestObject.
type FieldZoneTypeRestObject struct {
	Code        *string `json:"code,omitempty"`
	Copyright   *string `json:"copyright,omitempty"`
	Description *string `json:"description,omitempty"`
}

// FielderDetailType defines model for FielderDetailType.
type FielderDetailType string

// FieldingData defines model for FieldingData.
type FieldingData struct {
	AirOuts                      *int32             `json:"airOuts,omitempty"`
	Assists                      *int32             `json:"assists,omitempty"`
	AtBats                       *int32             `json:"atBats,omitempty"`
	Average                      *string            `json:"average,omitempty"`
	BallsInPlay                  *int32             `json:"ballsInPlay,omitempty"`
	BattingOrder                 *string            `json:"battingOrder,omitempty"`
	CatcherERA                   *string            `json:"catcherERA,omitempty"`
	CatchersInterference         *int32             `json:"catchersInterference,omitempty"`
	CaughtStealing               *int32             `json:"caughtStealing,omitempty"`
	Chances                      *int32             `json:"chances,omitempty"`
	DoublePlays                  *int32             `json:"doublePlays,omitempty"`
	Doubles                      *int32             `json:"doubles,omitempty"`
	Errors                       *int32             `json:"errors,omitempty"`
	FieldingPercentage           *string            `json:"fieldingPercentage,omitempty"`
	FlyHits                      *int32             `json:"flyHits,omitempty"`
	FlyOuts                      *int32             `json:"flyOuts,omitempty"`
	Games                        *int32             `json:"games,omitempty"`
	GamesPlayedOnBothTeams       *int32             `json:"gamesPlayedOnBothTeams,omitempty"`
	GamesStarted                 *int32             `json:"gamesStarted,omitempty"`
	Gidp                         *int32             `json:"gidp,omitempty"`
	GidpOpportunites             *int32             `json:"gidpOpportunites,omitempty"`
	Gitp                         *int32             `json:"gitp,omitempty"`
	GoAo                         *string            `json:"goAo,omitempty"`
	GroundHits                   *int32             `json:"groundHits,omitempty"`
	GroundOuts                   *int32             `json:"groundOuts,omitempty"`
	HitByPitch                   *int32             `json:"hitByPitch,omitempty"`
	Hits                         *int32             `json:"hits,omitempty"`
	HomeRuns                     *int32             `json:"homeRuns,omitempty"`
	Innings                      *string            `json:"innings,omitempty"`
	IntentionalWalks             *int32             `json:"intentionalWalks,omitempty"`
	LineHits                     *int32             `json:"lineHits,omitempty"`
	LineOuts                     *int32             `json:"lineOuts,omitempty"`
	Note                         *string            `json:"note,omitempty"`
	NumberOfPitches              *int32             `json:"numberOfPitches,omitempty"`
	OnBasePercentage             *string            `json:"onBasePercentage,omitempty"`
	OnBasePlusSlugging           *string            `json:"onBasePlusSlugging,omitempty"`
	OutfieldAssists              *int32             `json:"outfieldAssists,omitempty"`
	Outs                         *int32             `json:"outs,omitempty"`
	PassedBall                   *int32             `json:"passedBall,omitempty"`
	Pickoffs                     *int32             `json:"pickoffs,omitempty"`
	PitchesPerPlateAppearance    *float64           `json:"pitchesPerPlateAppearance,omitempty"`
	PitchesPerPlateAppearanceStr *string            `json:"pitchesPerPlateAppearanceStr,omitempty"`
	PlateAppearances             *int32             `json:"plateAppearances,omitempty"`
	PopHits                      *int32             `json:"popHits,omitempty"`
	PopOuts                      *int32             `json:"popOuts,omitempty"`
	Position                     *BaseballPosition  `json:"position,omitempty"`
	Putouts                      *int32             `json:"putouts,omitempty"`
	RangeFactorPer9Inn           *string            `json:"rangeFactorPer9Inn,omitempty"`
	RangeFactorPerGame           *string            `json:"rangeFactorPerGame,omitempty"`
	RequestingUserRole           *Role              `json:"requestingUserRole,omitempty"`
	Runs                         *int32             `json:"runs,omitempty"`
	SacBunts                     *int32             `json:"sacBunts,omitempty"`
	SacFlies                     *int32             `json:"sacFlies,omitempty"`
	Singles                      *int32             `json:"singles,omitempty"`
	Slugging                     *string            `json:"slugging,omitempty"`
	StolenBasePercentage         *string            `json:"stolenBasePercentage,omitempty"`
	StolenBasePercentageOrNull   *string            `json:"stolenBasePercentageOrNull,omitempty"`
	StolenBases                  *int32             `json:"stolenBases,omitempty"`
	Streak                       *int32             `json:"streak,omitempty"`
	Strikeouts                   *int32             `json:"strikeouts,omitempty"`
	Summary                      *map[string]string `json:"summary,omitempty"`
	SwingsAndMisses              *int32             `json:"swingsAndMisses,omitempty"`
	ThrowingErrors               *int32             `json:"throwingErrors,omitempty"`
	TotalBases                   *int32             `json:"totalBases,omitempty"`
	TotalSwings                  *int32             `json:"totalSwings,omitempty"`
	TriplePlays                  *int32             `json:"triplePlays,omitempty"`
	Triples                      *int32             `json:"triples,omitempty"`
	UserPrivileges               *[]Privilege       `json:"userPrivileges,omitempty"`
	Uzr                          *float64           `json:"uzr,omitempty"`
	Walks                        *int32             `json:"walks,omitempty"`
	WildPitches                  *int32             `json:"wildPitches,omitempty"`
}

// FilterLevelEnum defines model for FilterLevelEnum.
type FilterLevelEnum string

// FilterLevelEnumRestObject defines model for FilterLevelEnumRestObject.
type FilterLevelEnumRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
	Name      *string `json:"name,omitempty"`
	Scope     *int32  `json:"scope,omitempty"`
}

// FilterLevels defines model for FilterLevels.
type FilterLevels struct {
	AtBat     *bool   `json:"atBat,omitempty"`
	Career    *bool   `json:"career,omitempty"`
	Copyright *string `json:"copyright,omitempty"`
	Game      *bool   `json:"game,omitempty"`
	Inning    *bool   `json:"inning,omitempty"`
	Pitch     *bool   `json:"pitch,omitempty"`
	Season    *bool   `json:"season,omitempty"`
}

// ForecastWeatherWrapperRestObject defines model for ForecastWeatherWrapperRestObject.
type ForecastWeatherWrapperRestObject struct {
	Copyright *string                    `json:"copyright,omitempty"`
	Data      *WeatherForecastRestObject `json:"data,omitempty"`
	Units     *JsonNode                  `json:"units,omitempty"`
}

// FrameRestObject defines model for FrameRestObject.
type FrameRestObject struct {
	Copyright *string               `json:"copyright,omitempty"`
	Positions *[]PositionRestObject `json:"positions,omitempty"`
	TimeStamp *string               `json:"timeStamp,omitempty"`
}

// Franchise defines model for Franchise.
type Franchise struct {
	FirstSeasonId      *int32                             `json:"firstSeasonId,omitempty"`
	FranchiseId        *int32                             `json:"franchiseId,omitempty"`
	HydratedRosters    *map[string]map[string]interface{} `json:"hydratedRosters,omitempty"`
	LastSeasonId       *int32                             `json:"lastSeasonId,omitempty"`
	LocationName       *string                            `json:"locationName,omitempty"`
	MostRecentTeamId   *int32                             `json:"mostRecentTeamId,omitempty"`
	RequestingUserRole *Role                              `json:"requestingUserRole,omitempty"`
	Roster             *BaseballRoster                    `json:"roster,omitempty"`
	TeamIds            *[]int32                           `json:"teamIds,omitempty"`
	TeamName           *string                            `json:"teamName,omitempty"`
	UserPrivileges     *[]Privilege                       `json:"userPrivileges,omitempty"`
}

// FranchiseRestObject defines model for FranchiseRestObject.
type FranchiseRestObject struct {
	Copyright        *string           `json:"copyright,omitempty"`
	FirstSeasonId    *int32            `json:"firstSeasonId,omitempty"`
	FranchiseId      *int32            `json:"franchiseId,omitempty"`
	LastSeasonId     *int32            `json:"lastSeasonId,omitempty"`
	Link             *string           `json:"link,omitempty"`
	LocationName     *string           `json:"locationName,omitempty"`
	MostRecentTeamId *int32            `json:"mostRecentTeamId,omitempty"`
	Roster           *RosterRestObject `json:"roster,omitempty"`
	TeamName         *string           `json:"teamName,omitempty"`
}

// FreeAgentListRestObject defines model for FreeAgentListRestObject.
type FreeAgentListRestObject struct {
	Copyright  *string                `json:"copyright,omitempty"`
	FreeAgents *[]FreeAgentRestObject `json:"freeAgents,omitempty"`
	Hydrations *[]string              `json:"hydrations,omitempty"`
	Season     *string                `json:"season,omitempty"`
}

// FreeAgentRestObject defines model for FreeAgentRestObject.
type FreeAgentRestObject struct {
	DateDeclared *openapi_types.Date       `json:"dateDeclared,omitempty"`
	DateSigned   *openapi_types.Date       `json:"dateSigned,omitempty"`
	NewTeam      *BaseballTeamRestObject   `json:"newTeam,omitempty"`
	Notes        *string                   `json:"notes,omitempty"`
	OriginalTeam *BaseballTeamRestObject   `json:"originalTeam,omitempty"`
	Player       *BaseballPersonRestObject `json:"player,omitempty"`

	// Position The x-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The y-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The z-coordinate of the landing position for the ball's trajectory. This will always be z=0 by definition.
	Position  *PositionRestObject `json:"position,omitempty"`
	SortOrder *int32              `json:"sortOrder,omitempty"`
	Url       *string             `json:"url,omitempty"`
}

// FreeGameType defines model for FreeGameType.
type FreeGameType struct {
	FreeGameTypeEnum *FreeGameTypeEnum `json:"freeGameTypeEnum,omitempty"`
	OnStatus         *bool             `json:"onStatus,omitempty"`
}

// FreeGameTypeEnum defines model for FreeGameTypeEnum.
type FreeGameTypeEnum string

// FreeGameTypeRestObject defines model for FreeGameTypeRestObject.
type FreeGameTypeRestObject struct {
	Copyright        *string `json:"copyright,omitempty"`
	FreeGameTypeCode *string `json:"freeGameTypeCode,omitempty"`
	FreeGameTypeDesc *string `json:"freeGameTypeDesc,omitempty"`
	FreeGameTypeId   *int32  `json:"freeGameTypeId,omitempty"`
	FreeGameTypeText *string `json:"freeGameTypeText,omitempty"`
}

// FreeGameValueRestObject defines model for FreeGameValueRestObject.
type FreeGameValueRestObject struct {
	Copyright    *string                 `json:"copyright,omitempty"`
	FreeGameType *FreeGameTypeRestObject `json:"freeGameType,omitempty"`
	Status       *bool                   `json:"status,omitempty"`
}

// FullWeatherRestObject defines model for FullWeatherRestObject.
type FullWeatherRestObject struct {
	Conditions *WeatherConditionsRestObject `json:"conditions,omitempty"`
	Context    *WeatherContextRestObject    `json:"context,omitempty"`
	Copyright  *string                      `json:"copyright,omitempty"`
	Deviations *WeatherDeviationsRestObject `json:"deviations,omitempty"`
}

// FullWeatherWrapperRestObject defines model for FullWeatherWrapperRestObject.
type FullWeatherWrapperRestObject struct {
	Copyright *string                `json:"copyright,omitempty"`
	Data      *FullWeatherRestObject `json:"data,omitempty"`
	Units     *JsonNode              `json:"units,omitempty"`
}

// GameCms defines model for GameCms.
type GameCms struct {
	ContentSummary *ContentSummary `json:"contentSummary,omitempty"`
	Editorial      *Editorial      `json:"editorial,omitempty"`
	GameNotes      *GameNotes      `json:"gameNotes,omitempty"`
	Highlights     *Highlights     `json:"highlights,omitempty"`
	Lineup         *Lineup         `json:"lineup,omitempty"`
	Media          *Media          `json:"media,omitempty"`
}

// GameContentRestObject defines model for GameContentRestObject.
type GameContentRestObject struct {
	Copyright  *string                       `json:"copyright,omitempty"`
	Editorial  *GameEditorialRestObject      `json:"editorial,omitempty"`
	GameNotes  *GameNotesRestObject          `json:"gameNotes,omitempty"`
	Highlights *GameHighlightsRestObject     `json:"highlights,omitempty"`
	Link       *string                       `json:"link,omitempty"`
	Media      *GameMediaRestObject          `json:"media,omitempty"`
	Summary    *GameContentSummaryRestObject `json:"summary,omitempty"`
}

// GameContentSummaryRestObject defines model for GameContentSummaryRestObject.
type GameContentSummaryRestObject struct {
	Copyright          *string `json:"copyright,omitempty"`
	HasHighlightsVideo *bool   `json:"hasHighlightsVideo,omitempty"`
	HasPreviewArticle  *bool   `json:"hasPreviewArticle,omitempty"`
	HasRecapArticle    *bool   `json:"hasRecapArticle,omitempty"`
	HasWrapArticle     *bool   `json:"hasWrapArticle,omitempty"`
}

// GameDateBroadcast defines model for GameDateBroadcast.
type GameDateBroadcast struct {
	BroadcastAvailability       *BroadcastAvailability `json:"broadcastAvailability,omitempty"`
	BroadcastComment            *string                `json:"broadcastComment,omitempty"`
	BroadcastDate               *openapi_types.Date    `json:"broadcastDate,omitempty"`
	BroadcastUrl                *string                `json:"broadcastUrl,omitempty"`
	Broadcaster                 *Broadcaster           `json:"broadcaster,omitempty"`
	FreeGameOverallStatus       *bool                  `json:"freeGameOverallStatus,omitempty"`
	FreeGameStatus              *bool                  `json:"freeGameStatus,omitempty"`
	FreeGameTypes               *[]FreeGameType        `json:"freeGameTypes,omitempty"`
	GameDateBroadcastGuid       *openapi_types.UUID    `json:"gameDateBroadcastGuid,omitempty"`
	GamePk                      *int32                 `json:"gamePk,omitempty"`
	HomeAway                    *TeamDesignationEnum   `json:"homeAway,omitempty"`
	IsNationalStatus            *bool                  `json:"isNationalStatus,omitempty"`
	Language                    *Language              `json:"language,omitempty"`
	MediaState                  *MediaState            `json:"mediaState,omitempty"`
	MvpdAuthBroadcastStatus     *bool                  `json:"mvpdAuthBroadcastStatus,omitempty"`
	PostgameShowStatus          *bool                  `json:"postgameShowStatus,omitempty"`
	PregameShowTs               *time.Time             `json:"pregameShowTs,omitempty"`
	Site                        *Site                  `json:"site,omitempty"`
	SortOrder                   *int32                 `json:"sortOrder,omitempty"`
	StreamingAvailabilityStatus *bool                  `json:"streamingAvailabilityStatus,omitempty"`
	TeamId                      *int32                 `json:"teamId,omitempty"`
	VideoResolution             *VideoResolution       `json:"videoResolution,omitempty"`
	Xrefs                       *[]BroadcasterXrefId   `json:"xrefs,omitempty"`
}

// GameDateBroadcastRestObject defines model for GameDateBroadcastRestObject.
type GameDateBroadcastRestObject struct {
	Availability          *BroadcastAvailabilityRestObject `json:"availability,omitempty"`
	AvailableForStreaming *bool                            `json:"availableForStreaming,omitempty"`
	BroadcastDate         *openapi_types.Date              `json:"broadcastDate,omitempty"`
	CallSign              *string                          `json:"callSign,omitempty"`
	Copyright             *string                          `json:"copyright,omitempty"`
	FreeGame              *bool                            `json:"freeGame,omitempty"`
	FreeGameStatus        *bool                            `json:"freeGameStatus,omitempty"`
	FreeGameTypes         *[]FreeGameValueRestObject       `json:"freeGameTypes,omitempty"`
	GameDateBroadcastGuid *string                          `json:"gameDateBroadcastGuid,omitempty"`
	HomeAway              *string                          `json:"homeAway,omitempty"`
	Id                    *int32                           `json:"id,omitempty"`
	IsNational            *bool                            `json:"isNational,omitempty"`
	Language              *string                          `json:"language,omitempty"`
	MediaId               *string                          `json:"mediaId,omitempty"`
	MediaState            *MediaStateRestObject            `json:"mediaState,omitempty"`
	MvpdAuthRequired      *bool                            `json:"mvpdAuthRequired,omitempty"`
	Name                  *string                          `json:"name,omitempty"`
	PostGameShow          *bool                            `json:"postGameShow,omitempty"`
	PreGameShow           *time.Time                       `json:"preGameShow,omitempty"`
	Site                  *string                          `json:"site,omitempty"`
	SourceComment         *string                          `json:"sourceComment,omitempty"`
	SourceUrl             *string                          `json:"sourceUrl,omitempty"`
	Type                  *string                          `json:"type,omitempty"`
	VideoResolution       *VideoResolutionEnumRestObject   `json:"videoResolution,omitempty"`
	XrefIds               *[]XrefIdRestObject              `json:"xrefIds,omitempty"`
}

// GameEditorialRestObject defines model for GameEditorialRestObject.
type GameEditorialRestObject struct {
	Articles  *JsonNode `json:"articles,omitempty"`
	Copyright *string   `json:"copyright,omitempty"`
	Preview   *JsonNode `json:"preview,omitempty"`
	Recap     *JsonNode `json:"recap,omitempty"`
	Wrap      *JsonNode `json:"wrap,omitempty"`
}

// GameEventDetailTO defines model for GameEventDetailTO.
type GameEventDetailTO struct {
	Delta    *string `json:"delta,omitempty"`
	EventId  *int32  `json:"eventId,omitempty"`
	HomeAway *string `json:"homeAway,omitempty"`
	PlayerId *int32  `json:"playerId,omitempty"`
	StatName *string `json:"stat_name,omitempty"`
	TeamId   *int32  `json:"teamId,omitempty"`
}

// GameHighlightsRestObject defines model for GameHighlightsRestObject.
type GameHighlightsRestObject struct {
	Copyright         *string   `json:"copyright,omitempty"`
	GameCenter        *JsonNode `json:"gameCenter,omitempty"`
	Highlights        *JsonNode `json:"highlights,omitempty"`
	Live              *JsonNode `json:"live,omitempty"`
	Milestone         *JsonNode `json:"milestone,omitempty"`
	Scoreboard        *JsonNode `json:"scoreboard,omitempty"`
	ScoreboardPreview *JsonNode `json:"scoreboardPreview,omitempty"`
}

// GameInfoRestObject defines model for GameInfoRestObject.
type GameInfoRestObject struct {
	Attendance           *int32     `json:"attendance,omitempty"`
	Copyright            *string    `json:"copyright,omitempty"`
	DelayDurationMinutes *int32     `json:"delayDurationMinutes,omitempty"`
	FirstPitch           *time.Time `json:"firstPitch,omitempty"`
	GameDurationMinutes  *int32     `json:"gameDurationMinutes,omitempty"`
}

// GameMediaRestObject defines model for GameMediaRestObject.
type GameMediaRestObject struct {
	Copyright     *string   `json:"copyright,omitempty"`
	EnhancedGame  *bool     `json:"enhancedGame,omitempty"`
	Epg           *JsonNode `json:"epg,omitempty"`
	EpgAlternate  *JsonNode `json:"epgAlternate,omitempty"`
	FeaturedMedia *JsonNode `json:"featuredMedia,omitempty"`
	FreeGame      *bool     `json:"freeGame,omitempty"`
	Milestones    *JsonNode `json:"milestones,omitempty"`
	PreviewStory  *JsonNode `json:"previewStory,omitempty"`
}

// GameModeTO defines model for GameModeTO.
type GameModeTO struct {
	Id   *int32  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// GameNotes defines model for GameNotes.
type GameNotes struct {
	Notes *JsonNode `json:"notes,omitempty"`
}

// GameNotesRestObject defines model for GameNotesRestObject.
type GameNotesRestObject struct {
	Copyright *string   `json:"copyright,omitempty"`
	Notes     *JsonNode `json:"notes,omitempty"`
}

// GamePacePRPortalRestObject defines model for GamePacePRPortalRestObject.
type GamePacePRPortalRestObject struct {
	TimePer7InnGame     *Duration `json:"timePer7InnGame,omitempty"`
	TimePer9InnGame     *Duration `json:"timePer9InnGame,omitempty"`
	TimePerExtraInnGame *Duration `json:"timePerExtraInnGame,omitempty"`
	Total7InnGames      *int32    `json:"total7InnGames,omitempty"`
	Total9InnGames      *int32    `json:"total9InnGames,omitempty"`
	TotalExtraInnGames  *int32    `json:"totalExtraInnGames,omitempty"`
}

// GamePaceRestObject defines model for GamePaceRestObject.
type GamePaceRestObject struct {
	Copyright                      *string                     `json:"copyright,omitempty"`
	HitsPer9Inn                    *float64                    `json:"hitsPer9Inn,omitempty"`
	HitsPerGame                    *float64                    `json:"hitsPerGame,omitempty"`
	HitsPerRun                     *float64                    `json:"hitsPerRun,omitempty"`
	Hydrations                     *[]string                   `json:"hydrations,omitempty"`
	InningsPlayedPerGame           *float64                    `json:"inningsPlayedPerGame,omitempty"`
	League                         *LeagueRestObject           `json:"league,omitempty"`
	PitchersPerGame                *float64                    `json:"pitchersPerGame,omitempty"`
	PitchesPer9Inn                 *float64                    `json:"pitchesPer9Inn,omitempty"`
	PitchesPerGame                 *float64                    `json:"pitchesPerGame,omitempty"`
	PitchesPerPitcher              *float64                    `json:"pitchesPerPitcher,omitempty"`
	PlateAppearancesPer9Inn        *float64                    `json:"plateAppearancesPer9Inn,omitempty"`
	PlateAppearancesPerGame        *float64                    `json:"plateAppearancesPerGame,omitempty"`
	PrPortalCalculatedFields       *GamePacePRPortalRestObject `json:"prPortalCalculatedFields,omitempty"`
	RunsPer9Inn                    *float64                    `json:"runsPer9Inn,omitempty"`
	RunsPerGame                    *float64                    `json:"runsPerGame,omitempty"`
	Season                         *string                     `json:"season,omitempty"`
	Sport                          *SportRestObject            `json:"sport,omitempty"`
	Team                           *BaseballTeamRestObject     `json:"team,omitempty"`
	TimePer77PlateAppearances      *Duration                   `json:"timePer77PlateAppearances,omitempty"`
	TimePer7InnGame                *Duration                   `json:"timePer7InnGame,omitempty"`
	TimePer7InnGameWithoutExtraInn *Duration                   `json:"timePer7InnGameWithoutExtraInn,omitempty"`
	TimePer9Inn                    *Duration                   `json:"timePer9Inn,omitempty"`
	TimePerGame                    *Duration                   `json:"timePerGame,omitempty"`
	TimePerHit                     *Duration                   `json:"timePerHit,omitempty"`
	TimePerPitch                   *Duration                   `json:"timePerPitch,omitempty"`
	TimePerPlateAppearance         *Duration                   `json:"timePerPlateAppearance,omitempty"`
	TimePerRun                     *Duration                   `json:"timePerRun,omitempty"`
	Total7InnGames                 *int32                      `json:"total7InnGames,omitempty"`
	Total7InnGamesCompletedEarly   *int32                      `json:"total7InnGamesCompletedEarly,omitempty"`
	Total7InnGamesScheduled        *int32                      `json:"total7InnGamesScheduled,omitempty"`
	Total7InnGamesWithoutExtraInn  *int32                      `json:"total7InnGamesWithoutExtraInn,omitempty"`
	Total9InnGames                 *int32                      `json:"total9InnGames,omitempty"`
	Total9InnGamesCompletedEarly   *int32                      `json:"total9InnGamesCompletedEarly,omitempty"`
	Total9InnGamesScheduled        *int32                      `json:"total9InnGamesScheduled,omitempty"`
	Total9InnGamesWithoutExtraInn  *int32                      `json:"total9InnGamesWithoutExtraInn,omitempty"`
	TotalExtraInnGames             *int32                      `json:"totalExtraInnGames,omitempty"`
	TotalExtraInnTime              *Duration                   `json:"totalExtraInnTime,omitempty"`
	TotalGameTime                  *Duration                   `json:"totalGameTime,omitempty"`
	TotalGames                     *int32                      `json:"totalGames,omitempty"`
	TotalHits                      *int32                      `json:"totalHits,omitempty"`
	TotalInningsPlayed             *float64                    `json:"totalInningsPlayed,omitempty"`
	TotalPitchers                  *int32                      `json:"totalPitchers,omitempty"`
	TotalPitches                   *int32                      `json:"totalPitches,omitempty"`
	TotalPlateAppearances          *int32                      `json:"totalPlateAppearances,omitempty"`
	TotalRuns                      *int32                      `json:"totalRuns,omitempty"`
}

// GamePaceWrapperRestObject defines model for GamePaceWrapperRestObject.
type GamePaceWrapperRestObject struct {
	Copyright *string               `json:"copyright,omitempty"`
	Leagues   *[]GamePaceRestObject `json:"leagues,omitempty"`
	Sports    *[]GamePaceRestObject `json:"sports,omitempty"`
	Teams     *[]GamePaceRestObject `json:"teams,omitempty"`
}

// GameStatData defines model for GameStatData.
type GameStatData struct {
	AirOuts                      *int32             `json:"airOuts,omitempty"`
	Assists                      *int32             `json:"assists,omitempty"`
	AtBats                       *int32             `json:"atBats,omitempty"`
	Attendance                   *int32             `json:"attendance,omitempty"`
	Average                      *string            `json:"average,omitempty"`
	BallsInPlay                  *int32             `json:"ballsInPlay,omitempty"`
	BattingOrder                 *string            `json:"battingOrder,omitempty"`
	CatchersInterference         *int32             `json:"catchersInterference,omitempty"`
	CaughtStealing               *int32             `json:"caughtStealing,omitempty"`
	Chances                      *int32             `json:"chances,omitempty"`
	Doubles                      *int32             `json:"doubles,omitempty"`
	FlyHits                      *int32             `json:"flyHits,omitempty"`
	FlyOuts                      *int32             `json:"flyOuts,omitempty"`
	GameDuration                 *Duration          `json:"gameDuration,omitempty"`
	GameInnings                  *int32             `json:"gameInnings,omitempty"`
	Games                        *int32             `json:"games,omitempty"`
	GamesPlayedOnBothTeams       *int32             `json:"gamesPlayedOnBothTeams,omitempty"`
	GamesStarted                 *int32             `json:"gamesStarted,omitempty"`
	Gidp                         *int32             `json:"gidp,omitempty"`
	GidpOpportunites             *int32             `json:"gidpOpportunites,omitempty"`
	Gitp                         *int32             `json:"gitp,omitempty"`
	GoAo                         *string            `json:"goAo,omitempty"`
	GroundHits                   *int32             `json:"groundHits,omitempty"`
	GroundOuts                   *int32             `json:"groundOuts,omitempty"`
	HitByPitch                   *int32             `json:"hitByPitch,omitempty"`
	Hits                         *int32             `json:"hits,omitempty"`
	HomeRuns                     *int32             `json:"homeRuns,omitempty"`
	IntentionalWalks             *int32             `json:"intentionalWalks,omitempty"`
	LineHits                     *int32             `json:"lineHits,omitempty"`
	LineOuts                     *int32             `json:"lineOuts,omitempty"`
	Note                         *string            `json:"note,omitempty"`
	NumberOfPitches              *int32             `json:"numberOfPitches,omitempty"`
	OnBasePercentage             *string            `json:"onBasePercentage,omitempty"`
	OnBasePlusSlugging           *string            `json:"onBasePlusSlugging,omitempty"`
	Outs                         *int32             `json:"outs,omitempty"`
	Pickoffs                     *int32             `json:"pickoffs,omitempty"`
	PitchesPerPlateAppearance    *float64           `json:"pitchesPerPlateAppearance,omitempty"`
	PitchesPerPlateAppearanceStr *string            `json:"pitchesPerPlateAppearanceStr,omitempty"`
	PlateAppearances             *int32             `json:"plateAppearances,omitempty"`
	PopHits                      *int32             `json:"popHits,omitempty"`
	PopOuts                      *int32             `json:"popOuts,omitempty"`
	Putouts                      *int32             `json:"putouts,omitempty"`
	RequestingUserRole           *Role              `json:"requestingUserRole,omitempty"`
	Runs                         *int32             `json:"runs,omitempty"`
	SacBunts                     *int32             `json:"sacBunts,omitempty"`
	SacFlies                     *int32             `json:"sacFlies,omitempty"`
	Singles                      *int32             `json:"singles,omitempty"`
	Slugging                     *string            `json:"slugging,omitempty"`
	StolenBasePercentage         *string            `json:"stolenBasePercentage,omitempty"`
	StolenBasePercentageOrNull   *string            `json:"stolenBasePercentageOrNull,omitempty"`
	StolenBases                  *int32             `json:"stolenBases,omitempty"`
	Streak                       *int32             `json:"streak,omitempty"`
	Strikeouts                   *int32             `json:"strikeouts,omitempty"`
	Summary                      *map[string]string `json:"summary,omitempty"`
	SwingsAndMisses              *int32             `json:"swingsAndMisses,omitempty"`
	TotalBases                   *int32             `json:"totalBases,omitempty"`
	TotalSwings                  *int32             `json:"totalSwings,omitempty"`
	Triples                      *int32             `json:"triples,omitempty"`
	UserPrivileges               *[]Privilege       `json:"userPrivileges,omitempty"`
	Walks                        *int32             `json:"walks,omitempty"`
	WildPitches                  *int32             `json:"wildPitches,omitempty"`
}

// GameStatusRestObject defines model for GameStatusRestObject.
type GameStatusRestObject struct {
	Copyright        *string `json:"copyright,omitempty"`
	IsCurrentBatter  *bool   `json:"isCurrentBatter,omitempty"`
	IsCurrentPitcher *bool   `json:"isCurrentPitcher,omitempty"`
	IsOnBench        *bool   `json:"isOnBench,omitempty"`
	IsSubstitute     *bool   `json:"isSubstitute,omitempty"`
}

// GameStory defines model for GameStory.
type GameStory struct {
	GamePk            *int32     `json:"gamePk,omitempty"`
	LastUpdatedTime   *time.Time `json:"lastUpdatedTime,omitempty"`
	Link              *string    `json:"link,omitempty"`
	Name              *string    `json:"name,omitempty"`
	NumStories        *int32     `json:"numStories,omitempty"`
	Pages             *int32     `json:"pages,omitempty"`
	Status            *string    `json:"status,omitempty"`
	Thumbnail         *string    `json:"thumbnail,omitempty"`
	ThumbnailTemplate *string    `json:"thumbnailTemplate,omitempty"`
}

// GameStoryRestObject defines model for GameStoryRestObject.
type GameStoryRestObject struct {
	GamePk      *int32     `json:"gamePk,omitempty"`
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`
	Link        *string    `json:"link,omitempty"`
	Pages       *int32     `json:"pages,omitempty"`
}

// GameTO defines model for GameTO.
type GameTO struct {
	Attendance          *int32     `json:"attendance,omitempty"`
	AwayBlownSaves      *[]int32   `json:"awayBlownSaves,omitempty"`
	AwayHolds           *[]int32   `json:"awayHolds,omitempty"`
	DelayMinutes        *int32     `json:"delayMinutes,omitempty"`
	DelayReason         *string    `json:"delay_reason,omitempty"`
	FirstPitchTime      *string    `json:"firstPitchTime,omitempty"`
	FirstPitchTimeUTC   *time.Time `json:"firstPitchTimeUTC,omitempty"`
	GameMinutes         *int32     `json:"gameMinutes,omitempty"`
	GameStatusDetail    *string    `json:"gameStatusDetail,omitempty"`
	GamePk              *int32     `json:"game_pk,omitempty"`
	GameStatusInd       *string    `json:"game_status_ind,omitempty"`
	HomeBlownSaves      *[]int32   `json:"homeBlownSaves,omitempty"`
	HomeHolds           *[]int32   `json:"homeHolds,omitempty"`
	OfficialScorer      *int32     `json:"official_scorer,omitempty"`
	PrimaryDatacaster   *int32     `json:"primary_datacaster,omitempty"`
	SecondaryDatacaster *int32     `json:"secondary_datacaster,omitempty"`
	Sky                 *string    `json:"sky,omitempty"`
	Temperature         *string    `json:"temperature,omitempty"`
	TotalMinutes        *int32     `json:"totalMinutes,omitempty"`
	WindDirection       *string    `json:"wind_direction,omitempty"`
	WindSpeed           *string    `json:"wind_speed,omitempty"`
}

// GameTypeDates defines model for GameTypeDates.
type GameTypeDates struct {
	EndDate      *openapi_types.Date `json:"endDate,omitempty"`
	GameType     *GameTypeEnum       `json:"gameType,omitempty"`
	League       *League             `json:"league,omitempty"`
	Name         *string             `json:"name,omitempty"`
	PlayoffRound *int32              `json:"playoffRound,omitempty"`
	Playoffs     *bool               `json:"playoffs,omitempty"`
	RoundRobin   *bool               `json:"roundRobin,omitempty"`
	Season       *string             `json:"season,omitempty"`
	ShortName    *string             `json:"shortName,omitempty"`
	Sport        *Sport              `json:"sport,omitempty"`
	StartDate    *openapi_types.Date `json:"startDate,omitempty"`
}

// GameTypeDatesRestObject defines model for GameTypeDatesRestObject.
type GameTypeDatesRestObject struct {
	Copyright    *string             `json:"copyright,omitempty"`
	EndDate      *openapi_types.Date `json:"endDate,omitempty"`
	GameType     *GameTypeEnum       `json:"gameType,omitempty"`
	League       *LeagueRestObject   `json:"league,omitempty"`
	Name         *string             `json:"name,omitempty"`
	PlayoffRound *int32              `json:"playoffRound,omitempty"`
	Playoffs     *bool               `json:"playoffs,omitempty"`
	RoundRobin   *bool               `json:"roundRobin,omitempty"`
	Season       *string             `json:"season,omitempty"`
	ShortName    *string             `json:"shortName,omitempty"`
	Sport        *SportRestObject    `json:"sport,omitempty"`
	StartDate    *openapi_types.Date `json:"startDate,omitempty"`
}

// GameTypeEnum defines model for GameTypeEnum.
type GameTypeEnum string

// GeneralLookupRestObject defines model for GeneralLookupRestObject.
type GeneralLookupRestObject struct {
	Base        *GenericLookup `json:"base,omitempty"`
	Code        *string        `json:"code,omitempty"`
	Copyright   *string        `json:"copyright,omitempty"`
	Description *string        `json:"description,omitempty"`
}

// GenericLookup defines model for GenericLookup.
type GenericLookup string

// GroupByEnum defines model for GroupByEnum.
type GroupByEnum string

// GroupedStatData defines model for GroupedStatData.
type GroupedStatData struct {
	Advanced    *StatData        `json:"advanced,omitempty"`
	Catching    *GroupedStatData `json:"catching,omitempty"`
	Expected    *StatData        `json:"expected,omitempty"`
	Fielding    *GroupedStatData `json:"fielding,omitempty"`
	Hitting     *GroupedStatData `json:"hitting,omitempty"`
	Percentiles *GroupedStatData `json:"percentiles,omitempty"`
	Pitching    *GroupedStatData `json:"pitching,omitempty"`
	Projected   *StatData        `json:"projected,omitempty"`
	Rankings    *GroupedStatData `json:"rankings,omitempty"`
	Running     *GroupedStatData `json:"running,omitempty"`
	Standard    *StatData        `json:"standard,omitempty"`
	Tracking    *StatData        `json:"tracking,omitempty"`
}

// GroupedStatDataRestObject defines model for GroupedStatDataRestObject.
type GroupedStatDataRestObject struct {
	Advanced    *StatDataRestObject        `json:"advanced,omitempty"`
	Catching    *GroupedStatDataRestObject `json:"catching,omitempty"`
	Copyright   *string                    `json:"copyright,omitempty"`
	Expected    *StatDataRestObject        `json:"expected,omitempty"`
	Fielding    *GroupedStatDataRestObject `json:"fielding,omitempty"`
	Hitting     *GroupedStatDataRestObject `json:"hitting,omitempty"`
	Percentiles *GroupedStatDataRestObject `json:"percentiles,omitempty"`
	Pitching    *GroupedStatDataRestObject `json:"pitching,omitempty"`
	Projected   *StatDataRestObject        `json:"projected,omitempty"`
	Rankings    *GroupedStatDataRestObject `json:"rankings,omitempty"`
	Running     *GroupedStatDataRestObject `json:"running,omitempty"`
	Standard    *StatDataRestObject        `json:"standard,omitempty"`
	Tracking    *StatDataRestObject        `json:"tracking,omitempty"`
}

// HandlePositionRestObject Location of the handle of the bat during impact. The distance from head to handle is currently fixed at 32.677 inches.
type HandlePositionRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
	TimeStamp *string `json:"timeStamp,omitempty"`

	// X Location in the horizontal dimension, negative toward third base, positive toward first base.
	X *float64 `json:"x,omitempty"`

	// Y Location in the depth dimension, negative toward the backstop, positive toward pitchers mound.
	Y *float64 `json:"y,omitempty"`

	// Z Location in the vertical dimension, from the ground upward.
	Z *float64 `json:"z,omitempty"`
}

// HeadPositionRestObject Location of the head of the bat during impact.
type HeadPositionRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
	TimeStamp *string `json:"timeStamp,omitempty"`

	// X Location in the horizontal dimension, negative toward third base, positive toward first base.
	X *float64 `json:"x,omitempty"`

	// Y Location in the depth dimension, negative toward the backstop, positive toward pitchers mound.
	Y *float64 `json:"y,omitempty"`

	// Z Location in the vertical dimension, from the ground upward.
	Z *float64 `json:"z,omitempty"`
}

// HighLowContainerRestObject defines model for HighLowContainerRestObject.
type HighLowContainerRestObject struct {
	CombinedStats        *bool                              `json:"combinedStats,omitempty"`
	Copyright            *string                            `json:"copyright,omitempty"`
	Disclaimers          *[]string                          `json:"disclaimers,omitempty"`
	Exemptions           *[]StatExemptionRestObject         `json:"exemptions,omitempty"`
	GameType             *GameTypeEnum                      `json:"gameType,omitempty"`
	Group                *StatGroup                         `json:"group,omitempty"`
	Parameters           *map[string]map[string]interface{} `json:"parameters,omitempty"`
	Player               *BaseballPersonRestObject          `json:"player,omitempty"`
	PlayerPool           *PlayerPoolEnum                    `json:"playerPool,omitempty"`
	Season               *string                            `json:"season,omitempty"`
	SortStat             *BaseballStatsTypeRestObject       `json:"sortStat,omitempty"`
	Splits               *[]StatSplitsRestObject            `json:"splits,omitempty"`
	SplitsTiedWithLimit  *[]StatSplitsRestObject            `json:"splitsTiedWithLimit,omitempty"`
	SplitsTiedWithOffset *[]StatSplitsRestObject            `json:"splitsTiedWithOffset,omitempty"`
	Sport                *SportRestObject                   `json:"sport,omitempty"`
	Stats                *StatDataRestObject                `json:"stats,omitempty"`
	Team                 *BaseballTeamRestObject            `json:"team,omitempty"`
	TotalSplits          *int32                             `json:"totalSplits,omitempty"`
	Type                 *StatType                          `json:"type,omitempty"`
}

// HighLowStatEnum defines model for HighLowStatEnum.
type HighLowStatEnum string

// HighLowTypeEnum defines model for HighLowTypeEnum.
type HighLowTypeEnum string

// HighLowWrapperRestObject defines model for HighLowWrapperRestObject.
type HighLowWrapperRestObject struct {
	Copyright      *string                       `json:"copyright,omitempty"`
	HighLowResults *[]HighLowContainerRestObject `json:"highLowResults,omitempty"`
}

// Highlights defines model for Highlights.
type Highlights struct {
	GameCenter        *JsonNode `json:"gameCenter,omitempty"`
	Highlights        *JsonNode `json:"highlights,omitempty"`
	LiveHighlights    *JsonNode `json:"liveHighlights,omitempty"`
	Milestone         *JsonNode `json:"milestone,omitempty"`
	Scoreboard        *JsonNode `json:"scoreboard,omitempty"`
	ScoreboardPreview *JsonNode `json:"scoreboardPreview,omitempty"`
}

// HitSegmentRestObject defines model for HitSegmentRestObject.
type HitSegmentRestObject struct {
	Copyright         *string                      `json:"copyright,omitempty"`
	LandingData       *StartEndDataRestObject      `json:"landingData,omitempty"`
	LastMeasuredData  *StartEndDataRestObject      `json:"lastMeasuredData,omitempty"`
	LaunchData        *LaunchDataRestObject        `json:"launchData,omitempty"`
	ReducedConfidence *[]string                    `json:"reducedConfidence,omitempty"`
	TrajectoryData    *HitTrajectoryDataRestObject `json:"trajectoryData,omitempty"`
}

// HitTrajectory defines model for HitTrajectory.
type HitTrajectory string

// HitTrajectoryData defines model for HitTrajectoryData.
type HitTrajectoryData struct {
	HitPositionAt110Feet  *Coordinates `json:"hitPositionAt110Feet,omitempty"`
	MaxHeightPosition     *Coordinates `json:"maxHeightPosition,omitempty"`
	MeasuredTimeInterval  *[]float64   `json:"measuredTimeInterval,omitempty"`
	ReducedConfidence     *[]string    `json:"reducedConfidence,omitempty"`
	TrajectoryPolynomialX *[]float64   `json:"trajectoryPolynomialX,omitempty"`
	TrajectoryPolynomialY *[]float64   `json:"trajectoryPolynomialY,omitempty"`
	TrajectoryPolynomialZ *[]float64   `json:"trajectoryPolynomialZ,omitempty"`
	ValidTimeInterval     *[]float64   `json:"validTimeInterval,omitempty"`
}

// HitTrajectoryDataRestObject defines model for HitTrajectoryDataRestObject.
type HitTrajectoryDataRestObject struct {
	Copyright            *string                `json:"copyright,omitempty"`
	HitPositionAt110Feet *CoordinatesRestObject `json:"hitPositionAt110Feet,omitempty"`
	MaxHeightPosition    *CoordinatesRestObject `json:"maxHeightPosition,omitempty"`
	MeasuredTimeInterval *[]float64             `json:"measuredTimeInterval,omitempty"`
	ReducedConfidence    *[]string              `json:"reducedConfidence,omitempty"`

	// TrajectoryPolynomialX Polynomial describing x position of the ball's hit trajectory.
	TrajectoryPolynomialX *[]float64 `json:"trajectoryPolynomialX,omitempty"`

	// TrajectoryPolynomialY Polynomial describing y position of the ball's hit trajectory.
	TrajectoryPolynomialY *[]float64 `json:"trajectoryPolynomialY,omitempty"`

	// TrajectoryPolynomialZ Polynomial describing z position of the ball's hit trajectory.
	TrajectoryPolynomialZ *[]float64 `json:"trajectoryPolynomialZ,omitempty"`
	ValidTimeInterval     *[]float64 `json:"validTimeInterval,omitempty"`
}

// HomeRunDerbyBatterHitRestObject defines model for HomeRunDerbyBatterHitRestObject.
type HomeRunDerbyBatterHitRestObject struct {
	BonusOutsCurrent     *int32                `json:"bonusOutsCurrent,omitempty"`
	BonusOutsTotal       *int32                `json:"bonusOutsTotal,omitempty"`
	BonusTime            *bool                 `json:"bonusTime,omitempty"`
	Copyright            *string               `json:"copyright,omitempty"`
	HitData              *HitSegmentRestObject `json:"hitData,omitempty"`
	HomeRun              *bool                 `json:"homeRun,omitempty"`
	IsBonusTime          *bool                 `json:"isBonusTime,omitempty"`
	IsHomeRun            *bool                 `json:"isHomeRun,omitempty"`
	IsTieBreaker         *bool                 `json:"isTieBreaker,omitempty"`
	PlayId               *string               `json:"playId,omitempty"`
	TieBreaker           *bool                 `json:"tieBreaker,omitempty"`
	TieBreakerNum        *int32                `json:"tieBreakerNum,omitempty"`
	Time                 *time.Time            `json:"time,omitempty"`
	TimeRemaining        *string               `json:"timeRemaining,omitempty"`
	TimeRemainingSeconds *int32                `json:"timeRemainingSeconds,omitempty"`
}

// HomeRunDerbyMatchupRestObject defines model for HomeRunDerbyMatchupRestObject.
type HomeRunDerbyMatchupRestObject struct {
	BottomSeed *HomeRunDerbyRoundBatterRestObject `json:"bottomSeed,omitempty"`
	Copyright  *string                            `json:"copyright,omitempty"`
	TopSeed    *HomeRunDerbyRoundBatterRestObject `json:"topSeed,omitempty"`
}

// HomeRunDerbyRestObject defines model for HomeRunDerbyRestObject.
type HomeRunDerbyRestObject struct {
	Copyright *string                        `json:"copyright,omitempty"`
	Info      *ScheduleEventRestObject       `json:"info,omitempty"`
	Players   *[]BaseballPersonRestObject    `json:"players,omitempty"`
	Rounds    *[]HomeRunDerbyRoundRestObject `json:"rounds,omitempty"`
	Status    *HomeRunDerbyStatusRestObject  `json:"status,omitempty"`
}

// HomeRunDerbyRoundBatterRestObject defines model for HomeRunDerbyRoundBatterRestObject.
type HomeRunDerbyRoundBatterRestObject struct {
	Complete        *bool                              `json:"complete,omitempty"`
	Copyright       *string                            `json:"copyright,omitempty"`
	Hits            *[]HomeRunDerbyBatterHitRestObject `json:"hits,omitempty"`
	IsComplete      *bool                              `json:"isComplete,omitempty"`
	IsStarted       *bool                              `json:"isStarted,omitempty"`
	IsWinner        *bool                              `json:"isWinner,omitempty"`
	NumHomeRuns     *int32                             `json:"numHomeRuns,omitempty"`
	Order           *int32                             `json:"order,omitempty"`
	Player          *BaseballPersonRestObject          `json:"player,omitempty"`
	Seed            *int32                             `json:"seed,omitempty"`
	Started         *bool                              `json:"started,omitempty"`
	TopDerbyHitData *BaseballHitDataRestObject         `json:"topDerbyHitData,omitempty"`
	Winner          *bool                              `json:"winner,omitempty"`
}

// HomeRunDerbyRoundRestObject defines model for HomeRunDerbyRoundRestObject.
type HomeRunDerbyRoundRestObject struct {
	Batters         *[]HomeRunDerbyRoundBatterRestObject `json:"batters,omitempty"`
	Copyright       *string                              `json:"copyright,omitempty"`
	Matchups        *[]HomeRunDerbyMatchupRestObject     `json:"matchups,omitempty"`
	NumBatters      *int32                               `json:"numBatters,omitempty"`
	NumberOfPitches *int32                               `json:"numberOfPitches,omitempty"`
	Round           *int32                               `json:"round,omitempty"`
	RoundTime       *int32                               `json:"roundTime,omitempty"`
	Type            *string                              `json:"type,omitempty"`
}

// HomeRunDerbyStatusRestObject defines model for HomeRunDerbyStatusRestObject.
type HomeRunDerbyStatusRestObject struct {
	BonusCountNeededPerRound    *int32                    `json:"bonusCountNeededPerRound,omitempty"`
	BonusDistanceNeededPerRound *int32                    `json:"bonusDistanceNeededPerRound,omitempty"`
	BonusOutsCurrent            *int32                    `json:"bonusOutsCurrent,omitempty"`
	BonusOutsTotal              *int32                    `json:"bonusOutsTotal,omitempty"`
	BonusTime                   *bool                     `json:"bonusTime,omitempty"`
	BonusTypeOuts               *bool                     `json:"bonusTypeOuts,omitempty"`
	ClockStopped                *bool                     `json:"clockStopped,omitempty"`
	Copyright                   *string                   `json:"copyright,omitempty"`
	CurrentBatter               *BaseballPersonRestObject `json:"currentBatter,omitempty"`
	CurrentRound                *int32                    `json:"currentRound,omitempty"`
	CurrentRoundInProgress      *bool                     `json:"currentRoundInProgress,omitempty"`
	CurrentRoundTimeLeft        *string                   `json:"currentRoundTimeLeft,omitempty"`
	InTieBreaker                *bool                     `json:"inTieBreaker,omitempty"`
	PitchesInRound              *int32                    `json:"pitchesInRound,omitempty"`
	PitchesRemaining            *int32                    `json:"pitchesRemaining,omitempty"`
	RegulationRoundLength       *string                   `json:"regulationRoundLength,omitempty"`
	RegulationRoundLenth        *string                   `json:"regulationRoundLenth,omitempty"`
	ScheduledRounds             *int32                    `json:"scheduledRounds,omitempty"`
	State                       *string                   `json:"state,omitempty"`
	TieBreakerNum               *int32                    `json:"tieBreakerNum,omitempty"`
}

// IFeed defines model for IFeed.
type IFeed struct {
	Date *time.Time `json:"date,omitempty"`
}

// IFeedRestObject defines model for IFeedRestObject.
type IFeedRestObject = map[string]interface{}

// IGameStatus defines model for IGameStatus.
type IGameStatus struct {
	AbstractGameState *string `json:"abstractGameState,omitempty"`
	Code              *string `json:"code,omitempty"`
	DetailedState     *string `json:"detailedState,omitempty"`
	StartTimeTBD      *bool   `json:"startTimeTBD,omitempty"`
}

// IOfficialType defines model for IOfficialType.
type IOfficialType struct {
	DisplayName *string `json:"displayName,omitempty"`
	ShortName   *string `json:"shortName,omitempty"`
}

// Image defines model for Image.
type Image struct {
	Caption           *string            `json:"caption,omitempty"`
	ImageType         *ImageTypeEnum     `json:"imageType,omitempty"`
	ImageTypeAsString *string            `json:"imageTypeAsString,omitempty"`
	Images            *map[string]string `json:"images,omitempty"`
	Url               *string            `json:"url,omitempty"`
}

// ImageRestObject defines model for ImageRestObject.
type ImageRestObject struct {
	Caption   *string            `json:"caption,omitempty"`
	Copyright *string            `json:"copyright,omitempty"`
	Images    *map[string]string `json:"images,omitempty"`
	Url       *string            `json:"url,omitempty"`
}

// ImageTypeEnum defines model for ImageTypeEnum.
type ImageTypeEnum string

// IndoorDeviation Weather deviation data in indoor conditions. `distance`: Calculated deviation in distance of the standard 80-ft-apex flyball hit in indoor conditions. `horizontal`: Calculated deviation in horizontal distance of the standard 80-ft-apex flyball hit in indoor conditions. A negative deviation means the ball ended up more towards left field.
type IndoorDeviation struct {
	Apex       *float64 `json:"apex,omitempty"`
	Copyright  *string  `json:"copyright,omitempty"`
	Distance   *float64 `json:"distance,omitempty"`
	Height     *float64 `json:"height,omitempty"`
	Horizontal *float64 `json:"horizontal,omitempty"`
	Time       *float64 `json:"time,omitempty"`
}

// InningHit defines model for InningHit.
type InningHit struct {
	Batter      *BaseballPersonRestObject `json:"batter,omitempty"`
	Coordinates *Coordinate               `json:"coordinates,omitempty"`
	Copyright   *string                   `json:"copyright,omitempty"`
	Description *string                   `json:"description,omitempty"`
	Inning      *int32                    `json:"inning,omitempty"`
	Pitcher     *BaseballPersonRestObject `json:"pitcher,omitempty"`
	Team        *BaseballTeamRestObject   `json:"team,omitempty"`
	Type        *string                   `json:"type,omitempty"`
}

// InningHitWrap defines model for InningHitWrap.
type InningHitWrap struct {
	Away      *[]InningHit `json:"away,omitempty"`
	Copyright *string      `json:"copyright,omitempty"`
	Home      *[]InningHit `json:"home,omitempty"`
}

// InningPlay defines model for InningPlay.
type InningPlay struct {
	Bottom     *[]int32       `json:"bottom,omitempty"`
	Copyright  *string        `json:"copyright,omitempty"`
	EndIndex   *int32         `json:"endIndex,omitempty"`
	Hits       *InningHitWrap `json:"hits,omitempty"`
	StartIndex *int32         `json:"startIndex,omitempty"`
	Top        *[]int32       `json:"top,omitempty"`
}

// InningRestObject defines model for InningRestObject.
type InningRestObject struct {
	Away       *InningTeamInfoRestObject `json:"away,omitempty"`
	Copyright  *string                   `json:"copyright,omitempty"`
	Home       *InningTeamInfoRestObject `json:"home,omitempty"`
	Num        *int32                    `json:"num,omitempty"`
	OrdinalNum *string                   `json:"ordinalNum,omitempty"`
}

// InningTeamInfoRestObject defines model for InningTeamInfoRestObject.
type InningTeamInfoRestObject struct {
	Copyright  *string `json:"copyright,omitempty"`
	Errors     *int32  `json:"errors,omitempty"`
	Hits       *int32  `json:"hits,omitempty"`
	LeftOnBase *int32  `json:"leftOnBase,omitempty"`
	Runs       *int32  `json:"runs,omitempty"`
}

// JobTypeRestObject defines model for JobTypeRestObject.
type JobTypeRestObject struct {
	Code      *string `json:"code,omitempty"`
	Copyright *string `json:"copyright,omitempty"`
	Job       *string `json:"job,omitempty"`
	SortOrder *int32  `json:"sortOrder,omitempty"`
}

// JsonNode defines model for JsonNode.
type JsonNode = map[string]interface{}

// LandingDataRestObject defines model for LandingDataRestObject.
type LandingDataRestObject struct {
	Copyright *string `json:"copyright,omitempty"`

	// Distance Straight-line distance to the landing point of the ball's trajectory. If the ball hits above z=0 this distance is projected down to z=0.
	Distance *float64 `json:"distance,omitempty"`

	// OffsetSpin Additional distance attributed to the ball's spin.
	OffsetSpin *float64 `json:"offsetSpin,omitempty"`

	// OffsetWind Landing position offset attributed to the wind's impact on the ball's trajectory.
	OffsetWind *float64 `json:"offsetWind,omitempty"`

	// Position The x-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The y-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The z-coordinate of the landing position for the ball's trajectory. This will always be z=0 by definition.
	Position *LandingPositionRestObject `json:"position,omitempty"`

	// Time Hang time of the ball's trajectory.
	Time *float64 `json:"time,omitempty"`
}

// LandingPositionRestObject The x-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The y-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The z-coordinate of the landing position for the ball's trajectory. This will always be z=0 by definition.
type LandingPositionRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
	TimeStamp *string `json:"timeStamp,omitempty"`

	// X Location in the horizontal dimension, negative toward third base, positive toward first base.
	X *float64 `json:"x,omitempty"`

	// Y Location in the depth dimension, negative toward the backstop, positive toward pitchers mound.
	Y *float64 `json:"y,omitempty"`

	// Z Location in the vertical dimension, from the ground upward.
	Z *float64 `json:"z,omitempty"`
}

// Language defines model for Language.
type Language string

// LaunchData defines model for LaunchData.
type LaunchData struct {
	Angle             *float64     `json:"angle,omitempty"`
	ContactPosition   *Position    `json:"contactPosition,omitempty"`
	Direction         *float64     `json:"direction,omitempty"`
	ReducedConfidence *[]string    `json:"reducedConfidence,omitempty"`
	Speed             *float64     `json:"speed,omitempty"`
	SpinAxis          *float64     `json:"spinAxis,omitempty"`
	SpinRate          *float64     `json:"spinRate,omitempty"`
	SpinVector        *Coordinates `json:"spinVector,omitempty"`
}

// LaunchDataRestObject defines model for LaunchDataRestObject.
type LaunchDataRestObject struct {
	Angle *float64 `json:"angle,omitempty"`

	// ContactPosition The x-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The y-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The z-coordinate of the landing position for the ball's trajectory. This will always be z=0 by definition.
	ContactPosition   *PositionRestObject    `json:"contactPosition,omitempty"`
	Copyright         *string                `json:"copyright,omitempty"`
	Direction         *float64               `json:"direction,omitempty"`
	ReducedConfidence *[]string              `json:"reducedConfidence,omitempty"`
	Speed             *float64               `json:"speed,omitempty"`
	SpinAxis          *float64               `json:"spinAxis,omitempty"`
	SpinRate          *float64               `json:"spinRate,omitempty"`
	SpinVector        *CoordinatesRestObject `json:"spinVector,omitempty"`
}

// LeaderLimits defines model for LeaderLimits.
type LeaderLimits struct {
	Amount      *string `json:"amount,omitempty"`
	CompareType *string `json:"compareType,omitempty"`
	Type        *string `json:"type,omitempty"`
}

// Leaders defines model for Leaders.
type Leaders struct {
	GameType           *GameTypeEnum                      `json:"gameType,omitempty"`
	HydratedPeople     *map[string]map[string]interface{} `json:"hydratedPeople,omitempty"`
	HydratedTeams      *map[string]map[string]interface{} `json:"hydratedTeams,omitempty"`
	LeaderCategory     *PersonLeadersEnum                 `json:"leaderCategory,omitempty"`
	Leaders            *[]PlayerLeader                    `json:"leaders,omitempty"`
	League             *League                            `json:"league,omitempty"`
	LimitMetaData      *LimitMetadata                     `json:"limitMetaData,omitempty"`
	Limits             *LeaderLimits                      `json:"limits,omitempty"`
	RequestingUserRole *Role                              `json:"requestingUserRole,omitempty"`
	Season             *string                            `json:"season,omitempty"`
	StatGroup          *StatGroup                         `json:"statGroup,omitempty"`
	StatType           *StatType                          `json:"statType,omitempty"`
	Team               *BaseballTeam                      `json:"team,omitempty"`
	TotalSplits        *int32                             `json:"totalSplits,omitempty"`
	UserPrivileges     *[]Privilege                       `json:"userPrivileges,omitempty"`
}

// LeadersRestObject defines model for LeadersRestObject.
type LeadersRestObject struct {
	Copyright      *string                   `json:"copyright,omitempty"`
	GameType       *GameTypeEnum             `json:"gameType,omitempty"`
	Hydrations     *[]string                 `json:"hydrations,omitempty"`
	LeaderCategory *string                   `json:"leaderCategory,omitempty"`
	Leaders        *[]PlayerLeaderRestObject `json:"leaders,omitempty"`
	League         *LeagueRestObject         `json:"league,omitempty"`
	LimitMetadata  *LimitMetadataRestObject  `json:"limitMetadata,omitempty"`
	Limits         *LeaderLimits             `json:"limits,omitempty"`
	Season         *string                   `json:"season,omitempty"`
	StatGroup      *string                   `json:"statGroup,omitempty"`
	Team           *BaseballTeamRestObject   `json:"team,omitempty"`
	TotalSplits    *int32                    `json:"totalSplits,omitempty"`
}

// League defines model for League.
type League struct {
	Active             *bool           `json:"active,omitempty"`
	Affiliated         *bool           `json:"affiliated,omitempty"`
	DefaultVenueId     *int32          `json:"defaultVenueId,omitempty"`
	Games              *int32          `json:"games,omitempty"`
	HasConferences     *bool           `json:"hasConferences,omitempty"`
	HasDivisions       *bool           `json:"hasDivisions,omitempty"`
	HasPlayoffPoints   *bool           `json:"hasPlayoffPoints,omitempty"`
	HasSplitSeason     *bool           `json:"hasSplitSeason,omitempty"`
	HasWildcard        *bool           `json:"hasWildcard,omitempty"`
	Id                 *int32          `json:"id,omitempty"`
	LeagueTimeZone     *TimeZone       `json:"leagueTimeZone,omitempty"`
	Name               *string         `json:"name,omitempty"`
	NameAbbreviation   *string         `json:"nameAbbreviation,omitempty"`
	NameShort          *string         `json:"nameShort,omitempty"`
	OrgCode            *string         `json:"orgCode,omitempty"`
	RequestingUserRole *Role           `json:"requestingUserRole,omitempty"`
	RuleSettings       *[]RuleSettings `json:"ruleSettings,omitempty"`
	Season             *string         `json:"season,omitempty"`
	SeasonDateInfo     *Season         `json:"seasonDateInfo,omitempty"`
	SeasonState        *string         `json:"seasonState,omitempty"`
	SortOrder          *int32          `json:"sortOrder,omitempty"`
	Sport              *Sport          `json:"sport,omitempty"`
	TimeZone           *TimeZone       `json:"timeZone,omitempty"`
	TotalTeams         *int32          `json:"totalTeams,omitempty"`
	TotalWildcardTeams *int32          `json:"totalWildcardTeams,omitempty"`
	UserPrivileges     *[]Privilege    `json:"userPrivileges,omitempty"`
}

// LeagueActiveStatusEnum defines model for LeagueActiveStatusEnum.
type LeagueActiveStatusEnum string

// LeagueLeaderContainerRestObject defines model for LeagueLeaderContainerRestObject.
type LeagueLeaderContainerRestObject struct {
	Copyright     *string              `json:"copyright,omitempty"`
	LeagueLeaders *[]LeadersRestObject `json:"leagueLeaders,omitempty"`
}

// LeagueLeaderTypeRestObject defines model for LeagueLeaderTypeRestObject.
type LeagueLeaderTypeRestObject struct {
	DisplayName *string `json:"displayName,omitempty"`
}

// LeagueListsEnum defines model for LeagueListsEnum.
type LeagueListsEnum string

// LeagueRestObject defines model for LeagueRestObject.
type LeagueRestObject struct {
	Abbreviation     *string                   `json:"abbreviation,omitempty"`
	Active           *bool                     `json:"active,omitempty"`
	ConferencesInUse *bool                     `json:"conferencesInUse,omitempty"`
	Copyright        *string                   `json:"copyright,omitempty"`
	DivisionsInUse   *bool                     `json:"divisionsInUse,omitempty"`
	HasPlayoffPoints *bool                     `json:"hasPlayoffPoints,omitempty"`
	HasSplitSeason   *bool                     `json:"hasSplitSeason,omitempty"`
	HasWildCard      *bool                     `json:"hasWildCard,omitempty"`
	Id               *int32                    `json:"id,omitempty"`
	IsAffiliated     *bool                     `json:"isAffiliated,omitempty"`
	Link             *string                   `json:"link,omitempty"`
	Name             *string                   `json:"name,omitempty"`
	NameShort        *string                   `json:"nameShort,omitempty"`
	NumGames         *int32                    `json:"numGames,omitempty"`
	NumTeams         *int32                    `json:"numTeams,omitempty"`
	NumWildcardTeams *int32                    `json:"numWildcardTeams,omitempty"`
	OrgCode          *string                   `json:"orgCode,omitempty"`
	RuleSettings     *[]RuleSettingsRestObject `json:"ruleSettings,omitempty"`
	Season           *string                   `json:"season,omitempty"`
	SeasonDateInfo   *SeasonRestObject         `json:"seasonDateInfo,omitempty"`
	SeasonState      *string                   `json:"seasonState,omitempty"`
	SortOrder        *int32                    `json:"sortOrder,omitempty"`
	Sport            *SportRestObject          `json:"sport,omitempty"`
	TimeZone         *TimeZoneRestObject       `json:"timeZone,omitempty"`
}

// LimitMetadata defines model for LimitMetadata.
type LimitMetadata struct {
	Limit  *int32 `json:"limit,omitempty"`
	Offset *int32 `json:"offset,omitempty"`
	Ties   *int32 `json:"ties,omitempty"`
}

// LimitMetadataRestObject defines model for LimitMetadataRestObject.
type LimitMetadataRestObject struct {
	AdditionalTies *int32  `json:"additionalTies,omitempty"`
	Copyright      *string `json:"copyright,omitempty"`
	Limit          *int32  `json:"limit,omitempty"`
	Offset         *int32  `json:"offset,omitempty"`
}

// Lineup defines model for Lineup.
type Lineup struct {
	AwayPlayers *JsonNode `json:"awayPlayers,omitempty"`
	HomePlayers *JsonNode `json:"homePlayers,omitempty"`
}

// LiveLookin defines model for LiveLookin.
type LiveLookin struct {
	GamePk          *int32                `json:"gamePk,omitempty"`
	Headline        *string               `json:"headline,omitempty"`
	Kicker          *string               `json:"kicker,omitempty"`
	MediaPlaybackId *int64                `json:"mediaPlaybackId,omitempty"`
	Playbacks       *[]LiveLookinPlayback `json:"playbacks,omitempty"`
}

// LiveLookinPlayback defines model for LiveLookinPlayback.
type LiveLookinPlayback struct {
	Name *string `json:"name,omitempty"`
	Url  *string `json:"url,omitempty"`
}

// Location defines model for Location.
type Location struct {
	Address1     *string  `json:"address1,omitempty"`
	Address2     *string  `json:"address2,omitempty"`
	Address3     *string  `json:"address3,omitempty"`
	Address4     *string  `json:"address4,omitempty"`
	Attention    *string  `json:"attention,omitempty"`
	AzimuthAngle *float64 `json:"azimuthAngle,omitempty"`
	City         *string  `json:"city,omitempty"`
	Country      *string  `json:"country,omitempty"`
	Elevation    *int32   `json:"elevation,omitempty"`
	Latitude     *float64 `json:"latitude,omitempty"`
	Longitude    *float64 `json:"longitude,omitempty"`
	Phone        *string  `json:"phone,omitempty"`
	PostalCode   *string  `json:"postalCode,omitempty"`
	State        *string  `json:"state,omitempty"`
	StateAbbrev  *string  `json:"stateAbbrev,omitempty"`
}

// LocationRestObject defines model for LocationRestObject.
type LocationRestObject struct {
	Address1           *string                 `json:"address1,omitempty"`
	Address2           *string                 `json:"address2,omitempty"`
	Address3           *string                 `json:"address3,omitempty"`
	Address4           *string                 `json:"address4,omitempty"`
	AzimuthAngle       *float64                `json:"azimuthAngle,omitempty"`
	City               *string                 `json:"city,omitempty"`
	Coordinates        *[]CoordinateRestObject `json:"coordinates,omitempty"`
	Copyright          *string                 `json:"copyright,omitempty"`
	Country            *string                 `json:"country,omitempty"`
	DefaultCoordinates *CoordinateRestObject   `json:"defaultCoordinates,omitempty"`
	Elevation          *int32                  `json:"elevation,omitempty"`
	Phone              *string                 `json:"phone,omitempty"`
	PostalCode         *string                 `json:"postalCode,omitempty"`
	State              *string                 `json:"state,omitempty"`
	StateAbbrev        *string                 `json:"stateAbbrev,omitempty"`
}

// Matchup defines model for Matchup.
type Matchup struct {
	BatSide                 *DynamicEnumRestObject           `json:"batSide,omitempty"`
	Batter                  *BaseballPersonRestObject        `json:"batter,omitempty"`
	BatterHotColdZoneStats  *StatsRestObject                 `json:"batterHotColdZoneStats,omitempty"`
	BatterHotColdZones      *[]BaseballHotColdZoneRestObject `json:"batterHotColdZones,omitempty"`
	Copyright               *string                          `json:"copyright,omitempty"`
	PitchHand               *DynamicEnumRestObject           `json:"pitchHand,omitempty"`
	Pitcher                 *BaseballPersonRestObject        `json:"pitcher,omitempty"`
	PitcherHotColdZoneStats *StatsRestObject                 `json:"pitcherHotColdZoneStats,omitempty"`
	PitcherHotColdZones     *[]BaseballHotColdZoneRestObject `json:"pitcherHotColdZones,omitempty"`
	PostOnFirst             *BaseballPersonRestObject        `json:"postOnFirst,omitempty"`
	PostOnSecond            *BaseballPersonRestObject        `json:"postOnSecond,omitempty"`
	PostOnThird             *BaseballPersonRestObject        `json:"postOnThird,omitempty"`
	Splits                  *Split                           `json:"splits,omitempty"`
}

// MeasuredDataRestObject defines model for MeasuredDataRestObject.
type MeasuredDataRestObject struct {
	Confidence *string                `json:"confidence,omitempty"`
	Copyright  *string                `json:"copyright,omitempty"`
	Position   *CoordinatesRestObject `json:"position,omitempty"`
	Time       *float64               `json:"time,omitempty"`
	Velocity   *CoordinatesRestObject `json:"velocity,omitempty"`
}

// Media defines model for Media.
type Media struct {
	Broadcasts    *[]GameDateBroadcast `json:"broadcasts,omitempty"`
	EnhancedGame  *bool                `json:"enhancedGame,omitempty"`
	Epg           *JsonNode            `json:"epg,omitempty"`
	EpgAlternate  *JsonNode            `json:"epgAlternate,omitempty"`
	FeaturedMedia *JsonNode            `json:"featuredMedia,omitempty"`
	FreeGame      *bool                `json:"freeGame,omitempty"`
	GameStory     *JsonNode            `json:"gameStory,omitempty"`
	Milestones    *JsonNode            `json:"milestones,omitempty"`
	PreviewStory  *JsonNode            `json:"previewStory,omitempty"`
}

// MediaSourceType defines model for MediaSourceType.
type MediaSourceType string

// MediaState defines model for MediaState.
type MediaState string

// MediaStateRestObject defines model for MediaStateRestObject.
type MediaStateRestObject struct {
	Copyright      *string `json:"copyright,omitempty"`
	MediaStateCode *string `json:"mediaStateCode,omitempty"`
	MediaStateId   *int32  `json:"mediaStateId,omitempty"`
	MediaStateText *string `json:"mediaStateText,omitempty"`
}

// MetricType defines model for MetricType.
type MetricType string

// MetricWarningRestObject defines model for MetricWarningRestObject.
type MetricWarningRestObject struct {
	Actionable    *bool   `json:"actionable,omitempty"`
	Content       *string `json:"content,omitempty"`
	Copyright     *string `json:"copyright,omitempty"`
	Id            *string `json:"id,omitempty"`
	Level         *string `json:"level,omitempty"`
	OperationType *string `json:"operationType,omitempty"`
	PlayTime      *int64  `json:"playTime,omitempty"`
	Time          *int64  `json:"time,omitempty"`
	Type          *string `json:"type,omitempty"`
	TypeId        *string `json:"typeId,omitempty"`
	Value         *string `json:"value,omitempty"`
}

// MilestoneAchievementStatusRestObject defines model for MilestoneAchievementStatusRestObject.
type MilestoneAchievementStatusRestObject struct {
	AchievementStatusCode *string `json:"achievementStatusCode,omitempty"`
	AchievementStatusDesc *string `json:"achievementStatusDesc,omitempty"`
	AchievementStatusId   *int32  `json:"achievementStatusId,omitempty"`
	AchievementStatusText *string `json:"achievementStatusText,omitempty"`
	Copyright             *string `json:"copyright,omitempty"`
}

// MilestoneAchievementType defines model for MilestoneAchievementType.
type MilestoneAchievementType struct {
	AchievementTypeCode *string `json:"achievementTypeCode,omitempty"`
	AchievementTypeDesc *string `json:"achievementTypeDesc,omitempty"`
	AchievementTypeId   *int32  `json:"achievementTypeId,omitempty"`
	AchievementTypeText *string `json:"achievementTypeText,omitempty"`
}

// MilestoneContainerRestObject defines model for MilestoneContainerRestObject.
type MilestoneContainerRestObject struct {
	Copyright  *string                `json:"copyright,omitempty"`
	Milestones *[]MilestoneRestObject `json:"milestones,omitempty"`
}

// MilestoneDuration defines model for MilestoneDuration.
type MilestoneDuration struct {
	MilestoneDurationCode *string `json:"milestoneDurationCode,omitempty"`
	MilestoneDurationId   *int32  `json:"milestoneDurationId,omitempty"`
	MilestoneDurationText *string `json:"milestoneDurationText,omitempty"`
}

// MilestoneDurationRestObject defines model for MilestoneDurationRestObject.
type MilestoneDurationRestObject struct {
	Copyright             *string `json:"copyright,omitempty"`
	MilestoneDurationCode *string `json:"milestoneDurationCode,omitempty"`
	MilestoneDurationId   *int32  `json:"milestoneDurationId,omitempty"`
	MilestoneDurationText *string `json:"milestoneDurationText,omitempty"`
}

// MilestoneRestObject defines model for MilestoneRestObject.
type MilestoneRestObject struct {
	AchievementDate         *openapi_types.Date                   `json:"achievementDate,omitempty"`
	AchievementRank         *int32                                `json:"achievementRank,omitempty"`
	AchievementStatus       *MilestoneAchievementStatusRestObject `json:"achievementStatus,omitempty"`
	AchievementValue        *int32                                `json:"achievementValue,omitempty"`
	AtBatNumber             *int32                                `json:"atBatNumber,omitempty"`
	Copyright               *string                               `json:"copyright,omitempty"`
	CurrentValue            *int32                                `json:"currentValue,omitempty"`
	GameId                  *int32                                `json:"gameId,omitempty"`
	IsLastAchievementStatus *bool                                 `json:"isLastAchievementStatus,omitempty"`
	MilestoneAchievementId  *int32                                `json:"milestoneAchievementId,omitempty"`
	MilestoneProjectionId   *int32                                `json:"milestoneProjectionId,omitempty"`
	MilestoneRule           *MilestoneRuleRestObject              `json:"milestoneRule,omitempty"`
	OrganizationId          *int32                                `json:"organizationId,omitempty"`
	PitchNumber             *int32                                `json:"pitchNumber,omitempty"`
	PlayId                  *string                               `json:"playId,omitempty"`
	Player                  *BaseballPersonRestObject             `json:"player,omitempty"`
	ProjectionRank          *int32                                `json:"projectionRank,omitempty"`
	ProjectionValue         *int32                                `json:"projectionValue,omitempty"`
	RuleCount               *int32                                `json:"ruleCount,omitempty"`
	StatDifference          *int32                                `json:"statDifference,omitempty"`
	Team                    *BaseballTeamRestObject               `json:"team,omitempty"`
}

// MilestoneRuleRestObject defines model for MilestoneRuleRestObject.
type MilestoneRuleRestObject struct {
	Copyright          *string                       `json:"copyright,omitempty"`
	GameTypeCode       *string                       `json:"gameTypeCode,omitempty"`
	MilestoneDuration  *MilestoneDurationRestObject  `json:"milestoneDuration,omitempty"`
	MilestoneRank      *int32                        `json:"milestoneRank,omitempty"`
	MilestoneRuleId    *int32                        `json:"milestoneRuleId,omitempty"`
	MilestoneStatistic *MilestoneStatisticRestObject `json:"milestoneStatistic,omitempty"`
	MilestoneType      *MilestoneTypeRestObject      `json:"milestoneType,omitempty"`
	MilestoneValue     *int32                        `json:"milestoneValue,omitempty"`
	OrgType            *OrganizationTypeRestObject   `json:"orgType,omitempty"`
}

// MilestoneStatisticRestObject defines model for MilestoneStatisticRestObject.
type MilestoneStatisticRestObject struct {
	Category         *string                      `json:"category,omitempty"`
	Copyright        *string                      `json:"copyright,omitempty"`
	IsStandardStatus *bool                        `json:"isStandardStatus,omitempty"`
	IsStatcastStatus *bool                        `json:"isStatcastStatus,omitempty"`
	StatAbbr         *string                      `json:"statAbbr,omitempty"`
	StatEnum         *BaseballStatsTypeRestObject `json:"statEnum,omitempty"`
	StatisticDesc    *string                      `json:"statisticDesc,omitempty"`
	StatisticId      *int32                       `json:"statisticId,omitempty"`
	StatisticText    *string                      `json:"statisticText,omitempty"`
}

// MilestoneType defines model for MilestoneType.
type MilestoneType struct {
	MilestoneTypeCode *string `json:"milestoneTypeCode,omitempty"`
	MilestoneTypeId   *int32  `json:"milestoneTypeId,omitempty"`
	MilestoneTypeText *string `json:"milestoneTypeText,omitempty"`
}

// MilestoneTypeRestObject defines model for MilestoneTypeRestObject.
type MilestoneTypeRestObject struct {
	Copyright         *string `json:"copyright,omitempty"`
	MilestoneTypeCode *string `json:"milestoneTypeCode,omitempty"`
	MilestoneTypeId   *int32  `json:"milestoneTypeId,omitempty"`
	MilestoneTypeText *string `json:"milestoneTypeText,omitempty"`
}

// MoundVisitsRestObject defines model for MoundVisitsRestObject.
type MoundVisitsRestObject struct {
	Away      *UsedRemainingRestObject `json:"away,omitempty"`
	Copyright *string                  `json:"copyright,omitempty"`
	Home      *UsedRemainingRestObject `json:"home,omitempty"`
}

// Movement defines model for Movement.
type Movement struct {
	End        *string `json:"end,omitempty"`
	IsOut      *bool   `json:"isOut,omitempty"`
	OriginBase *string `json:"originBase,omitempty"`
	OutBase    *string `json:"outBase,omitempty"`
	OutNumber  *int32  `json:"outNumber,omitempty"`
	Start      *string `json:"start,omitempty"`
}

// NonGameBroadcastRestObject defines model for NonGameBroadcastRestObject.
type NonGameBroadcastRestObject struct {
	Availability             *BroadcastAvailabilityRestObject `json:"availability,omitempty"`
	AvailableForStreaming    *bool                            `json:"availableForStreaming,omitempty"`
	BroadcastDate            *openapi_types.Date              `json:"broadcastDate,omitempty"`
	CallSign                 *string                          `json:"callSign,omitempty"`
	Copyright                *string                          `json:"copyright,omitempty"`
	Id                       *int32                           `json:"id,omitempty"`
	IsNational               *bool                            `json:"isNational,omitempty"`
	Language                 *string                          `json:"language,omitempty"`
	MediaId                  *string                          `json:"mediaId,omitempty"`
	MediaState               *MediaStateRestObject            `json:"mediaState,omitempty"`
	MvpdAuthRequired         *bool                            `json:"mvpdAuthRequired,omitempty"`
	Name                     *string                          `json:"name,omitempty"`
	NonGameDateBroadcastGuid *string                          `json:"nonGameDateBroadcastGuid,omitempty"`
	Site                     *string                          `json:"site,omitempty"`
	SourceComment            *string                          `json:"sourceComment,omitempty"`
	SourceUrl                *string                          `json:"sourceUrl,omitempty"`
	Type                     *string                          `json:"type,omitempty"`
	VideoResolution          *VideoResolutionEnumRestObject   `json:"videoResolution,omitempty"`
	XrefIds                  *[]XrefIdRestObject              `json:"xrefIds,omitempty"`
}

// NonGameDateBroadcast defines model for NonGameDateBroadcast.
type NonGameDateBroadcast struct {
	BroadcastAvailability       *BroadcastAvailability `json:"broadcastAvailability,omitempty"`
	BroadcastComment            *string                `json:"broadcastComment,omitempty"`
	BroadcastDate               *openapi_types.Date    `json:"broadcastDate,omitempty"`
	BroadcastUrl                *string                `json:"broadcastUrl,omitempty"`
	Broadcaster                 *Broadcaster           `json:"broadcaster,omitempty"`
	EventId                     *int32                 `json:"eventId,omitempty"`
	IsNationalStatus            *bool                  `json:"isNationalStatus,omitempty"`
	Language                    *Language              `json:"language,omitempty"`
	MediaState                  *MediaState            `json:"mediaState,omitempty"`
	MvpdAuthBroadcastStatus     *bool                  `json:"mvpdAuthBroadcastStatus,omitempty"`
	NonGameDateBroadcastGuid    *openapi_types.UUID    `json:"nonGameDateBroadcastGuid,omitempty"`
	Site                        *Site                  `json:"site,omitempty"`
	SortOrder                   *int32                 `json:"sortOrder,omitempty"`
	StreamingAvailabilityStatus *bool                  `json:"streamingAvailabilityStatus,omitempty"`
	TeamId                      *int32                 `json:"teamId,omitempty"`
	VideoResolution             *VideoResolution       `json:"videoResolution,omitempty"`
	Xrefs                       *[]BroadcasterXrefId   `json:"xrefs,omitempty"`
}

// Official defines model for Official.
type Official struct {
	GameDate     *openapi_types.Date `json:"gameDate,omitempty"`
	JerseyNumber *string             `json:"jerseyNumber,omitempty"`
	OfficialType *IOfficialType      `json:"officialType,omitempty"`
	Person       *BaseballPerson     `json:"person,omitempty"`
}

// OfficialRestObject defines model for OfficialRestObject.
type OfficialRestObject struct {
	Official     *BaseballPersonRestObject `json:"official,omitempty"`
	OfficialType *string                   `json:"officialType,omitempty"`
}

// OrganizationType defines model for OrganizationType.
type OrganizationType string

// OrganizationTypeRestObject defines model for OrganizationTypeRestObject.
type OrganizationTypeRestObject struct {
	Copyright   *string `json:"copyright,omitempty"`
	OrgTypeCode *string `json:"orgTypeCode,omitempty"`
	OrgTypeId   *int32  `json:"orgTypeId,omitempty"`
	OrgTypeText *string `json:"orgTypeText,omitempty"`
}

// OtherNames defines model for OtherNames.
type OtherNames struct {
	FirstName    *string `json:"firstName,omitempty"`
	Id           *int32  `json:"id,omitempty"`
	LastName     *string `json:"lastName,omitempty"`
	PhoneticName *string `json:"phoneticName,omitempty"`
	Slug         *string `json:"slug,omitempty"`
}

// OtherNamesRestObject defines model for OtherNamesRestObject.
type OtherNamesRestObject struct {
	Copyright            *string `json:"copyright,omitempty"`
	FirstInitialLastName *string `json:"firstInitialLastName,omitempty"`
	LastFirstName        *string `json:"lastFirstName,omitempty"`
	LastNameFirstInitial *string `json:"lastNameFirstInitial,omitempty"`
	PhoneticName         *string `json:"phoneticName,omitempty"`
	Slug                 *string `json:"slug,omitempty"`
}

// OtherTeamNames defines model for OtherTeamNames.
type OtherTeamNames struct {
	Slug *string `json:"slug,omitempty"`
}

// PeopleRestObject defines model for PeopleRestObject.
type PeopleRestObject struct {
	Copyright  *string                     `json:"copyright,omitempty"`
	Hydrations *[]string                   `json:"hydrations,omitempty"`
	People     *[]BaseballPersonRestObject `json:"people,omitempty"`
}

// PerformerType defines model for PerformerType.
type PerformerType struct {
	Name *string `json:"name,omitempty"`
}

// PersonLeadersEnum defines model for PersonLeadersEnum.
type PersonLeadersEnum string

// PersonStatGroupRestObject defines model for PersonStatGroupRestObject.
type PersonStatGroupRestObject struct {
	Copyright           *string                        `json:"copyright,omitempty"`
	Person              *string                        `json:"person,omitempty"`
	PrimaryStatGroups   *StatSearchStatGroupRestObject `json:"primaryStatGroups,omitempty"`
	SupportedStatGroups *StatSearchStatGroupRestObject `json:"supportedStatGroups,omitempty"`
}

// Photo defines model for Photo.
type Photo struct {
	DefaultRes *string `json:"defaultRes,omitempty"`
	DoubleRes  *string `json:"doubleRes,omitempty"`
	LowRes     *string `json:"lowRes,omitempty"`
	PhotoType  *string `json:"photoType,omitempty"`
	TripleRes  *string `json:"tripleRes,omitempty"`
}

// PhotoRestObject defines model for PhotoRestObject.
type PhotoRestObject struct {
	Copyright  *string `json:"copyright,omitempty"`
	DefaultRes *string `json:"defaultRes,omitempty"`
	DoubleRes  *string `json:"doubleRes,omitempty"`
	LowRes     *string `json:"lowRes,omitempty"`
	PhotoType  *string `json:"photoType,omitempty"`
	TripleRes  *string `json:"tripleRes,omitempty"`
}

// PitchCode defines model for PitchCode.
type PitchCode string

// PitchCodeRestObject defines model for PitchCodeRestObject.
type PitchCodeRestObject struct {
	BallStatus         *bool   `json:"ballStatus,omitempty"`
	Code               *string `json:"code,omitempty"`
	Copyright          *string `json:"copyright,omitempty"`
	Description        *string `json:"description,omitempty"`
	PitchResultText    *string `json:"pitchResultText,omitempty"`
	PitchStatus        *bool   `json:"pitchStatus,omitempty"`
	SortOrder          *int32  `json:"sortOrder,omitempty"`
	StrikeStatus       *bool   `json:"strikeStatus,omitempty"`
	SwingContactStatus *bool   `json:"swingContactStatus,omitempty"`
	SwingMissStatus    *bool   `json:"swingMissStatus,omitempty"`
	SwingStatus        *bool   `json:"swingStatus,omitempty"`
}

// PitchFxDataRestObject defines model for PitchFxDataRestObject.
type PitchFxDataRestObject struct {
	A0        *CoordinatesRestObject `json:"a0,omitempty"`
	Copyright *string                `json:"copyright,omitempty"`
	PfxHorz   *float64               `json:"pfxHorz,omitempty"`
	PfxVert   *float64               `json:"pfxVert,omitempty"`
	V0        *CoordinatesRestObject `json:"v0,omitempty"`
	X0        *CoordinatesRestObject `json:"x0,omitempty"`
}

// PitchHandTypeRestObject defines model for PitchHandTypeRestObject.
type PitchHandTypeRestObject struct {
	Code        *string `json:"code,omitempty"`
	Copyright   *string `json:"copyright,omitempty"`
	Description *string `json:"description,omitempty"`
}

// PitchSegmentRestObject defines model for PitchSegmentRestObject.
type PitchSegmentRestObject struct {
	Copyright        *string                        `json:"copyright,omitempty"`
	LastMeasuredData *StartEndDataRestObject        `json:"lastMeasuredData,omitempty"`
	ReleaseData      *ReleaseDataRestObject         `json:"releaseData,omitempty"`
	TrajectoryData   *PitchTrajectoryDataRestObject `json:"trajectoryData,omitempty"`
}

// PitchTrajectoryDataRestObject defines model for PitchTrajectoryDataRestObject.
type PitchTrajectoryDataRestObject struct {
	Copyright               *string                `json:"copyright,omitempty"`
	EffectiveVelocity       *float64               `json:"effectiveVelocity,omitempty"`
	HorizontalApproachAngle *float64               `json:"horizontalApproachAngle,omitempty"`
	HorizontalBreak         *float64               `json:"horizontalBreak,omitempty"`
	Location                *CoordinatesRestObject `json:"location,omitempty"`
	MeasuredTimeInterval    *[]float64             `json:"measuredTimeInterval,omitempty"`
	PfxData                 *PitchFxDataRestObject `json:"pfxData,omitempty"`
	ReducedConfidence       *[]string              `json:"reducedConfidence,omitempty"`

	// TrajectoryPolynomialX Polynomial describing x position of the ball's pitch trajectory.
	TrajectoryPolynomialX *[]float64 `json:"trajectoryPolynomialX,omitempty"`

	// TrajectoryPolynomialY Polynomial describing y position of the ball's pitch trajectory.
	TrajectoryPolynomialY *[]float64 `json:"trajectoryPolynomialY,omitempty"`

	// TrajectoryPolynomialZ Polynomial describing z position of the ball's pitch trajectory.
	TrajectoryPolynomialZ *[]float64 `json:"trajectoryPolynomialZ,omitempty"`
	ValidTimeInterval     *[]float64 `json:"validTimeInterval,omitempty"`
	VerticalApproachAngle *float64   `json:"verticalApproachAngle,omitempty"`
	VerticalBreak         *float64   `json:"verticalBreak,omitempty"`
	VerticalBreakInduced  *float64   `json:"verticalBreakInduced,omitempty"`
	ZoneSpeed             *float64   `json:"zoneSpeed,omitempty"`
	ZoneTime              *float64   `json:"zoneTime,omitempty"`
}

// PitchType defines model for PitchType.
type PitchType string

// PitchTypeRestObject defines model for PitchTypeRestObject.
type PitchTypeRestObject struct {
	Code        *string `json:"code,omitempty"`
	Copyright   *string `json:"copyright,omitempty"`
	Description *string `json:"description,omitempty"`
}

// PitcherDetailType defines model for PitcherDetailType.
type PitcherDetailType string

// PitchingData defines model for PitchingData.
type PitchingData struct {
	AirOuts                            *int32             `json:"airOuts,omitempty"`
	Assists                            *int32             `json:"assists,omitempty"`
	AtBats                             *int32             `json:"atBats,omitempty"`
	Average                            *string            `json:"average,omitempty"`
	Balks                              *int32             `json:"balks,omitempty"`
	Balls                              *int32             `json:"balls,omitempty"`
	BallsInPlay                        *int32             `json:"ballsInPlay,omitempty"`
	BattersFaced                       *int32             `json:"battersFaced,omitempty"`
	BattingOrder                       *string            `json:"battingOrder,omitempty"`
	BlownSaves                         *int32             `json:"blownSaves,omitempty"`
	CatchersInterference               *int32             `json:"catchersInterference,omitempty"`
	CaughtStealing                     *int32             `json:"caughtStealing,omitempty"`
	Chances                            *int32             `json:"chances,omitempty"`
	CompleteGames                      *int32             `json:"completeGames,omitempty"`
	Doubles                            *int32             `json:"doubles,omitempty"`
	EarnedRunAverage                   *string            `json:"earnedRunAverage,omitempty"`
	EarnedRuns                         *int32             `json:"earnedRuns,omitempty"`
	FlyHits                            *int32             `json:"flyHits,omitempty"`
	FlyOuts                            *int32             `json:"flyOuts,omitempty"`
	Games                              *int32             `json:"games,omitempty"`
	GamesFinished                      *int32             `json:"gamesFinished,omitempty"`
	GamesPlayedOnBothTeams             *int32             `json:"gamesPlayedOnBothTeams,omitempty"`
	GamesStarted                       *int32             `json:"gamesStarted,omitempty"`
	Gidp                               *int32             `json:"gidp,omitempty"`
	GidpOpportunites                   *int32             `json:"gidpOpportunites,omitempty"`
	Gitp                               *int32             `json:"gitp,omitempty"`
	GoAo                               *string            `json:"goAo,omitempty"`
	GroundHits                         *int32             `json:"groundHits,omitempty"`
	GroundOuts                         *int32             `json:"groundOuts,omitempty"`
	HitBatsmen                         *int32             `json:"hitBatsmen,omitempty"`
	HitByPitch                         *int32             `json:"hitByPitch,omitempty"`
	Hits                               *int32             `json:"hits,omitempty"`
	HitsPer9Inn                        *string            `json:"hitsPer9Inn,omitempty"`
	Holds                              *int32             `json:"holds,omitempty"`
	HomeRuns                           *int32             `json:"homeRuns,omitempty"`
	HomeRunsPer9                       *string            `json:"homeRunsPer9,omitempty"`
	HomeRunsPer9OrNull                 *string            `json:"homeRunsPer9OrNull,omitempty"`
	InheritedRunnersStrandedPercentage *string            `json:"inheritedRunnersStrandedPercentage,omitempty"`
	InheritedRuns                      *int32             `json:"inheritedRuns,omitempty"`
	InheritedRunsScored                *int32             `json:"inheritedRunsScored,omitempty"`
	InningsPitched                     *string            `json:"inningsPitched,omitempty"`
	IntentionalWalks                   *int32             `json:"intentionalWalks,omitempty"`
	LineHits                           *int32             `json:"lineHits,omitempty"`
	LineOuts                           *int32             `json:"lineOuts,omitempty"`
	Losses                             *int32             `json:"losses,omitempty"`
	Note                               *string            `json:"note,omitempty"`
	NumberOfPitches                    *int32             `json:"numberOfPitches,omitempty"`
	OnBasePercentage                   *string            `json:"onBasePercentage,omitempty"`
	OnBasePlusSlugging                 *string            `json:"onBasePlusSlugging,omitempty"`
	Outs                               *int32             `json:"outs,omitempty"`
	OutsPitched                        *int32             `json:"outsPitched,omitempty"`
	PassedBall                         *int32             `json:"passedBall,omitempty"`
	Pickoffs                           *int32             `json:"pickoffs,omitempty"`
	PitchesPerInning                   *string            `json:"pitchesPerInning,omitempty"`
	PitchesPerPlateAppearance          *float64           `json:"pitchesPerPlateAppearance,omitempty"`
	PitchesPerPlateAppearanceStr       *string            `json:"pitchesPerPlateAppearanceStr,omitempty"`
	PitchesThrown                      *int32             `json:"pitchesThrown,omitempty"`
	PitchingOrder                      *int32             `json:"pitchingOrder,omitempty"`
	PlateAppearances                   *int32             `json:"plateAppearances,omitempty"`
	PopHits                            *int32             `json:"popHits,omitempty"`
	PopOuts                            *int32             `json:"popOuts,omitempty"`
	Putouts                            *int32             `json:"putouts,omitempty"`
	RequestingUserRole                 *Role              `json:"requestingUserRole,omitempty"`
	Runs                               *int32             `json:"runs,omitempty"`
	RunsBattedIn                       *int32             `json:"runsBattedIn,omitempty"`
	RunsScoredPer9                     *string            `json:"runsScoredPer9,omitempty"`
	RunsScoredPer9OrNull               *string            `json:"runsScoredPer9OrNull,omitempty"`
	SacBunts                           *int32             `json:"sacBunts,omitempty"`
	SacFlies                           *int32             `json:"sacFlies,omitempty"`
	SaveOpportunities                  *int32             `json:"saveOpportunities,omitempty"`
	Saves                              *int32             `json:"saves,omitempty"`
	Shutouts                           *int32             `json:"shutouts,omitempty"`
	Singles                            *int32             `json:"singles,omitempty"`
	Slugging                           *string            `json:"slugging,omitempty"`
	StolenBasePercentage               *string            `json:"stolenBasePercentage,omitempty"`
	StolenBasePercentageOrNull         *string            `json:"stolenBasePercentageOrNull,omitempty"`
	StolenBases                        *int32             `json:"stolenBases,omitempty"`
	Streak                             *int32             `json:"streak,omitempty"`
	StrikePercentage                   *string            `json:"strikePercentage,omitempty"`
	StrikePercentageOrNull             *string            `json:"strikePercentageOrNull,omitempty"`
	StrikeoutWalkRatio                 *string            `json:"strikeoutWalkRatio,omitempty"`
	Strikeouts                         *int32             `json:"strikeouts,omitempty"`
	StrikeoutsPer9Inn                  *string            `json:"strikeoutsPer9Inn,omitempty"`
	Strikes                            *int32             `json:"strikes,omitempty"`
	Summary                            *map[string]string `json:"summary,omitempty"`
	SwingsAndMisses                    *int32             `json:"swingsAndMisses,omitempty"`
	Ties                               *int32             `json:"ties,omitempty"`
	TotalBases                         *int32             `json:"totalBases,omitempty"`
	TotalSwings                        *int32             `json:"totalSwings,omitempty"`
	Triples                            *int32             `json:"triples,omitempty"`
	UserPrivileges                     *[]Privilege       `json:"userPrivileges,omitempty"`
	Walks                              *int32             `json:"walks,omitempty"`
	WalksHitsPerInningPitched          *string            `json:"walksHitsPerInningPitched,omitempty"`
	WalksPer9Inn                       *string            `json:"walksPer9Inn,omitempty"`
	WildPitches                        *int32             `json:"wildPitches,omitempty"`
	WinPercentage                      *string            `json:"winPercentage,omitempty"`
	Wins                               *int32             `json:"wins,omitempty"`
}

// Platform defines model for Platform.
type Platform string

// PlayCredit defines model for PlayCredit.
type PlayCredit struct {
	BatterStat  *BatterDetailType  `json:"batterStat,omitempty"`
	Credit      *string            `json:"credit,omitempty"`
	Detail      *GameEventDetailTO `json:"detail,omitempty"`
	FielderStat *FielderDetailType `json:"fielderStat,omitempty"`
	Person      *BaseballPerson    `json:"person,omitempty"`
	PitcherStat *PitcherDetailType `json:"pitcherStat,omitempty"`
	Position    *BaseballPosition  `json:"position,omitempty"`
	RunnerStat  *RunnerDetailType  `json:"runnerStat,omitempty"`
}

// PlayCreditRestObject defines model for PlayCreditRestObject.
type PlayCreditRestObject struct {
	Copyright *string                   `json:"copyright,omitempty"`
	Credit    *string                   `json:"credit,omitempty"`
	Player    *BaseballPersonRestObject `json:"player,omitempty"`

	// Position The x-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The y-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The z-coordinate of the landing position for the ball's trajectory. This will always be z=0 by definition.
	Position *PositionRestObject `json:"position,omitempty"`
}

// PlayEventRestObject defines model for PlayEventRestObject.
type PlayEventRestObject struct {
	Copyright     *string  `json:"copyright,omitempty"`
	IsScrubbed    *bool    `json:"isScrubbed,omitempty"`
	PlayEvent     *string  `json:"playEvent,omitempty"`
	PlayEventId   *string  `json:"playEventId,omitempty"`
	PlayEventType *int32   `json:"playEventType,omitempty"`
	PositionId    *int32   `json:"positionId,omitempty"`
	TimeCode      *int64   `json:"timeCode,omitempty"`
	TimeStamp     *string  `json:"timeStamp,omitempty"`
	X             *float64 `json:"x,omitempty"`
	Y             *float64 `json:"y,omitempty"`
}

// PlayResultRestObject defines model for PlayResultRestObject.
type PlayResultRestObject struct {
	Copyright      *string                     `json:"copyright,omitempty"`
	EventSequence  *[]EventSequenceRestObject  `json:"eventSequence,omitempty"`
	PlayerSequence *[]PlayerSequenceRestObject `json:"playerSequence,omitempty"`
	RunnerSequence *[]RunnerSequenceRestObject `json:"runnerSequence,omitempty"`
}

// PlayWeatherWrapperRestObject defines model for PlayWeatherWrapperRestObject.
type PlayWeatherWrapperRestObject struct {
	Copyright *string                `json:"copyright,omitempty"`
	Data      *WeatherPlayRestObject `json:"data,omitempty"`
	Units     *JsonNode              `json:"units,omitempty"`
}

// PlayerActiveStatusEnum defines model for PlayerActiveStatusEnum.
type PlayerActiveStatusEnum string

// PlayerDraftInfo defines model for PlayerDraftInfo.
type PlayerDraftInfo struct {
	PickInRound *int32        `json:"pickInRound,omitempty"`
	PickOverall *int32        `json:"pickOverall,omitempty"`
	Round       *string       `json:"round,omitempty"`
	Team        *BaseballTeam `json:"team,omitempty"`
	Year        *int32        `json:"year,omitempty"`
}

// PlayerDraftInfoRestObject defines model for PlayerDraftInfoRestObject.
type PlayerDraftInfoRestObject struct {
	Copyright   *string                 `json:"copyright,omitempty"`
	PickInRound *int32                  `json:"pickInRound,omitempty"`
	PickOverall *int32                  `json:"pickOverall,omitempty"`
	Round       *string                 `json:"round,omitempty"`
	Team        *BaseballTeamRestObject `json:"team,omitempty"`
	Year        *int32                  `json:"year,omitempty"`
}

// PlayerLeader defines model for PlayerLeader.
type PlayerLeader struct {
	League   *League         `json:"league,omitempty"`
	NumTeams *int32          `json:"numTeams,omitempty"`
	Person   *BaseballPerson `json:"person,omitempty"`
	Rank     *int32          `json:"rank,omitempty"`
	Season   *string         `json:"season,omitempty"`
	Sport    *Sport          `json:"sport,omitempty"`
	Team     *BaseballTeam   `json:"team,omitempty"`
	Value    *string         `json:"value,omitempty"`
}

// PlayerLeaderRestObject defines model for PlayerLeaderRestObject.
type PlayerLeaderRestObject struct {
	Copyright *string                   `json:"copyright,omitempty"`
	League    *LeagueRestObject         `json:"league,omitempty"`
	NumTeams  *int32                    `json:"numTeams,omitempty"`
	Person    *BaseballPersonRestObject `json:"person,omitempty"`
	Rank      *int32                    `json:"rank,omitempty"`
	Season    *string                   `json:"season,omitempty"`
	Sport     *SportRestObject          `json:"sport,omitempty"`
	Team      *BaseballTeamRestObject   `json:"team,omitempty"`
	Value     *string                   `json:"value,omitempty"`
}

// PlayerListPerson defines model for PlayerListPerson.
type PlayerListPerson struct {
	League         *League           `json:"league,omitempty"`
	Player         *BaseballPerson   `json:"player,omitempty"`
	PlayerListId   *string           `json:"playerListId,omitempty"`
	PlayerListName *string           `json:"playerListName,omitempty"`
	Position       *BaseballPosition `json:"position,omitempty"`
	Season         *string           `json:"season,omitempty"`
	Team           *BaseballTeam     `json:"team,omitempty"`
}

// PlayerPoolEnum defines model for PlayerPoolEnum.
type PlayerPoolEnum string

// PlayerSequenceRestObject defines model for PlayerSequenceRestObject.
type PlayerSequenceRestObject struct {
	Copyright  *string `json:"copyright,omitempty"`
	PlayType   *string `json:"playType,omitempty"`
	PositionId *int32  `json:"positionId,omitempty"`
}

// Position defines model for Position.
type Position struct {
	TimeStamp *string  `json:"timeStamp,omitempty"`
	X         *float64 `json:"x,omitempty"`
	Y         *float64 `json:"y,omitempty"`
	Z         *float64 `json:"z,omitempty"`
}

// PositionRestObject The x-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The y-coordinate of the landing position for the ball's trajectory. This is defined using the x,y position at z=0. The z-coordinate of the landing position for the ball's trajectory. This will always be z=0 by definition.
type PositionRestObject = LandingPositionRestObject

// PositionalMapRestObject defines model for PositionalMapRestObject.
type PositionalMapRestObject struct {
	Copyright  *string               `json:"copyright,omitempty"`
	PositionId *int32                `json:"positionId,omitempty"`
	Positions  *[]PositionRestObject `json:"positions,omitempty"`
	Typ        *int32                `json:"typ,omitempty"`
}

// PostseasonScheduleRestObject defines model for PostseasonScheduleRestObject.
type PostseasonScheduleRestObject struct {
	Copyright            *string                     `json:"copyright,omitempty"`
	Series               *[]ScheduleSeriesRestObject `json:"series,omitempty"`
	TotalEvents          *int32                      `json:"totalEvents,omitempty"`
	TotalGames           *int32                      `json:"totalGames,omitempty"`
	TotalGamesInProgress *int32                      `json:"totalGamesInProgress,omitempty"`
	TotalItems           *int32                      `json:"totalItems,omitempty"`
	Wait                 *int32                      `json:"wait,omitempty"`
}

// PostseasonSeries defines model for PostseasonSeries.
type PostseasonSeries struct {
	GameType       *GameTypeEnum `json:"gameType,omitempty"`
	IsDefault      *bool         `json:"isDefault,omitempty"`
	SeriesConfigId *string       `json:"seriesConfigId,omitempty"`
	SeriesId       *string       `json:"seriesId,omitempty"`
	SortOrder      *int32        `json:"sortOrder,omitempty"`
}

// PostseasonSeriesRestObject defines model for PostseasonSeriesRestObject.
type PostseasonSeriesRestObject struct {
	Copyright  *string `json:"copyright,omitempty"`
	GameType   *string `json:"gameType,omitempty"`
	Id         *string `json:"id,omitempty"`
	IsDefault  *bool   `json:"isDefault,omitempty"`
	SortNumber *int32  `json:"sortNumber,omitempty"`
}

// Privilege defines model for Privilege.
type Privilege string

// Promotion defines model for Promotion.
type Promotion struct {
	AltPageUrl     *string `json:"altPageUrl,omitempty"`
	Description    *string `json:"description,omitempty"`
	DisplayIfPast  *bool   `json:"displayIfPast,omitempty"`
	Distribution   *string `json:"distribution,omitempty"`
	ImageUrl       *string `json:"imageUrl,omitempty"`
	NotSponsorship *bool   `json:"notSponsorship,omitempty"`
	OfferId        *int32  `json:"offerId,omitempty"`
	OfferType      *string `json:"offerType,omitempty"`
	Order          *int32  `json:"order,omitempty"`
	Other          *string `json:"other,omitempty"`
	PresentedBy    *string `json:"presentedBy,omitempty"`
	SortKey        *string `json:"sortKey,omitempty"`
	Sponsorship    *bool   `json:"sponsorship,omitempty"`
	TeamId         *int32  `json:"teamId,omitempty"`
	ThumbnailUrl   *string `json:"thumbnailUrl,omitempty"`
	Title          *string `json:"title,omitempty"`
	Tlink          *string `json:"tlink,omitempty"`
}

// PromotionRestObject defines model for PromotionRestObject.
type PromotionRestObject struct {
	AltPageUrl    *string `json:"altPageUrl,omitempty"`
	Copyright     *string `json:"copyright,omitempty"`
	Description   *string `json:"description,omitempty"`
	DisplayIfPast *bool   `json:"displayIfPast,omitempty"`
	Distribution  *string `json:"distribution,omitempty"`
	ImageUrl      *string `json:"imageUrl,omitempty"`
	Name          *string `json:"name,omitempty"`
	OfferId       *int32  `json:"offerId,omitempty"`
	OfferType     *string `json:"offerType,omitempty"`
	Order         *int32  `json:"order,omitempty"`
	Other         *string `json:"other,omitempty"`
	PresentedBy   *string `json:"presentedBy,omitempty"`
	SortKey       *string `json:"sortKey,omitempty"`
	TeamId        *int32  `json:"teamId,omitempty"`
	ThumbnailUrl  *string `json:"thumbnailUrl,omitempty"`
	Tlink         *string `json:"tlink,omitempty"`
}

// ProspectListRestObject defines model for ProspectListRestObject.
type ProspectListRestObject struct {
	Copyright    *string                            `json:"copyright,omitempty"`
	Offset       *int32                             `json:"offset,omitempty"`
	Prospects    *[]BaseballDraftProspectRestObject `json:"prospects,omitempty"`
	QueriedSize  *int32                             `json:"queriedSize,omitempty"`
	ReturnedSize *int32                             `json:"returnedSize,omitempty"`
	TotalSize    *int32                             `json:"totalSize,omitempty"`
}

// PublicFacingEnum defines model for PublicFacingEnum.
type PublicFacingEnum string

// RelatedApplication defines model for RelatedApplication.
type RelatedApplication struct {
	AndroidPackage *string `json:"androidPackage,omitempty"`
	AndroidUrl     *string `json:"androidUrl,omitempty"`
	Icon           *string `json:"icon,omitempty"`
	Intent         *string `json:"intent,omitempty"`
	IosPackage     *string `json:"iosPackage,omitempty"`
	IosUrl         *string `json:"iosUrl,omitempty"`
	Name           *string `json:"name,omitempty"`
	Primary        *bool   `json:"primary,omitempty"`
}

// Relative defines model for Relative.
type Relative struct {
	AdditionalBio               *AdditionalBio                     `json:"additionalBio,omitempty"`
	Age                         *int32                             `json:"age,omitempty"`
	AlumniLastSeason            *string                            `json:"alumniLastSeason,omitempty"`
	Articles                    *[]Article                         `json:"articles,omitempty"`
	Awards                      *[]Award                           `json:"awards,omitempty"`
	BatSide                     *DynamicLookupEnum                 `json:"batSide,omitempty"`
	BatterPitcher               *string                            `json:"batterPitcher,omitempty"`
	BirthCity                   *string                            `json:"birthCity,omitempty"`
	BirthCountry                *string                            `json:"birthCountry,omitempty"`
	BirthDate                   *openapi_types.Date                `json:"birthDate,omitempty"`
	BirthStateProvince          *string                            `json:"birthStateProvince,omitempty"`
	BoxscoreName                *string                            `json:"boxscoreName,omitempty"`
	CurrentTeam                 *BaseballTeam                      `json:"currentTeam,omitempty"`
	DeathCity                   *string                            `json:"deathCity,omitempty"`
	DeathCountry                *string                            `json:"deathCountry,omitempty"`
	DeathDate                   *openapi_types.Date                `json:"deathDate,omitempty"`
	DeathStateProvince          *string                            `json:"deathStateProvince,omitempty"`
	DepthCharts                 *[]DepthChart                      `json:"depthCharts,omitempty"`
	Draft                       *[]PlayerDraftInfo                 `json:"draft,omitempty"`
	DraftProspects              *map[string]map[string]interface{} `json:"draftProspects,omitempty"`
	DraftYear                   *int32                             `json:"draftYear,omitempty"`
	Drafts                      *[]BaseballDraftProspect           `json:"drafts,omitempty"`
	EducationInfo               *EducationInfo                     `json:"educationInfo,omitempty"`
	Fielder                     *bool                              `json:"fielder,omitempty"`
	FirstLastName               *string                            `json:"firstLastName,omitempty"`
	FirstName                   *string                            `json:"firstName,omitempty"`
	FullFMLName                 *string                            `json:"fullFMLName,omitempty"`
	FullLFMName                 *string                            `json:"fullLFMName,omitempty"`
	FullName                    *string                            `json:"fullName,omitempty"`
	Gender                      *string                            `json:"gender,omitempty"`
	HasStats                    *bool                              `json:"hasStats,omitempty"`
	Height                      *int32                             `json:"height,omitempty"`
	HeightFeet                  *int32                             `json:"heightFeet,omitempty"`
	HeightInches                *int32                             `json:"heightInches,omitempty"`
	HydratedArticles            *map[string]map[string]interface{} `json:"hydratedArticles,omitempty"`
	HydratedAwards              *map[string]map[string]interface{} `json:"hydratedAwards,omitempty"`
	HydratedCurrentTeam         *map[string]map[string]interface{} `json:"hydratedCurrentTeam,omitempty"`
	HydratedDepthCharts         *map[string]map[string]interface{} `json:"hydratedDepthCharts,omitempty"`
	HydratedEducation           *map[string]map[string]interface{} `json:"hydratedEducation,omitempty"`
	HydratedMixedFeed           *map[string]map[string]interface{} `json:"hydratedMixedFeed,omitempty"`
	HydratedNextStarts          *map[string]map[string]interface{} `json:"hydratedNextStarts,omitempty"`
	HydratedPersonJobsEntries   *map[string]map[string]interface{} `json:"hydratedPersonJobsEntries,omitempty"`
	HydratedPersonRosterEntries *map[string]map[string]interface{} `json:"hydratedPersonRosterEntries,omitempty"`
	HydratedPlayerPhotos        *map[string]map[string]interface{} `json:"hydratedPlayerPhotos,omitempty"`
	HydratedRelatives           *map[string]map[string]interface{} `json:"hydratedRelatives,omitempty"`
	HydratedSocial              *map[string]map[string]interface{} `json:"hydratedSocial,omitempty"`
	HydratedStats               *map[string]map[string]interface{} `json:"hydratedStats,omitempty"`
	HydratedTeam                *map[string]map[string]interface{} `json:"hydratedTeam,omitempty"`
	HydratedVideos              *map[string]map[string]interface{} `json:"hydratedVideos,omitempty"`
	Id                          *int32                             `json:"id,omitempty"`
	InitLastName                *string                            `json:"initLastName,omitempty"`
	IsActive                    *bool                              `json:"isActive,omitempty"`
	IsAlternateCaptain          *bool                              `json:"isAlternateCaptain,omitempty"`
	IsCaptain                   *bool                              `json:"isCaptain,omitempty"`
	IsPlayer                    *bool                              `json:"isPlayer,omitempty"`
	IsRookie                    *bool                              `json:"isRookie,omitempty"`
	IsVerified                  *bool                              `json:"isVerified,omitempty"`
	LanguageId                  *int32                             `json:"languageId,omitempty"`
	LastFirstName               *string                            `json:"lastFirstName,omitempty"`
	LastInitName                *string                            `json:"lastInitName,omitempty"`
	LastName                    *string                            `json:"lastName,omitempty"`
	LastPlayedDate              *openapi_types.Date                `json:"lastPlayedDate,omitempty"`
	MiddleName                  *string                            `json:"middleName,omitempty"`
	MixedFeed                   *[]IFeed                           `json:"mixedFeed,omitempty"`
	MlbDebutDate                *openapi_types.Date                `json:"mlbDebutDate,omitempty"`
	NameFirstLast               *string                            `json:"nameFirstLast,omitempty"`
	NameMatrilineal             *string                            `json:"nameMatrilineal,omitempty"`
	NamePrefix                  *string                            `json:"namePrefix,omitempty"`
	NameSlug                    *string                            `json:"nameSlug,omitempty"`
	NameTitle                   *string                            `json:"nameTitle,omitempty"`
	Nationality                 *string                            `json:"nationality,omitempty"`
	NextStarts                  *[]BaseballScheduleItem            `json:"nextStarts,omitempty"`
	NickName                    *string                            `json:"nickName,omitempty"`
	NickNames                   *[]string                          `json:"nickNames,omitempty"`
	Note                        *string                            `json:"note,omitempty"`
	OtherNames                  *OtherNames                        `json:"otherNames,omitempty"`
	PhoneticName                *string                            `json:"phoneticName,omitempty"`
	Photos                      *[]Photo                           `json:"photos,omitempty"`
	PitchHand                   *DynamicLookupEnum                 `json:"pitchHand,omitempty"`
	Pitcher                     *bool                              `json:"pitcher,omitempty"`
	PrimaryNumber               *string                            `json:"primaryNumber,omitempty"`
	PrimaryPosition             *BaseballPosition                  `json:"primaryPosition,omitempty"`
	Pronunciation               *string                            `json:"pronunciation,omitempty"`
	Relation                    *string                            `json:"relation,omitempty"`
	RequestingUserRole          *Role                              `json:"requestingUserRole,omitempty"`
	RookieSeasons               *[]string                          `json:"rookieSeasons,omitempty"`
	RosterNumber                *string                            `json:"rosterNumber,omitempty"`
	SocialMediaInfo             *SocialMediaInfo                   `json:"socialMediaInfo,omitempty"`
	Stats                       *Stats                             `json:"stats,omitempty"`
	StrikeZoneBottom            *float64                           `json:"strikeZoneBottom,omitempty"`
	StrikeZoneTop               *float64                           `json:"strikeZoneTop,omitempty"`
	Transactions                *[]Transaction                     `json:"transactions,omitempty"`
	Twitter                     *string                            `json:"twitter,omitempty"`
	UseLastName                 *string                            `json:"useLastName,omitempty"`
	UseName                     *string                            `json:"useName,omitempty"`
	UserPrivileges              *[]Privilege                       `json:"userPrivileges,omitempty"`
	Videos                      *[]Video                           `json:"videos,omitempty"`
	Weight                      *int32                             `json:"weight,omitempty"`
	XrefIds                     *[]XrefId                          `json:"xrefIds,omitempty"`
}

// ReleaseDataRestObject defines model for ReleaseDataRestObject.
type ReleaseDataRestObject struct {
	Angle             *float64                   `json:"angle,omitempty"`
	Copyright         *string                    `json:"copyright,omitempty"`
	Direction         *float64                   `json:"direction,omitempty"`
	Extension         *float64                   `json:"extension,omitempty"`
	ReducedConfidence *[]string                  `json:"reducedConfidence,omitempty"`
	ReleasePosition   *CoordinatesRestObject     `json:"releasePosition,omitempty"`
	ReleaseSpeed      *float64                   `json:"releaseSpeed,omitempty"`
	SeamOrientation   *SeamOrientationRestObject `json:"seamOrientation,omitempty"`
	SpinAxis          *float64                   `json:"spinAxis,omitempty"`
	SpinFitError      *float64                   `json:"spinFitError,omitempty"`
	SpinRate          *float64                   `json:"spinRate,omitempty"`
	SpinVector        *CoordinatesRestObject     `json:"spinVector,omitempty"`
}

// RestObject defines model for RestObject.
type RestObject struct {
	Copyright *string `json:"copyright,omitempty"`
}

// Result defines model for Result.
type Result struct {
	AwayScore   *int32  `json:"awayScore,omitempty"`
	Copyright   *string `json:"copyright,omitempty"`
	Description *string `json:"description,omitempty"`
	Event       *string `json:"event,omitempty"`
	EventType   *string `json:"eventType,omitempty"`
	HomeScore   *int32  `json:"homeScore,omitempty"`

	// IsOut Did the play result in an out?
	IsOut *bool   `json:"isOut,omitempty"`
	Rbi   *int32  `json:"rbi,omitempty"`
	Type  *string `json:"type,omitempty"`
}

// ReviewDetails defines model for ReviewDetails.
type ReviewDetails struct {
	AdditionalReviews *[]ReviewDetails `json:"additionalReviews,omitempty"`
	ChallengeTeamId   *int32           `json:"challengeTeamId,omitempty"`
	Copyright         *string          `json:"copyright,omitempty"`
	InProgress        *bool            `json:"inProgress,omitempty"`
	IsOverturned      *bool            `json:"isOverturned,omitempty"`
	ReviewType        *string          `json:"reviewType,omitempty"`
}

// Role defines model for Role.
type Role string

// RoofType defines model for RoofType.
type RoofType string

// RoofTypeRestObject defines model for RoofTypeRestObject.
type RoofTypeRestObject struct {
	Copyright   *string `json:"copyright,omitempty"`
	Description *string `json:"description,omitempty"`
	Value       *string `json:"value,omitempty"`
}

// RosterRestObject defines model for RosterRestObject.
type RosterRestObject struct {
	Copyright  *string                          `json:"copyright,omitempty"`
	Hydrations *[]string                        `json:"hydrations,omitempty"`
	Link       *string                          `json:"link,omitempty"`
	Roster     *[]BaseballRosterEntryRestObject `json:"roster,omitempty"`
	RosterType *string                          `json:"rosterType,omitempty"`
	TeamId     *int32                           `json:"teamId,omitempty"`
}

// RosterType defines model for RosterType.
type RosterType string

// RuleSettings defines model for RuleSettings.
type RuleSettings struct {
	AllGameTypeStatus   *bool                   `json:"allGameTypeStatus,omitempty"`
	EndDate             *openapi_types.Date     `json:"endDate,omitempty"`
	GamePk              *int32                  `json:"gamePk,omitempty"`
	GameType            *string                 `json:"gameType,omitempty"`
	Inherited           *bool                   `json:"inherited,omitempty"`
	League              *League                 `json:"league,omitempty"`
	PlaySettingId       *int32                  `json:"playSettingId,omitempty"`
	PriorityOverride    *int32                  `json:"priorityOverride,omitempty"`
	ScheduleEvent       *ScheduleEvent          `json:"scheduleEvent,omitempty"`
	SettingCategory     *string                 `json:"settingCategory,omitempty"`
	SettingCategoryCode *string                 `json:"settingCategoryCode,omitempty"`
	SettingCategoryId   *int32                  `json:"settingCategoryId,omitempty"`
	SettingDescription  *string                 `json:"settingDescription,omitempty"`
	SettingDisplayName  *string                 `json:"settingDisplayName,omitempty"`
	SettingId           *int32                  `json:"settingId,omitempty"`
	SettingIsPublic     *bool                   `json:"settingIsPublic,omitempty"`
	SettingName         *string                 `json:"settingName,omitempty"`
	SettingOptions      *[]RuleSettingsOption   `json:"settingOptions,omitempty"`
	SettingScope        *string                 `json:"settingScope,omitempty"`
	SettingValue        *map[string]interface{} `json:"settingValue,omitempty"`
	SortOrder           *int32                  `json:"sortOrder,omitempty"`
	Sport               *Sport                  `json:"sport,omitempty"`
	StartDate           *openapi_types.Date     `json:"startDate,omitempty"`
	UserHasPermission   *bool                   `json:"userHasPermission,omitempty"`
	ValueType           *string                 `json:"valueType,omitempty"`
	Venue               *Venue                  `json:"venue,omitempty"`
}

// RuleSettingsOption defines model for RuleSettingsOption.
type RuleSettingsOption struct {
	ActiveBeginDate *openapi_types.Date     `json:"activeBeginDate,omitempty"`
	ActiveEndDate   *openapi_types.Date     `json:"activeEndDate,omitempty"`
	Description     *string                 `json:"description,omitempty"`
	DisplayName     *string                 `json:"displayName,omitempty"`
	SettingId       *int32                  `json:"settingId,omitempty"`
	SettingValueId  *int32                  `json:"settingValueId,omitempty"`
	SortOrder       *int32                  `json:"sortOrder,omitempty"`
	Value           *map[string]interface{} `json:"value,omitempty"`
}

// RuleSettingsOptionRestObject defines model for RuleSettingsOptionRestObject.
type RuleSettingsOptionRestObject struct {
	ActiveBeginDate *openapi_types.Date     `json:"activeBeginDate,omitempty"`
	ActiveEndDate   *openapi_types.Date     `json:"activeEndDate,omitempty"`
	Description     *string                 `json:"description,omitempty"`
	DisplayName     *string                 `json:"displayName,omitempty"`
	SettingValueId  *int32                  `json:"settingValueId,omitempty"`
	SortOrder       *int32                  `json:"sortOrder,omitempty"`
	Value           *map[string]interface{} `json:"value,omitempty"`
}

// RuleSettingsRestObject defines model for RuleSettingsRestObject.
type RuleSettingsRestObject struct {
	AllGameTypeStatus   *bool                           `json:"allGameTypeStatus,omitempty"`
	EndDate             *openapi_types.Date             `json:"endDate,omitempty"`
	GameType            *string                         `json:"gameType,omitempty"`
	Inherited           *bool                           `json:"inherited,omitempty"`
	PlaySettingId       *int32                          `json:"playSettingId,omitempty"`
	PriorityOverride    *int32                          `json:"priorityOverride,omitempty"`
	SettingCategory     *string                         `json:"settingCategory,omitempty"`
	SettingCategoryCode *string                         `json:"settingCategoryCode,omitempty"`
	SettingDescription  *string                         `json:"settingDescription,omitempty"`
	SettingDisplayName  *string                         `json:"settingDisplayName,omitempty"`
	SettingId           *int32                          `json:"settingId,omitempty"`
	SettingName         *string                         `json:"settingName,omitempty"`
	SettingOptions      *[]RuleSettingsOptionRestObject `json:"settingOptions,omitempty"`
	SettingScope        *string                         `json:"settingScope,omitempty"`
	SettingValue        *map[string]interface{}         `json:"settingValue,omitempty"`
	SortOrder           *int32                          `json:"sortOrder,omitempty"`
	StartDate           *openapi_types.Date             `json:"startDate,omitempty"`
	ValueType           *string                         `json:"valueType,omitempty"`
}

// RunnerDetailType defines model for RunnerDetailType.
type RunnerDetailType string

// RunnerMovement defines model for RunnerMovement.
type RunnerMovement struct {
	Copyright *string                 `json:"copyright,omitempty"`
	Credits   *[]PlayCreditRestObject `json:"credits,omitempty"`
	Details   *Details                `json:"details,omitempty"`
	Movement  *Movement               `json:"movement,omitempty"`
}

// RunnerSequenceRestObject defines model for RunnerSequenceRestObject.
type RunnerSequenceRestObject struct {
	Copyright  *string `json:"copyright,omitempty"`
	EndBase    *int32  `json:"endBase,omitempty"`
	IsOut      *bool   `json:"isOut,omitempty"`
	PositionId *int32  `json:"positionId,omitempty"`
	StartBase  *int32  `json:"startBase,omitempty"`
}

// SacFlyProbability defines model for SacFlyProbability.
type SacFlyProbability struct {
	Fielder       *BaseballPersonRestObject `json:"fielder,omitempty"`
	InnerDistance *int32                    `json:"innerDistance,omitempty"`
	OuterDistance *int32                    `json:"outerDistance,omitempty"`
}

// ScheduleDateRestObject defines model for ScheduleDateRestObject.
type ScheduleDateRestObject struct {
	Copyright            *string                           `json:"copyright,omitempty"`
	Date                 *openapi_types.Date               `json:"date,omitempty"`
	Events               *[]ScheduleEventRestObject        `json:"events,omitempty"`
	Games                *[]BaseballScheduleItemRestObject `json:"games,omitempty"`
	TotalEvents          *int32                            `json:"totalEvents,omitempty"`
	TotalGames           *int32                            `json:"totalGames,omitempty"`
	TotalGamesInProgress *int32                            `json:"totalGamesInProgress,omitempty"`
	TotalItems           *int32                            `json:"totalItems,omitempty"`
}

// ScheduleEvent defines model for ScheduleEvent.
type ScheduleEvent struct {
	Broadcasts          *[]NonGameDateBroadcast `json:"broadcasts,omitempty"`
	CalendarDate        *openapi_types.Date     `json:"calendarDate,omitempty"`
	CalendarType        *CalendarTypes          `json:"calendarType,omitempty"`
	CoachingVideo       *[]MediaSourceType      `json:"coachingVideo,omitempty"`
	Content             *ScheduleEventCms       `json:"content,omitempty"`
	Divisions           *[]Division             `json:"divisions,omitempty"`
	EndDate             *openapi_types.Date     `json:"endDate,omitempty"`
	EndDateTime         *time.Time              `json:"endDateTime,omitempty"`
	EventDate           *time.Time              `json:"eventDate,omitempty"`
	EventDesignations   *[]Designation          `json:"eventDesignations,omitempty"`
	EventNumber         *int32                  `json:"eventNumber,omitempty"`
	EventStatus         *EventStatus            `json:"eventStatus,omitempty"`
	EventType           *ScheduleEventTypes     `json:"eventType,omitempty"`
	FileCode            *string                 `json:"fileCode,omitempty"`
	Game                *BaseballScheduleItem   `json:"game,omitempty"`
	Id                  *int32                  `json:"id,omitempty"`
	Images              *[]Image                `json:"images,omitempty"`
	Leagues             *[]League               `json:"leagues,omitempty"`
	Link                *string                 `json:"link,omitempty"`
	MultiDay            *bool                   `json:"multiDay,omitempty"`
	Name                *string                 `json:"name,omitempty"`
	NonGameGuid         *string                 `json:"nonGameGuid,omitempty"`
	OrganizationId      *int32                  `json:"organizationId,omitempty"`
	OrganizationIds     *[]int32                `json:"organizationIds,omitempty"`
	OrganizationType    *string                 `json:"organizationType,omitempty"`
	PrimaryCalendar     *bool                   `json:"primaryCalendar,omitempty"`
	PromotionTickets    *[]BaseballTicket       `json:"promotionTickets,omitempty"`
	PublicFacing        *PublicFacingEnum       `json:"publicFacing,omitempty"`
	Sports              *[]Sport                `json:"sports,omitempty"`
	TeamId              *int32                  `json:"teamId,omitempty"`
	Teams               *[]BaseballTeam         `json:"teams,omitempty"`
	Tickets             *[]BaseballTicket       `json:"tickets,omitempty"`
	TimeZone            *TimeZone               `json:"timeZone,omitempty"`
	TrackingSystemOwner *TrackingSystemOwner    `json:"trackingSystemOwner,omitempty"`
	TrackingVersion     *TrackingVersion        `json:"trackingVersion,omitempty"`
	Venue               *Venue                  `json:"venue,omitempty"`
}

// ScheduleEventCms defines model for ScheduleEventCms.
type ScheduleEventCms struct {
	Content *JsonNode `json:"content,omitempty"`
}

// ScheduleEventRestObject defines model for ScheduleEventRestObject.
type ScheduleEventRestObject struct {
	Broadcasts        *[]NonGameBroadcastRestObject   `json:"broadcasts,omitempty"`
	CoachingVideo     *[]MediaSourceType              `json:"coachingVideo,omitempty"`
	Content           *ScheduleEventCms               `json:"content,omitempty"`
	Copyright         *string                         `json:"copyright,omitempty"`
	Designations      *[]DesignationRestObject        `json:"designations,omitempty"`
	Divisions         *[]DivisionRestObject           `json:"divisions,omitempty"`
	EndDateTime       *time.Time                      `json:"endDateTime,omitempty"`
	EventDate         *time.Time                      `json:"eventDate,omitempty"`
	EventNumber       *int32                          `json:"eventNumber,omitempty"`
	EventStatus       *GameStatusRestObject           `json:"eventStatus,omitempty"`
	EventType         *ScheduleEventTypeRestObject    `json:"eventType,omitempty"`
	FileCode          *string                         `json:"fileCode,omitempty"`
	Game              *BaseballScheduleItemRestObject `json:"game,omitempty"`
	Id                *int32                          `json:"id,omitempty"`
	Images            *[]ImageRestObject              `json:"images,omitempty"`
	IsMultiDay        *bool                           `json:"isMultiDay,omitempty"`
	IsPrimaryCalendar *bool                           `json:"isPrimaryCalendar,omitempty"`
	Leagues           *[]LeagueRestObject             `json:"leagues,omitempty"`
	Link              *string                         `json:"link,omitempty"`
	Name              *string                         `json:"name,omitempty"`
	NonGameGuid       *string                         `json:"nonGameGuid,omitempty"`
	Promotions        *[]BaseballTicketRestObject     `json:"promotions,omitempty"`
	PublicFacing      *bool                           `json:"publicFacing,omitempty"`
	RuleSettings      *[]RuleSettingsRestObject       `json:"ruleSettings,omitempty"`
	Sports            *[]SportRestObject              `json:"sports,omitempty"`
	Teams             *[]BaseballTeamRestObject       `json:"teams,omitempty"`
	Tickets           *[]BaseballTicketRestObject     `json:"tickets,omitempty"`
	TimeZone          *TimeZoneRestObject             `json:"timeZone,omitempty"`
	TrackingVersion   *TrackingVersionRestObject      `json:"trackingVersion,omitempty"`
	Venue             *VenueRestObject                `json:"venue,omitempty"`
}

// ScheduleEventTypeRestObject defines model for ScheduleEventTypeRestObject.
type ScheduleEventTypeRestObject struct {
	Code      *string `json:"code,omitempty"`
	Copyright *string `json:"copyright,omitempty"`
	Name      *string `json:"name,omitempty"`
}

// ScheduleEventTypes defines model for ScheduleEventTypes.
type ScheduleEventTypes string

// ScheduleRestObject defines model for ScheduleRestObject.
type ScheduleRestObject struct {
	Copyright            *string                   `json:"copyright,omitempty"`
	Dates                *[]ScheduleDateRestObject `json:"dates,omitempty"`
	Hydrations           *[]string                 `json:"hydrations,omitempty"`
	TotalEvents          *int32                    `json:"totalEvents,omitempty"`
	TotalGames           *int32                    `json:"totalGames,omitempty"`
	TotalGamesInProgress *int32                    `json:"totalGamesInProgress,omitempty"`
	TotalItems           *int32                    `json:"totalItems,omitempty"`
	Wait                 *int32                    `json:"wait,omitempty"`
}

// ScheduleSeriesRestObject defines model for ScheduleSeriesRestObject.
type ScheduleSeriesRestObject struct {
	Copyright            *string                           `json:"copyright,omitempty"`
	Games                *[]BaseballScheduleItemRestObject `json:"games,omitempty"`
	Series               *PostseasonSeriesRestObject       `json:"series,omitempty"`
	SortOrder            *int32                            `json:"sortOrder,omitempty"`
	TotalGames           *int32                            `json:"totalGames,omitempty"`
	TotalGamesInProgress *int32                            `json:"totalGamesInProgress,omitempty"`
	TotalItems           *int32                            `json:"totalItems,omitempty"`
}

// ScheduleTypeEnum defines model for ScheduleTypeEnum.
type ScheduleTypeEnum string

// School defines model for School.
type School struct {
	City        *string `json:"city,omitempty"`
	Country     *string `json:"country,omitempty"`
	Name        *string `json:"name,omitempty"`
	SchoolClass *string `json:"schoolClass,omitempty"`
	State       *string `json:"state,omitempty"`
}

// SchoolRestObject defines model for SchoolRestObject.
type SchoolRestObject struct {
	City        *string `json:"city,omitempty"`
	Copyright   *string `json:"copyright,omitempty"`
	Country     *string `json:"country,omitempty"`
	Name        *string `json:"name,omitempty"`
	SchoolClass *string `json:"schoolClass,omitempty"`
	State       *string `json:"state,omitempty"`
}

// SeamOrientationRestObject defines model for SeamOrientationRestObject.
type SeamOrientationRestObject struct {
	Copyright *string  `json:"copyright,omitempty"`
	FrameRate *int32   `json:"frameRate,omitempty"`
	Time      *float64 `json:"time,omitempty"`
	Xx        *float64 `json:"xx,omitempty"`
	Xy        *float64 `json:"xy,omitempty"`
	Xz        *float64 `json:"xz,omitempty"`
	Yx        *float64 `json:"yx,omitempty"`
	Yy        *float64 `json:"yy,omitempty"`
	Yz        *float64 `json:"yz,omitempty"`
	Zx        *float64 `json:"zx,omitempty"`
	Zy        *float64 `json:"zy,omitempty"`
	Zz        *float64 `json:"zz,omitempty"`
}

// Season defines model for Season.
type Season struct {
	AllStarDate               *openapi_types.Date `json:"allStarDate,omitempty"`
	ConferencesInUse          *bool               `json:"conferencesInUse,omitempty"`
	DivisionsInUse            *bool               `json:"divisionsInUse,omitempty"`
	FirstDate2ndHalf          *openapi_types.Date `json:"firstDate2ndHalf,omitempty"`
	GameLevelGamedayType      *string             `json:"gameLevelGamedayType,omitempty"`
	GameTypeDates             *[]GameTypeDates    `json:"gameTypeDates,omitempty"`
	HasWildcard               *bool               `json:"hasWildcard,omitempty"`
	LastDate1stHalf           *openapi_types.Date `json:"lastDate1stHalf,omitempty"`
	NumberOfGames             *int32              `json:"numberOfGames,omitempty"`
	OffSeasonEndDate          *openapi_types.Date `json:"offSeasonEndDate,omitempty"`
	OffSeasonStartDate        *openapi_types.Date `json:"offSeasonStartDate,omitempty"`
	OlympicsParticipation     *bool               `json:"olympicsParticipation,omitempty"`
	OrganizationId            *int32              `json:"organizationId,omitempty"`
	PostSeasonEndDate         *openapi_types.Date `json:"postSeasonEndDate,omitempty"`
	PostSeasonStartDate       *openapi_types.Date `json:"postSeasonStartDate,omitempty"`
	PreSeasonEndDate          *openapi_types.Date `json:"preSeasonEndDate,omitempty"`
	PreSeasonStartDate        *openapi_types.Date `json:"preSeasonStartDate,omitempty"`
	QualifierInningsPitched   *float64            `json:"qualifierInningsPitched,omitempty"`
	QualifierOutsPitched      *float64            `json:"qualifierOutsPitched,omitempty"`
	QualifierPlateAppearances *float64            `json:"qualifierPlateAppearances,omitempty"`
	RegularSeasonEndDate      *openapi_types.Date `json:"regularSeasonEndDate,omitempty"`
	RegularSeasonStartDate    *openapi_types.Date `json:"regularSeasonStartDate,omitempty"`
	SeasonEndDate             *openapi_types.Date `json:"seasonEndDate,omitempty"`
	SeasonId                  *string             `json:"seasonId,omitempty"`
	SeasonLevelGamedayType    *string             `json:"seasonLevelGamedayType,omitempty"`
	SeasonStartDate           *openapi_types.Date `json:"seasonStartDate,omitempty"`
	SpringEndDate             *openapi_types.Date `json:"springEndDate,omitempty"`
	SpringStartDate           *openapi_types.Date `json:"springStartDate,omitempty"`
	TiesInUse                 *bool               `json:"tiesInUse,omitempty"`
}

// SeasonRestObject defines model for SeasonRestObject.
type SeasonRestObject struct {
	AllStarDate               *openapi_types.Date        `json:"allStarDate,omitempty"`
	ConferencesInUse          *bool                      `json:"conferencesInUse,omitempty"`
	Copyright                 *string                    `json:"copyright,omitempty"`
	DivisionsInUse            *bool                      `json:"divisionsInUse,omitempty"`
	FirstDate2ndHalf          *openapi_types.Date        `json:"firstDate2ndHalf,omitempty"`
	GameLevelGamedayType      *string                    `json:"gameLevelGamedayType,omitempty"`
	GameTypeDates             *[]GameTypeDatesRestObject `json:"gameTypeDates,omitempty"`
	HasWildcard               *bool                      `json:"hasWildcard,omitempty"`
	LastDate1stHalf           *openapi_types.Date        `json:"lastDate1stHalf,omitempty"`
	NumberOfGames             *int32                     `json:"numberOfGames,omitempty"`
	OffSeasonEndDate          *openapi_types.Date        `json:"offSeasonEndDate,omitempty"`
	OffseasonStartDate        *openapi_types.Date        `json:"offseasonStartDate,omitempty"`
	OlympicsParticipation     *bool                      `json:"olympicsParticipation,omitempty"`
	PostSeasonEndDate         *openapi_types.Date        `json:"postSeasonEndDate,omitempty"`
	PostSeasonStartDate       *openapi_types.Date        `json:"postSeasonStartDate,omitempty"`
	PreSeasonEndDate          *openapi_types.Date        `json:"preSeasonEndDate,omitempty"`
	PreSeasonStartDate        *openapi_types.Date        `json:"preSeasonStartDate,omitempty"`
	QualifierOutsPitched      *float64                   `json:"qualifierOutsPitched,omitempty"`
	QualifierPlateAppearances *float64                   `json:"qualifierPlateAppearances,omitempty"`
	RegularSeasonEndDate      *openapi_types.Date        `json:"regularSeasonEndDate,omitempty"`
	RegularSeasonStartDate    *openapi_types.Date        `json:"regularSeasonStartDate,omitempty"`
	SeasonEndDate             *openapi_types.Date        `json:"seasonEndDate,omitempty"`
	SeasonId                  *string                    `json:"seasonId,omitempty"`
	SeasonLevelGamedayType    *string                    `json:"seasonLevelGamedayType,omitempty"`
	SeasonStartDate           *openapi_types.Date        `json:"seasonStartDate,omitempty"`
	SpringEndDate             *openapi_types.Date        `json:"springEndDate,omitempty"`
	SpringStartDate           *openapi_types.Date        `json:"springStartDate,omitempty"`
	TiesInUse                 *bool                      `json:"tiesInUse,omitempty"`
}

// SeasonsRestObject defines model for SeasonsRestObject.
type SeasonsRestObject struct {
	Copyright *string             `json:"copyright,omitempty"`
	Seasons   *[]SeasonRestObject `json:"seasons,omitempty"`
}

// SegmentRestObject defines model for SegmentRestObject.
type SegmentRestObject struct {
	Copyright             *string                 `json:"copyright,omitempty"`
	EndData               *StartEndDataRestObject `json:"endData,omitempty"`
	FirstMeasuredData     *MeasuredDataRestObject `json:"firstMeasuredData,omitempty"`
	LandingData           *MeasuredDataRestObject `json:"landingData,omitempty"`
	LastMeasuredData      *MeasuredDataRestObject `json:"lastMeasuredData,omitempty"`
	ReducedConfidence     *[]string               `json:"reducedConfidence,omitempty"`
	SegmentType           *string                 `json:"segmentType,omitempty"`
	StartData             *StartEndDataRestObject `json:"startData,omitempty"`
	TrajectoryPolynomialX *[]float64              `json:"trajectoryPolynomialX,omitempty"`
	TrajectoryPolynomialY *[]float64              `json:"trajectoryPolynomialY,omitempty"`
	TrajectoryPolynomialZ *[]float64              `json:"trajectoryPolynomialZ,omitempty"`
}

// SeriesStatus defines model for SeriesStatus.
type SeriesStatus struct {
	Description        *string       `json:"description,omitempty"`
	GameNumber         *int32        `json:"gameNumber,omitempty"`
	GameType           *GameTypeEnum `json:"gameType,omitempty"`
	IsOver             *bool         `json:"isOver,omitempty"`
	IsTied             *bool         `json:"isTied,omitempty"`
	LosingTeam         *BaseballTeam `json:"losingTeam,omitempty"`
	Losses             *int32        `json:"losses,omitempty"`
	Result             *string       `json:"result,omitempty"`
	SeriesAbbreviation *string       `json:"seriesAbbreviation,omitempty"`
	SeriesAwayNumber   *int32        `json:"seriesAwayNumber,omitempty"`
	SeriesHomeNumber   *int32        `json:"seriesHomeNumber,omitempty"`
	SeriesId           *string       `json:"seriesId,omitempty"`
	SeriesName         *string       `json:"seriesName,omitempty"`
	ShortDescription   *string       `json:"shortDescription,omitempty"`
	Ties               *int32        `json:"ties,omitempty"`
	TotalGames         *int32        `json:"totalGames,omitempty"`
	WinningTeam        *BaseballTeam `json:"winningTeam,omitempty"`
	Wins               *int32        `json:"wins,omitempty"`
}

// SeriesStatusRestObject defines model for SeriesStatusRestObject.
type SeriesStatusRestObject struct {
	Abbreviation     *string                 `json:"abbreviation,omitempty"`
	Copyright        *string                 `json:"copyright,omitempty"`
	Description      *string                 `json:"description,omitempty"`
	GameNumber       *int32                  `json:"gameNumber,omitempty"`
	IsOver           *bool                   `json:"isOver,omitempty"`
	IsTied           *bool                   `json:"isTied,omitempty"`
	LosingTeam       *BaseballTeamRestObject `json:"losingTeam,omitempty"`
	Losses           *int32                  `json:"losses,omitempty"`
	Result           *string                 `json:"result,omitempty"`
	ShortDescription *string                 `json:"shortDescription,omitempty"`
	ShortName        *string                 `json:"shortName,omitempty"`
	TotalGames       *int32                  `json:"totalGames,omitempty"`
	WinningTeam      *BaseballTeamRestObject `json:"winningTeam,omitempty"`
	Wins             *int32                  `json:"wins,omitempty"`
}

// SettingsRestObject defines model for SettingsRestObject.
type SettingsRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
	Name      *string `json:"name,omitempty"`
}

// Site defines model for Site.
type Site string

// SituationCodeRestObject defines model for SituationCodeRestObject.
type SituationCodeRestObject struct {
	Batting        *bool   `json:"batting,omitempty"`
	Code           *string `json:"code,omitempty"`
	Copyright      *string `json:"copyright,omitempty"`
	Description    *string `json:"description,omitempty"`
	Fielding       *bool   `json:"fielding,omitempty"`
	NavigationMenu *string `json:"navigationMenu,omitempty"`
	Pitching       *bool   `json:"pitching,omitempty"`
	SortOrder      *int32  `json:"sortOrder,omitempty"`
	Team           *bool   `json:"team,omitempty"`
}

// SkeletalDataRestObject defines model for SkeletalDataRestObject.
type SkeletalDataRestObject struct {
	Copyright     *string            `json:"copyright,omitempty"`
	Frames        *[]FrameRestObject `json:"frames,omitempty"`
	JointMetaData *map[string]string `json:"jointMetaData,omitempty"`
	System        *SystemRestObject  `json:"system,omitempty"`
}

// SkeletalDataWrapperRestObject defines model for SkeletalDataWrapperRestObject.
type SkeletalDataWrapperRestObject struct {
	Copyright    *string                 `json:"copyright,omitempty"`
	SkeletalData *SkeletalDataRestObject `json:"skeletalData,omitempty"`
}

// SkeletalFileData defines model for SkeletalFileData.
type SkeletalFileData struct {
	Copyright *string   `json:"copyright,omitempty"`
	FileNames *[]string `json:"fileNames,omitempty"`
}

// SkeletonRestObject defines model for SkeletonRestObject.
type SkeletonRestObject struct {
	Copyright *string             `json:"copyright,omitempty"`
	Settings  *SettingsRestObject `json:"settings,omitempty"`
}

// SocialMediaInfo defines model for SocialMediaInfo.
type SocialMediaInfo struct {
	Facebook   *[]string `json:"facebook,omitempty"`
	Googleplus *[]string `json:"googleplus,omitempty"`
	Hashtags   *[]string `json:"hashtags,omitempty"`
	Instagram  *[]string `json:"instagram,omitempty"`
	Periscope  *[]string `json:"periscope,omitempty"`
	Pinterest  *[]string `json:"pinterest,omitempty"`
	Snapchat   *[]string `json:"snapchat,omitempty"`
	Tumblr     *[]string `json:"tumblr,omitempty"`
	Twitter    *[]string `json:"twitter,omitempty"`
	Vine       *[]string `json:"vine,omitempty"`
	Website    *[]string `json:"website,omitempty"`
	Youtube    *[]string `json:"youtube,omitempty"`
}

// SocialMediaRestObject defines model for SocialMediaRestObject.
type SocialMediaRestObject struct {
	Copyright  *string   `json:"copyright,omitempty"`
	Facebook   *[]string `json:"facebook,omitempty"`
	Googleplus *[]string `json:"googleplus,omitempty"`
	Hashtags   *[]string `json:"hashtags,omitempty"`
	Instagram  *[]string `json:"instagram,omitempty"`
	Periscope  *[]string `json:"periscope,omitempty"`
	Pinterest  *[]string `json:"pinterest,omitempty"`
	Snapchat   *[]string `json:"snapchat,omitempty"`
	Tumblr     *[]string `json:"tumblr,omitempty"`
	Twitter    *[]string `json:"twitter,omitempty"`
	Vine       *[]string `json:"vine,omitempty"`
	Website    *[]string `json:"website,omitempty"`
	Youtube    *[]string `json:"youtube,omitempty"`
}

// SortOrderEnum defines model for SortOrderEnum.
type SortOrderEnum string

// Split defines model for Split.
type Split struct {
	Batter    *string `json:"batter,omitempty"`
	Copyright *string `json:"copyright,omitempty"`
	MenOnBase *string `json:"menOnBase,omitempty"`
	Pitcher   *string `json:"pitcher,omitempty"`
}

// Sport defines model for Sport.
type Sport struct {
	Abbreviation             *string                            `json:"abbreviation,omitempty"`
	ActiveStatus             *string                            `json:"activeStatus,omitempty"`
	Affiliated               *bool                              `json:"affiliated,omitempty"`
	Code                     *string                            `json:"code,omitempty"`
	DeviceProperties         *JsonNode                          `json:"deviceProperties,omitempty"`
	HydratedDeviceProperties *map[string]map[string]interface{} `json:"hydratedDeviceProperties,omitempty"`
	HydratedRuleSettings     *map[string]map[string]interface{} `json:"hydratedRuleSettings,omitempty"`
	HydratedSeason           *map[string]map[string]interface{} `json:"hydratedSeason,omitempty"`
	Id                       *int32                             `json:"id,omitempty"`
	Name                     *string                            `json:"name,omitempty"`
	RequestingUserRole       *Role                              `json:"requestingUserRole,omitempty"`
	RuleSettings             *[]RuleSettings                    `json:"ruleSettings,omitempty"`
	SeasonDateInfo           *Season                            `json:"seasonDateInfo,omitempty"`
	SeasonState              *string                            `json:"seasonState,omitempty"`
	SortOrder                *int32                             `json:"sortOrder,omitempty"`
	SportActive              *bool                              `json:"sportActive,omitempty"`
	UserPrivileges           *[]Privilege                       `json:"userPrivileges,omitempty"`
}

// SportActiveStatusEnum defines model for SportActiveStatusEnum.
type SportActiveStatusEnum string

// SportRestObject defines model for SportRestObject.
type SportRestObject struct {
	Abbreviation     *string                   `json:"abbreviation,omitempty"`
	ActiveStatus     *bool                     `json:"activeStatus,omitempty"`
	Code             *string                   `json:"code,omitempty"`
	Copyright        *string                   `json:"copyright,omitempty"`
	DeviceProperties *JsonNode                 `json:"deviceProperties,omitempty"`
	Hydrations       *[]string                 `json:"hydrations,omitempty"`
	Id               *int32                    `json:"id,omitempty"`
	IsAffiliated     *bool                     `json:"isAffiliated,omitempty"`
	Link             *string                   `json:"link,omitempty"`
	Name             *string                   `json:"name,omitempty"`
	RuleSettings     *[]RuleSettingsRestObject `json:"ruleSettings,omitempty"`
	SeasonDateInfo   *SeasonRestObject         `json:"seasonDateInfo,omitempty"`
	SeasonState      *string                   `json:"seasonState,omitempty"`
	SortOrder        *int32                    `json:"sortOrder,omitempty"`
}

// SportTypeEnum defines model for SportTypeEnum.
type SportTypeEnum string

// SportsRestObject defines model for SportsRestObject.
type SportsRestObject struct {
	Copyright *string            `json:"copyright,omitempty"`
	Sports    *[]SportRestObject `json:"sports,omitempty"`
}

// StandingsOdds defines model for StandingsOdds.
type StandingsOdds struct {
	DivisionOdds *float64 `json:"divisionOdds,omitempty"`
	PlayoffOdds  *float64 `json:"playoffOdds,omitempty"`
	WildcardOdds *float64 `json:"wildcardOdds,omitempty"`
}

// StandingsRestObject defines model for StandingsRestObject.
type StandingsRestObject struct {
	Copyright   *string                                   `json:"copyright,omitempty"`
	LastUpdated *time.Time                                `json:"lastUpdated,omitempty"`
	Records     *[]TeamStandingsRecordContainerRestObject `json:"records,omitempty"`
}

// StandingsType defines model for StandingsType.
type StandingsType string

// StartEndData defines model for StartEndData.
type StartEndData struct {
	Bearing    *float64     `json:"bearing,omitempty"`
	Confidence *string      `json:"confidence,omitempty"`
	Distance   *float64     `json:"distance,omitempty"`
	Position   *Coordinates `json:"position,omitempty"`
	Speed      *float64     `json:"speed,omitempty"`
	Time       *float64     `json:"time,omitempty"`
	Velocity   *Coordinates `json:"velocity,omitempty"`
}

// StartEndDataRestObject defines model for StartEndDataRestObject.
type StartEndDataRestObject struct {
	Bearing    *float64               `json:"bearing,omitempty"`
	Confidence *string                `json:"confidence,omitempty"`
	Copyright  *string                `json:"copyright,omitempty"`
	Distance   *float64               `json:"distance,omitempty"`
	Position   *CoordinatesRestObject `json:"position,omitempty"`
	Speed      *float64               `json:"speed,omitempty"`
	Time       *float64               `json:"time,omitempty"`
	Velocity   *CoordinatesRestObject `json:"velocity,omitempty"`
}

// StatContainer defines model for StatContainer.
type StatContainer struct {
	Disclaimers          *[]string                          `json:"disclaimers,omitempty"`
	Exemptions           *[]PlayerListPerson                `json:"exemptions,omitempty"`
	GameType             *GameTypeEnum                      `json:"gameType,omitempty"`
	Group                *StatGroup                         `json:"group,omitempty"`
	Parameters           *map[string]map[string]interface{} `json:"parameters,omitempty"`
	Player               *BaseballPerson                    `json:"player,omitempty"`
	PlayerPool           *PlayerPoolEnum                    `json:"playerPool,omitempty"`
	Season               *string                            `json:"season,omitempty"`
	Splits               *[]StatSplits                      `json:"splits,omitempty"`
	SplitsTiedWithLimit  *[]StatSplits                      `json:"splitsTiedWithLimit,omitempty"`
	SplitsTiedWithOffset *[]StatSplits                      `json:"splitsTiedWithOffset,omitempty"`
	Sport                *Sport                             `json:"sport,omitempty"`
	Stats                *StatData                          `json:"stats,omitempty"`
	Team                 *BaseballTeam                      `json:"team,omitempty"`
	TotalSplits          *int32                             `json:"totalSplits,omitempty"`
	TotalSplitsIfNotSet  *int32                             `json:"totalSplitsIfNotSet,omitempty"`
	Type                 *StatType                          `json:"type,omitempty"`
}

// StatContainerRestObject defines model for StatContainerRestObject.
type StatContainerRestObject struct {
	Copyright            *string                            `json:"copyright,omitempty"`
	Disclaimers          *[]string                          `json:"disclaimers,omitempty"`
	Exemptions           *[]StatExemptionRestObject         `json:"exemptions,omitempty"`
	GameType             *GameTypeEnum                      `json:"gameType,omitempty"`
	Group                *StatGroup                         `json:"group,omitempty"`
	Parameters           *map[string]map[string]interface{} `json:"parameters,omitempty"`
	Player               *BaseballPersonRestObject          `json:"player,omitempty"`
	PlayerPool           *PlayerPoolEnum                    `json:"playerPool,omitempty"`
	Season               *string                            `json:"season,omitempty"`
	Splits               *[]StatSplitsRestObject            `json:"splits,omitempty"`
	SplitsTiedWithLimit  *[]StatSplitsRestObject            `json:"splitsTiedWithLimit,omitempty"`
	SplitsTiedWithOffset *[]StatSplitsRestObject            `json:"splitsTiedWithOffset,omitempty"`
	Sport                *SportRestObject                   `json:"sport,omitempty"`
	Stats                *StatDataRestObject                `json:"stats,omitempty"`
	Team                 *BaseballTeamRestObject            `json:"team,omitempty"`
	TotalSplits          *int32                             `json:"totalSplits,omitempty"`
	Type                 *StatType                          `json:"type,omitempty"`
}

// StatData defines model for StatData.
type StatData struct {
	Note               *string            `json:"note,omitempty"`
	RequestingUserRole *Role              `json:"requestingUserRole,omitempty"`
	Summary            *map[string]string `json:"summary,omitempty"`
	UserPrivileges     *[]Privilege       `json:"userPrivileges,omitempty"`
}

// StatDataRestObject defines model for StatDataRestObject.
type StatDataRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
	Note      *string `json:"note,omitempty"`
	Summary   *string `json:"summary,omitempty"`
}

// StatExemptionRestObject defines model for StatExemptionRestObject.
type StatExemptionRestObject struct {
	Copyright     *string                   `json:"copyright,omitempty"`
	ExemptionId   *string                   `json:"exemptionId,omitempty"`
	ExemptionName *string                   `json:"exemptionName,omitempty"`
	Player        *BaseballPersonRestObject `json:"player,omitempty"`
}

// StatField defines model for StatField.
type StatField string

// StatFields defines model for StatFields.
type StatFields struct {
	Advanced  *bool   `json:"advanced,omitempty"`
	Copyright *string `json:"copyright,omitempty"`
	Expected  *bool   `json:"expected,omitempty"`
	Standard  *bool   `json:"standard,omitempty"`
	Tracking  *bool   `json:"tracking,omitempty"`
}

// StatGroup defines model for StatGroup.
type StatGroup string

// StatSearchConfigRestObject defines model for StatSearchConfigRestObject.
type StatSearchConfigRestObject struct {
	Aggregations     *[]AggregateSortTypeRestObject      `json:"aggregations,omitempty"`
	CompareOverTypes *[]StatSearchGroupByRestObject      `json:"compareOverTypes,omitempty"`
	FilterLevels     *[]FilterLevelEnumRestObject        `json:"filterLevels,omitempty"`
	GroupByTypes     *[]StatSearchGroupByRestObject      `json:"groupByTypes,omitempty"`
	Parameters       *[]StatSearchParamRestObject        `json:"parameters,omitempty"`
	PersonFilters    *[]StatSearchPersonFilterRestObject `json:"personFilters,omitempty"`
	SituationCodes   *[]StatSearchSitCodeRestObject      `json:"situationCodes,omitempty"`
	Stats            *[]StatSearchStatRestObject         `json:"stats,omitempty"`
}

// StatSearchGroupByRestObject defines model for StatSearchGroupByRestObject.
type StatSearchGroupByRestObject struct {
	Catching    *bool   `json:"catching,omitempty"`
	Code        *string `json:"code,omitempty"`
	Copyright   *string `json:"copyright,omitempty"`
	Description *string `json:"description,omitempty"`
	Fielding    *bool   `json:"fielding,omitempty"`
	FilterLevel *string `json:"filterLevel,omitempty"`
	Hitting     *bool   `json:"hitting,omitempty"`
	Pitching    *bool   `json:"pitching,omitempty"`
	Running     *bool   `json:"running,omitempty"`
}

// StatSearchParamRestObject defines model for StatSearchParamRestObject.
type StatSearchParamRestObject struct {
	Catching    *bool   `json:"catching,omitempty"`
	Code        *string `json:"code,omitempty"`
	Copyright   *string `json:"copyright,omitempty"`
	Fielding    *bool   `json:"fielding,omitempty"`
	FilterLevel *string `json:"filterLevel,omitempty"`
	Hitting     *bool   `json:"hitting,omitempty"`
	Pitching    *bool   `json:"pitching,omitempty"`
	Running     *bool   `json:"running,omitempty"`
}

// StatSearchPersonFilterRestObject defines model for StatSearchPersonFilterRestObject.
type StatSearchPersonFilterRestObject struct {
	Copyright            *string                      `json:"copyright,omitempty"`
	Name                 *string                      `json:"name,omitempty"`
	PersonStatGroup      *[]PersonStatGroupRestObject `json:"personStatGroup,omitempty"`
	PrimaryFilterLevel   *string                      `json:"primaryFilterLevel,omitempty"`
	SecondaryFilterLevel *string                      `json:"secondaryFilterLevel,omitempty"`
}

// StatSearchSitCodeRestObject defines model for StatSearchSitCodeRestObject.
type StatSearchSitCodeRestObject struct {
	Catching       *bool   `json:"catching,omitempty"`
	Category       *string `json:"category,omitempty"`
	Copyright      *string `json:"copyright,omitempty"`
	Description    *string `json:"description,omitempty"`
	Fielding       *bool   `json:"fielding,omitempty"`
	Hitting        *bool   `json:"hitting,omitempty"`
	NavigationMenu *string `json:"navigationMenu,omitempty"`
	Pitching       *bool   `json:"pitching,omitempty"`
	Running        *bool   `json:"running,omitempty"`
	SitCode        *string `json:"sitCode,omitempty"`
}

// StatSearchStatGroupRestObject defines model for StatSearchStatGroupRestObject.
type StatSearchStatGroupRestObject struct {
	Catching  *bool   `json:"catching,omitempty"`
	Copyright *string `json:"copyright,omitempty"`
	Fielding  *bool   `json:"fielding,omitempty"`
	Hitting   *bool   `json:"hitting,omitempty"`
	Pitching  *bool   `json:"pitching,omitempty"`
	Running   *bool   `json:"running,omitempty"`
}

// StatSearchStatRestObject defines model for StatSearchStatRestObject.
type StatSearchStatRestObject struct {
	Abbreviation   *string       `json:"abbreviation,omitempty"`
	Aggregation    *string       `json:"aggregation,omitempty"`
	Copyright      *string       `json:"copyright,omitempty"`
	Decimals       *int32        `json:"decimals,omitempty"`
	Description    *string       `json:"description,omitempty"`
	FilterLevels   *FilterLevels `json:"filterLevels,omitempty"`
	IsCounting     *bool         `json:"isCounting,omitempty"`
	IsInstanceStat *bool         `json:"isInstanceStat,omitempty"`
	SortOrder      *string       `json:"sortOrder,omitempty"`
	SortStat       *string       `json:"sortStat,omitempty"`
	StatFields     *StatFields   `json:"statFields,omitempty"`
	StatGroup      *string       `json:"statGroup,omitempty"`
	Units          *string       `json:"units,omitempty"`
}

// StatSplits defines model for StatSplits.
type StatSplits struct {
	AwayTeam           *BaseballTeam         `json:"awayTeam,omitempty"`
	Date               *openapi_types.Date   `json:"date,omitempty"`
	DayOfTheWeek       *int32                `json:"dayOfTheWeek,omitempty"`
	Exemption          *PlayerListPerson     `json:"exemption,omitempty"`
	Game               *BaseballScheduleItem `json:"game,omitempty"`
	GameInnings        *int32                `json:"gameInnings,omitempty"`
	GameNumber         *int32                `json:"gameNumber,omitempty"`
	GamePk             *int32                `json:"gamePk,omitempty"`
	GameType           *GameTypeEnum         `json:"gameType,omitempty"`
	Group              *StatGroup            `json:"group,omitempty"`
	HomeTeam           *BaseballTeam         `json:"homeTeam,omitempty"`
	IsHome             *bool                 `json:"isHome,omitempty"`
	IsWin              *bool                 `json:"isWin,omitempty"`
	LastDatePlayed     *openapi_types.Date   `json:"lastDatePlayed,omitempty"`
	League             *League               `json:"league,omitempty"`
	Month              *int32                `json:"month,omitempty"`
	NumLeagues         *int32                `json:"numLeagues,omitempty"`
	NumOccurrences     *int32                `json:"numOccurrences,omitempty"`
	NumTeams           *int32                `json:"numTeams,omitempty"`
	Opponent           *BaseballTeam         `json:"opponent,omitempty"`
	OpposingConference *Conference           `json:"opposingConference,omitempty"`
	OpposingDivision   *Division             `json:"opposingDivision,omitempty"`
	Player             *BaseballPerson       `json:"player,omitempty"`
	Position           *BaseballPosition     `json:"position,omitempty"`
	Rank               *int32                `json:"rank,omitempty"`
	RequestingUserRole *Role                 `json:"requestingUserRole,omitempty"`
	Season             *string               `json:"season,omitempty"`
	Split              *DynamicLookupEnum    `json:"split,omitempty"`
	Sport              *Sport                `json:"sport,omitempty"`
	Stat               *StatData             `json:"stat,omitempty"`
	Stats              *GroupedStatData      `json:"stats,omitempty"`
	Team               *BaseballTeam         `json:"team,omitempty"`
	Type               *StatType             `json:"type,omitempty"`
	UserPrivileges     *[]Privilege          `json:"userPrivileges,omitempty"`
	Venue              *Venue                `json:"venue,omitempty"`
}

// StatSplitsRestObject defines model for StatSplitsRestObject.
type StatSplitsRestObject struct {
	AwayTeam           *BaseballTeamRestObject         `json:"awayTeam,omitempty"`
	Copyright          *string                         `json:"copyright,omitempty"`
	Date               *openapi_types.Date             `json:"date,omitempty"`
	DayOfWeek          *int32                          `json:"dayOfWeek,omitempty"`
	Exemption          *StatExemptionRestObject        `json:"exemption,omitempty"`
	Game               *BaseballScheduleItemRestObject `json:"game,omitempty"`
	GameType           *string                         `json:"gameType,omitempty"`
	Group              *string                         `json:"group,omitempty"`
	HomeTeam           *BaseballTeamRestObject         `json:"homeTeam,omitempty"`
	IsHome             *bool                           `json:"isHome,omitempty"`
	IsWin              *bool                           `json:"isWin,omitempty"`
	League             *LeagueRestObject               `json:"league,omitempty"`
	Month              *int32                          `json:"month,omitempty"`
	NumLeagues         *int32                          `json:"numLeagues,omitempty"`
	NumOccurrences     *int32                          `json:"numOccurrences,omitempty"`
	NumTeams           *int32                          `json:"numTeams,omitempty"`
	Opponent           *BaseballTeamRestObject         `json:"opponent,omitempty"`
	OpponentConference *ConferenceRestObject           `json:"opponentConference,omitempty"`
	OpponentDivision   *DivisionRestObject             `json:"opponentDivision,omitempty"`
	Player             *BaseballPersonRestObject       `json:"player,omitempty"`
	Rank               *int32                          `json:"rank,omitempty"`
	Season             *string                         `json:"season,omitempty"`
	Split              *DynamicEnumRestObject          `json:"split,omitempty"`
	Sport              *SportRestObject                `json:"sport,omitempty"`
	Stat               *StatDataRestObject             `json:"stat,omitempty"`
	Stats              *GroupedStatDataRestObject      `json:"stats,omitempty"`
	Team               *BaseballTeamRestObject         `json:"team,omitempty"`
	Type               *string                         `json:"type,omitempty"`
	Venue              *VenueRestObject                `json:"venue,omitempty"`
}

// StatType defines model for StatType.
type StatType string

// StatcastPositionRestObject defines model for StatcastPositionRestObject.
type StatcastPositionRestObject struct {
	Copyright   *string `json:"copyright,omitempty"`
	Description *string `json:"description,omitempty"`
	PositionId  *int32  `json:"positionId,omitempty"`
}

// Statistic defines model for Statistic.
type Statistic struct {
	Category         *string `json:"category,omitempty"`
	IsStandardStatus *bool   `json:"isStandardStatus,omitempty"`
	IsStatcastStatus *bool   `json:"isStatcastStatus,omitempty"`
	SortOrder        *int32  `json:"sortOrder,omitempty"`
	StatisticDesc    *string `json:"statisticDesc,omitempty"`
	StatisticId      *int32  `json:"statisticId,omitempty"`
	StatisticText    *string `json:"statisticText,omitempty"`
}

// Stats defines model for Stats.
type Stats struct {
	AllStats *[]StatContainer `json:"allStats,omitempty"`
}

// StatsRestObject defines model for StatsRestObject.
type StatsRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
}

// StatusFlags defines model for StatusFlags.
type StatusFlags struct {
	IsAllStarGame               *bool `json:"isAllStarGame,omitempty"`
	IsCancelled                 *bool `json:"isCancelled,omitempty"`
	IsChampionshipSeries        *bool `json:"isChampionshipSeries,omitempty"`
	IsClassicDoubleHeader       *bool `json:"isClassicDoubleHeader,omitempty"`
	IsCompletedEarly            *bool `json:"isCompletedEarly,omitempty"`
	IsDelayed                   *bool `json:"isDelayed,omitempty"`
	IsDivisionSeries            *bool `json:"isDivisionSeries,omitempty"`
	IsDoubleHeader              *bool `json:"isDoubleHeader,omitempty"`
	IsExhibition                *bool `json:"isExhibition,omitempty"`
	IsFinal                     *bool `json:"isFinal,omitempty"`
	IsForfeit                   *bool `json:"isForfeit,omitempty"`
	IsFreeGame                  *bool `json:"isFreeGame,omitempty"`
	IsGameOver                  *bool `json:"isGameOver,omitempty"`
	IsInGamDelay                *bool `json:"isInGamDelay,omitempty"`
	IsInstantReplay             *bool `json:"isInstantReplay,omitempty"`
	IsLive                      *bool `json:"isLive,omitempty"`
	IsManagerChallenge          *bool `json:"isManagerChallenge,omitempty"`
	IsNonDoubleHeaderTBD        *bool `json:"isNonDoubleHeaderTBD,omitempty"`
	IsPostSeason                *bool `json:"isPostSeason,omitempty"`
	IsPostSeasonReady           *bool `json:"isPostSeasonReady,omitempty"`
	IsPostponed                 *bool `json:"isPostponed,omitempty"`
	IsPreGameDelay              *bool `json:"isPreGameDelay,omitempty"`
	IsPreview                   *bool `json:"isPreview,omitempty"`
	IsSplitTicketDoubleHeader   *bool `json:"isSplitTicketDoubleHeader,omitempty"`
	IsSpring                    *bool `json:"isSpring,omitempty"`
	IsSuspended                 *bool `json:"isSuspended,omitempty"`
	IsSuspendedOnDate           *bool `json:"isSuspendedOnDate,omitempty"`
	IsSuspendedResumptionOnDate *bool `json:"isSuspendedResumptionOnDate,omitempty"`
	IsTbd                       *bool `json:"isTbd,omitempty"`
	IsTieBreaker                *bool `json:"isTieBreaker,omitempty"`
	IsUmpireReview              *bool `json:"isUmpireReview,omitempty"`
	IsWarmup                    *bool `json:"isWarmup,omitempty"`
	IsWildCard                  *bool `json:"isWildCard,omitempty"`
	IsWorldSeries               *bool `json:"isWorldSeries,omitempty"`
}

// StatusFlagsRestObject defines model for StatusFlagsRestObject.
type StatusFlagsRestObject struct {
	Copyright                   *string `json:"copyright,omitempty"`
	IsAllStarGame               *bool   `json:"isAllStarGame,omitempty"`
	IsCancelled                 *bool   `json:"isCancelled,omitempty"`
	IsChampionshopSeries        *bool   `json:"isChampionshopSeries,omitempty"`
	IsClassicDoubleHeader       *bool   `json:"isClassicDoubleHeader,omitempty"`
	IsCompletedEarly            *bool   `json:"isCompletedEarly,omitempty"`
	IsDelayed                   *bool   `json:"isDelayed,omitempty"`
	IsDivisionSeries            *bool   `json:"isDivisionSeries,omitempty"`
	IsDoubleHeader              *bool   `json:"isDoubleHeader,omitempty"`
	IsExhibition                *bool   `json:"isExhibition,omitempty"`
	IsFinal                     *bool   `json:"isFinal,omitempty"`
	IsForfeit                   *bool   `json:"isForfeit,omitempty"`
	IsFreeGame                  *bool   `json:"isFreeGame,omitempty"`
	IsGameOver                  *bool   `json:"isGameOver,omitempty"`
	IsInGameDelay               *bool   `json:"isInGameDelay,omitempty"`
	IsInstantReplay             *bool   `json:"isInstantReplay,omitempty"`
	IsLive                      *bool   `json:"isLive,omitempty"`
	IsManagerChallenge          *bool   `json:"isManagerChallenge,omitempty"`
	IsNonDoubleHeaderTBD        *bool   `json:"isNonDoubleHeaderTBD,omitempty"`
	IsPostSeason                *bool   `json:"isPostSeason,omitempty"`
	IsPostSeasonReady           *bool   `json:"isPostSeasonReady,omitempty"`
	IsPostponed                 *bool   `json:"isPostponed,omitempty"`
	IsPreGameDelay              *bool   `json:"isPreGameDelay,omitempty"`
	IsPreview                   *bool   `json:"isPreview,omitempty"`
	IsSplitTicketDoubleHeader   *bool   `json:"isSplitTicketDoubleHeader,omitempty"`
	IsSpring                    *bool   `json:"isSpring,omitempty"`
	IsSuspended                 *bool   `json:"isSuspended,omitempty"`
	IsSuspendedOnDate           *bool   `json:"isSuspendedOnDate,omitempty"`
	IsSuspendedResumptionOnDate *bool   `json:"isSuspendedResumptionOnDate,omitempty"`
	IsTBD                       *bool   `json:"isTBD,omitempty"`
	IsTieBreaker                *bool   `json:"isTieBreaker,omitempty"`
	IsUmpireReview              *bool   `json:"isUmpireReview,omitempty"`
	IsWarmup                    *bool   `json:"isWarmup,omitempty"`
	IsWildCard                  *bool   `json:"isWildCard,omitempty"`
	IsWorldSeries               *bool   `json:"isWorldSeries,omitempty"`
}

// StreakLevelEnum defines model for StreakLevelEnum.
type StreakLevelEnum string

// StreakRestObject defines model for StreakRestObject.
type StreakRestObject struct {
	Copyright    *string `json:"copyright,omitempty"`
	StreakCode   *string `json:"streakCode,omitempty"`
	StreakNumber *int32  `json:"streakNumber,omitempty"`
	StreakType   *string `json:"streakType,omitempty"`
}

// StreakSpanEnum defines model for StreakSpanEnum.
type StreakSpanEnum string

// StreakStatEnum defines model for StreakStatEnum.
type StreakStatEnum string

// StreaksContainerRestObject defines model for StreaksContainerRestObject.
type StreaksContainerRestObject struct {
	Copyright            *string                            `json:"copyright,omitempty"`
	Disclaimers          *[]string                          `json:"disclaimers,omitempty"`
	Exemptions           *[]StatExemptionRestObject         `json:"exemptions,omitempty"`
	GameType             *GameTypeEnum                      `json:"gameType,omitempty"`
	Group                *StatGroup                         `json:"group,omitempty"`
	Parameters           *map[string]map[string]interface{} `json:"parameters,omitempty"`
	Player               *BaseballPersonRestObject          `json:"player,omitempty"`
	PlayerPool           *PlayerPoolEnum                    `json:"playerPool,omitempty"`
	Season               *string                            `json:"season,omitempty"`
	Splits               *[]StatSplitsRestObject            `json:"splits,omitempty"`
	SplitsTiedWithLimit  *[]StatSplitsRestObject            `json:"splitsTiedWithLimit,omitempty"`
	SplitsTiedWithOffset *[]StatSplitsRestObject            `json:"splitsTiedWithOffset,omitempty"`
	Sport                *SportRestObject                   `json:"sport,omitempty"`
	Stats                *StatDataRestObject                `json:"stats,omitempty"`
	StreakStat           *StreakStatEnum                    `json:"streakStat,omitempty"`
	Team                 *BaseballTeamRestObject            `json:"team,omitempty"`
	TotalSplits          *int32                             `json:"totalSplits,omitempty"`
	Type                 *StatType                          `json:"type,omitempty"`
}

// StreaksWrapperRestObject defines model for StreaksWrapperRestObject.
type StreaksWrapperRestObject struct {
	Copyright *string                       `json:"copyright,omitempty"`
	Stats     *[]StreaksContainerRestObject `json:"stats,omitempty"`
}

// SystemRestObject defines model for SystemRestObject.
type SystemRestObject struct {
	Copyright *string             `json:"copyright,omitempty"`
	Skeleton  *SkeletonRestObject `json:"skeleton,omitempty"`
}

// TeamActiveStatusEnum defines model for TeamActiveStatusEnum.
type TeamActiveStatusEnum string

// TeamContentCms defines model for TeamContentCms.
type TeamContentCms struct {
	Home     *JsonNode `json:"home,omitempty"`
	Sections *JsonNode `json:"sections,omitempty"`
}

// TeamDesignationEnum defines model for TeamDesignationEnum.
type TeamDesignationEnum string

// TeamInfo defines model for TeamInfo.
type TeamInfo struct {
	Copyright  *string                 `json:"copyright,omitempty"`
	Errors     *int32                  `json:"errors,omitempty"`
	Hits       *int32                  `json:"hits,omitempty"`
	IsWinner   *bool                   `json:"isWinner,omitempty"`
	LeftOnBase *int32                  `json:"leftOnBase,omitempty"`
	Runs       *int32                  `json:"runs,omitempty"`
	Team       *BaseballTeamRestObject `json:"team,omitempty"`
}

// TeamLeaderContainerRestObject defines model for TeamLeaderContainerRestObject.
type TeamLeaderContainerRestObject struct {
	Copyright   *string              `json:"copyright,omitempty"`
	TeamLeaders *[]LeadersRestObject `json:"teamLeaders,omitempty"`
}

// TeamPlayoffs defines model for TeamPlayoffs.
type TeamPlayoffs struct {
	InPlayoffs *bool `json:"inPlayoffs,omitempty"`
}

// TeamStandingsRecordContainerRestObject defines model for TeamStandingsRecordContainerRestObject.
type TeamStandingsRecordContainerRestObject struct {
	AggregateRecord *TeamStandingsRecordRestObject   `json:"aggregateRecord,omitempty"`
	Conference      *ConferenceRestObject            `json:"conference,omitempty"`
	Copyright       *string                          `json:"copyright,omitempty"`
	Division        *DivisionRestObject              `json:"division,omitempty"`
	Hydrations      *[]string                        `json:"hydrations,omitempty"`
	LastUpdated     *time.Time                       `json:"lastUpdated,omitempty"`
	League          *LeagueRestObject                `json:"league,omitempty"`
	Organization    *BaseballTeamRestObject          `json:"organization,omitempty"`
	Sport           *SportRestObject                 `json:"sport,omitempty"`
	StandingsType   *string                          `json:"standingsType,omitempty"`
	TeamRecords     *[]TeamStandingsRecordRestObject `json:"teamRecords,omitempty"`
}

// TeamStandingsRecordRestObject defines model for TeamStandingsRecordRestObject.
type TeamStandingsRecordRestObject struct {
	ClinchIndicator       *string                               `json:"clinchIndicator,omitempty"`
	Conference            *Conference                           `json:"conference,omitempty"`
	ConferenceGamesBack   *string                               `json:"conferenceGamesBack,omitempty"`
	ConferenceRank        *string                               `json:"conferenceRank,omitempty"`
	Copyright             *string                               `json:"copyright,omitempty"`
	Division              *Division                             `json:"division,omitempty"`
	DivisionGamesBack     *string                               `json:"divisionGamesBack,omitempty"`
	DivisionRank          *string                               `json:"divisionRank,omitempty"`
	GamesBack             *string                               `json:"gamesBack,omitempty"`
	GamesPlayed           *int32                                `json:"gamesPlayed,omitempty"`
	LastUpdated           *time.Time                            `json:"lastUpdated,omitempty"`
	League                *League                               `json:"league,omitempty"`
	LeagueGamesBack       *string                               `json:"leagueGamesBack,omitempty"`
	LeagueRank            *string                               `json:"leagueRank,omitempty"`
	LeagueRecord          *WinLossRecordRestObject              `json:"leagueRecord,omitempty"`
	Points                *int32                                `json:"points,omitempty"`
	Probabilites          *StandingsOdds                        `json:"probabilites,omitempty"`
	Records               *map[string][]WinLossRecordRestObject `json:"records,omitempty"`
	Season                *string                               `json:"season,omitempty"`
	SportGamesBack        *string                               `json:"sportGamesBack,omitempty"`
	SportRank             *string                               `json:"sportRank,omitempty"`
	SpringLeagueGamesBack *string                               `json:"springLeagueGamesBack,omitempty"`
	SpringLeagueRank      *string                               `json:"springLeagueRank,omitempty"`
	Streak                *StreakRestObject                     `json:"streak,omitempty"`
	Team                  *BaseballTeamRestObject               `json:"team,omitempty"`
	WildCardGamesBack     *string                               `json:"wildCardGamesBack,omitempty"`
	WildCardRank          *string                               `json:"wildCardRank,omitempty"`
}

// TeamStatData defines model for TeamStatData.
type TeamStatData struct {
	AirOuts                      *int32             `json:"airOuts,omitempty"`
	Assists                      *int32             `json:"assists,omitempty"`
	AtBats                       *int32             `json:"atBats,omitempty"`
	Average                      *string            `json:"average,omitempty"`
	BallsInPlay                  *int32             `json:"ballsInPlay,omitempty"`
	BattingOrder                 *string            `json:"battingOrder,omitempty"`
	CatchersInterference         *int32             `json:"catchersInterference,omitempty"`
	CaughtStealing               *int32             `json:"caughtStealing,omitempty"`
	Chances                      *int32             `json:"chances,omitempty"`
	Doubles                      *int32             `json:"doubles,omitempty"`
	FlyHits                      *int32             `json:"flyHits,omitempty"`
	FlyOuts                      *int32             `json:"flyOuts,omitempty"`
	Games                        *int32             `json:"games,omitempty"`
	GamesPlayedOnBothTeams       *int32             `json:"gamesPlayedOnBothTeams,omitempty"`
	GamesStarted                 *int32             `json:"gamesStarted,omitempty"`
	Gidp                         *int32             `json:"gidp,omitempty"`
	GidpOpportunites             *int32             `json:"gidpOpportunites,omitempty"`
	Gitp                         *int32             `json:"gitp,omitempty"`
	GoAo                         *string            `json:"goAo,omitempty"`
	GroundHits                   *int32             `json:"groundHits,omitempty"`
	GroundOuts                   *int32             `json:"groundOuts,omitempty"`
	HitByPitch                   *int32             `json:"hitByPitch,omitempty"`
	Hits                         *int32             `json:"hits,omitempty"`
	HomeRuns                     *int32             `json:"homeRuns,omitempty"`
	IntentionalWalks             *int32             `json:"intentionalWalks,omitempty"`
	LineHits                     *int32             `json:"lineHits,omitempty"`
	LineOuts                     *int32             `json:"lineOuts,omitempty"`
	LossStreak                   *int32             `json:"lossStreak,omitempty"`
	Note                         *string            `json:"note,omitempty"`
	NumberOfPitches              *int32             `json:"numberOfPitches,omitempty"`
	OnBasePercentage             *string            `json:"onBasePercentage,omitempty"`
	OnBasePlusSlugging           *string            `json:"onBasePlusSlugging,omitempty"`
	Outs                         *int32             `json:"outs,omitempty"`
	Pickoffs                     *int32             `json:"pickoffs,omitempty"`
	PitchesPerPlateAppearance    *float64           `json:"pitchesPerPlateAppearance,omitempty"`
	PitchesPerPlateAppearanceStr *string            `json:"pitchesPerPlateAppearanceStr,omitempty"`
	PlateAppearances             *int32             `json:"plateAppearances,omitempty"`
	PopHits                      *int32             `json:"popHits,omitempty"`
	PopOuts                      *int32             `json:"popOuts,omitempty"`
	Putouts                      *int32             `json:"putouts,omitempty"`
	RequestingUserRole           *Role              `json:"requestingUserRole,omitempty"`
	Runs                         *int32             `json:"runs,omitempty"`
	SacBunts                     *int32             `json:"sacBunts,omitempty"`
	SacFlies                     *int32             `json:"sacFlies,omitempty"`
	Singles                      *int32             `json:"singles,omitempty"`
	Slugging                     *string            `json:"slugging,omitempty"`
	StolenBasePercentage         *string            `json:"stolenBasePercentage,omitempty"`
	StolenBasePercentageOrNull   *string            `json:"stolenBasePercentageOrNull,omitempty"`
	StolenBases                  *int32             `json:"stolenBases,omitempty"`
	Streak                       *int32             `json:"streak,omitempty"`
	Strikeouts                   *int32             `json:"strikeouts,omitempty"`
	Summary                      *map[string]string `json:"summary,omitempty"`
	SwingsAndMisses              *int32             `json:"swingsAndMisses,omitempty"`
	TotalBases                   *int32             `json:"totalBases,omitempty"`
	TotalSwings                  *int32             `json:"totalSwings,omitempty"`
	Triples                      *int32             `json:"triples,omitempty"`
	UserPrivileges               *[]Privilege       `json:"userPrivileges,omitempty"`
	Walks                        *int32             `json:"walks,omitempty"`
	WildPitches                  *int32             `json:"wildPitches,omitempty"`
	WinStreak                    *int32             `json:"winStreak,omitempty"`
}

// TeamsRestObject defines model for TeamsRestObject.
type TeamsRestObject struct {
	Copyright *string                   `json:"copyright,omitempty"`
	Teams     *[]BaseballTeamRestObject `json:"teams,omitempty"`
}

// TimeZone defines model for TimeZone.
type TimeZone struct {
	Id               *string `json:"id,omitempty"`
	Offset           *int32  `json:"offset,omitempty"`
	OffsetAtGameTime *int32  `json:"offsetAtGameTime,omitempty"`
	Tz               *string `json:"tz,omitempty"`
}

// TimeZoneRestObject defines model for TimeZoneRestObject.
type TimeZoneRestObject struct {
	Copyright        *string `json:"copyright,omitempty"`
	Id               *string `json:"id,omitempty"`
	Offset           *int32  `json:"offset,omitempty"`
	OffsetAtGameTime *int32  `json:"offsetAtGameTime,omitempty"`
	Tz               *string `json:"tz,omitempty"`
}

// TrackingSoftwareVersionRestObject defines model for TrackingSoftwareVersionRestObject.
type TrackingSoftwareVersionRestObject struct {
	Copyright                            *string `json:"copyright,omitempty"`
	TrackingSoftwareComponentCode        *string `json:"trackingSoftwareComponentCode,omitempty"`
	TrackingSoftwareComponentDesc        *string `json:"trackingSoftwareComponentDesc,omitempty"`
	TrackingSoftwareComponentId          *int32  `json:"trackingSoftwareComponentId,omitempty"`
	TrackingSoftwareComponentText        *string `json:"trackingSoftwareComponentText,omitempty"`
	TrackingSoftwareComponentVersionText *string `json:"trackingSoftwareComponentVersionText,omitempty"`
	TrackingVendorId                     *int32  `json:"trackingVendorId,omitempty"`
	TrackingVersionSoftwareNote          *string `json:"trackingVersionSoftwareNote,omitempty"`
	TrackingVersionSoftwareNoteId        *int32  `json:"trackingVersionSoftwareNoteId,omitempty"`
}

// TrackingSystemOwner defines model for TrackingSystemOwner.
type TrackingSystemOwner string

// TrackingVendor defines model for TrackingVendor.
type TrackingVendor string

// TrackingVendorVersionContainer defines model for TrackingVendorVersionContainer.
type TrackingVendorVersionContainer struct {
	Description *string `json:"description,omitempty"`
	Id          *int32  `json:"id,omitempty"`
	Version     *string `json:"version,omitempty"`
}

// TrackingVersion defines model for TrackingVersion.
type TrackingVersion string

// TrackingVersionRestObject defines model for TrackingVersionRestObject.
type TrackingVersionRestObject struct {
	BatVendor          *TrackingVendorVersionContainer `json:"batVendor,omitempty"`
	BiomechanicsVendor *TrackingVendorVersionContainer `json:"biomechanicsVendor,omitempty"`
	Copyright          *string                         `json:"copyright,omitempty"`
	Description        *string                         `json:"description,omitempty"`
	HitVendor          *TrackingVendorVersionContainer `json:"hitVendor,omitempty"`
	Id                 *int32                          `json:"id,omitempty"`
	Owner              *TrackingSystemOwner            `json:"owner,omitempty"`
	PitchVendor        *TrackingVendorVersionContainer `json:"pitchVendor,omitempty"`
	PlayerVendor       *TrackingVendorVersionContainer `json:"playerVendor,omitempty"`
	SkeletalVendor     *TrackingVendorVersionContainer `json:"skeletalVendor,omitempty"`
}

// Transaction defines model for Transaction.
type Transaction struct {
	Date           *time.Time         `json:"date,omitempty"`
	Description    *string            `json:"description,omitempty"`
	DescriptionMap *map[string]string `json:"descriptionMap,omitempty"`
	EffectiveDate  *time.Time         `json:"effectiveDate,omitempty"`
	FromTeam       *BaseballTeam      `json:"fromTeam,omitempty"`
	Id             *int32             `json:"id,omitempty"`
	IsConditional  *bool              `json:"isConditional,omitempty"`
	Person         *BaseballPerson    `json:"person,omitempty"`
	ResolutionDate *time.Time         `json:"resolutionDate,omitempty"`
	ToTeam         *BaseballTeam      `json:"toTeam,omitempty"`
	Type           *string            `json:"type,omitempty"`
	TypeCode       *string            `json:"typeCode,omitempty"`
	TypeId         *string            `json:"typeId,omitempty"`
}

// TransactionRestObject defines model for TransactionRestObject.
type TransactionRestObject struct {
	Copyright      *string                   `json:"copyright,omitempty"`
	Date           *openapi_types.Date       `json:"date,omitempty"`
	Description    *string                   `json:"description,omitempty"`
	EffectiveDate  *openapi_types.Date       `json:"effectiveDate,omitempty"`
	FromTeam       *BaseballTeamRestObject   `json:"fromTeam,omitempty"`
	Id             *int32                    `json:"id,omitempty"`
	IsConditional  *bool                     `json:"isConditional,omitempty"`
	Person         *BaseballPersonRestObject `json:"person,omitempty"`
	ResolutionDate *openapi_types.Date       `json:"resolutionDate,omitempty"`
	ToTeam         *BaseballTeamRestObject   `json:"toTeam,omitempty"`
	Type           *string                   `json:"type,omitempty"`
	TypeCode       *string                   `json:"typeCode,omitempty"`
	TypeDesc       *string                   `json:"typeDesc,omitempty"`
}

// TransactionsRestObject defines model for TransactionsRestObject.
type TransactionsRestObject struct {
	Copyright    *string                  `json:"copyright,omitempty"`
	Transactions *[]TransactionRestObject `json:"transactions,omitempty"`
}

// UniformAssetTypeRestObject defines model for UniformAssetTypeRestObject.
type UniformAssetTypeRestObject struct {
	Copyright            *string `json:"copyright,omitempty"`
	UniformAssetTypeCode *string `json:"uniformAssetTypeCode,omitempty"`
	UniformAssetTypeDesc *string `json:"uniformAssetTypeDesc,omitempty"`
	UniformAssetTypeId   *int32  `json:"uniformAssetTypeId,omitempty"`
	UniformAssetTypeText *string `json:"uniformAssetTypeText,omitempty"`
}

// UniformRestObject defines model for UniformRestObject.
type UniformRestObject struct {
	Active           *bool                       `json:"active,omitempty"`
	Copyright        *string                     `json:"copyright,omitempty"`
	EndSeason        *string                     `json:"endSeason,omitempty"`
	StartSeason      *string                     `json:"startSeason,omitempty"`
	UniformAssetCode *string                     `json:"uniformAssetCode,omitempty"`
	UniformAssetId   *int32                      `json:"uniformAssetId,omitempty"`
	UniformAssetText *string                     `json:"uniformAssetText,omitempty"`
	UniformAssetType *UniformAssetTypeRestObject `json:"uniformAssetType,omitempty"`
}

// UniformsGameRestObject defines model for UniformsGameRestObject.
type UniformsGameRestObject struct {
	Away      *BaseballTeamUniformRestObject `json:"away,omitempty"`
	Copyright *string                        `json:"copyright,omitempty"`
	GamePk    *int32                         `json:"gamePk,omitempty"`
	Home      *BaseballTeamUniformRestObject `json:"home,omitempty"`
}

// UniformsGamesRestObject defines model for UniformsGamesRestObject.
type UniformsGamesRestObject struct {
	Copyright *string                   `json:"copyright,omitempty"`
	Uniforms  *[]UniformsGameRestObject `json:"uniforms,omitempty"`
}

// UniformsTeamRestObject defines model for UniformsTeamRestObject.
type UniformsTeamRestObject struct {
	Copyright     *string              `json:"copyright,omitempty"`
	TeamId        *int32               `json:"teamId,omitempty"`
	UniformAssets *[]UniformRestObject `json:"uniformAssets,omitempty"`
}

// UniformsTeamsRestObject defines model for UniformsTeamsRestObject.
type UniformsTeamsRestObject struct {
	Copyright *string                   `json:"copyright,omitempty"`
	Uniforms  *[]UniformsTeamRestObject `json:"uniforms,omitempty"`
}

// UsedRemainingRestObject defines model for UsedRemainingRestObject.
type UsedRemainingRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
	Remaining *int32  `json:"remaining,omitempty"`
	Used      *int32  `json:"used,omitempty"`
}

// VendorWeatherForecast defines model for VendorWeatherForecast.
type VendorWeatherForecast struct {
	AdjustedPrecipitationProbability *int32     `json:"adjustedPrecipitationProbability,omitempty"`
	CloudCoverPercentage             *int32     `json:"cloudCoverPercentage,omitempty"`
	Description                      *string    `json:"description,omitempty"`
	Dewpoint                         *float64   `json:"dewpoint,omitempty"`
	ForecastTimestamp                *time.Time `json:"forecastTimestamp,omitempty"`
	GameId                           *int32     `json:"gameId,omitempty"`
	PrecipitationId                  *int32     `json:"precipitationId,omitempty"`
	PrecipitationProbability         *int32     `json:"precipitationProbability,omitempty"`
	PrecipitationRate                *float64   `json:"precipitationRate,omitempty"`
	RelativeHumidity                 *int32     `json:"relativeHumidity,omitempty"`
	SkyConditionIconId               *int32     `json:"skyConditionIconId,omitempty"`
	SnowRate                         *float64   `json:"snowRate,omitempty"`
	SurfacePressure                  *float64   `json:"surfacePressure,omitempty"`
	Temperature                      *float64   `json:"temperature,omitempty"`
	TemperatureFeelsLike             *float64   `json:"temperatureFeelsLike,omitempty"`
	ThunderstormProbability          *int32     `json:"thunderstormProbability,omitempty"`
	WetBulbGlobeTemperature          *float64   `json:"wetBulbGlobeTemperature,omitempty"`
	WetBulbTemperature               *float64   `json:"wetBulbTemperature,omitempty"`
	WindDirectionDegrees             *int32     `json:"windDirectionDegrees,omitempty"`
	WindSpeed                        *float64   `json:"windSpeed,omitempty"`
}

// VendorWeatherForecastRestObject defines model for VendorWeatherForecastRestObject.
type VendorWeatherForecastRestObject struct {
	AdjustedPrecipitationProbability *int32     `json:"adjustedPrecipitationProbability,omitempty"`
	CloudCoverPercentage             *int32     `json:"cloudCoverPercentage,omitempty"`
	Copyright                        *string    `json:"copyright,omitempty"`
	Description                      *string    `json:"description,omitempty"`
	Dewpoint                         *float64   `json:"dewpoint,omitempty"`
	ForecastTimestamp                *time.Time `json:"forecastTimestamp,omitempty"`
	PrecipitationId                  *int32     `json:"precipitationId,omitempty"`
	PrecipitationProbability         *int32     `json:"precipitationProbability,omitempty"`
	PrecipitationRate                *float64   `json:"precipitationRate,omitempty"`
	RelativeHumidity                 *int32     `json:"relativeHumidity,omitempty"`
	SkyConditionIconId               *int32     `json:"skyConditionIconId,omitempty"`
	SnowRate                         *float64   `json:"snowRate,omitempty"`
	SurfacePressure                  *float64   `json:"surfacePressure,omitempty"`
	Temperature                      *float64   `json:"temperature,omitempty"`
	TemperatureFeelsLike             *float64   `json:"temperatureFeelsLike,omitempty"`
	ThunderstormProbability          *int32     `json:"thunderstormProbability,omitempty"`
	WetBulbGlobeTemperature          *float64   `json:"wetBulbGlobeTemperature,omitempty"`
	WetBulbTemperature               *float64   `json:"wetBulbTemperature,omitempty"`
	WindDirectionDegrees             *int32     `json:"windDirectionDegrees,omitempty"`
	WindSpeed                        *float64   `json:"windSpeed,omitempty"`
}

// Venue defines model for Venue.
type Venue struct {
	Active              *bool                 `json:"active,omitempty"`
	AppEnabled          *bool                 `json:"appEnabled,omitempty"`
	City                *string               `json:"city,omitempty"`
	CoachingVideo       *[]MediaSourceType    `json:"coachingVideo,omitempty"`
	FieldInfo           *FieldInfo            `json:"fieldInfo,omitempty"`
	Id                  *int32                `json:"id,omitempty"`
	Location            *Location             `json:"location,omitempty"`
	Menu                *VenueCms             `json:"menu,omitempty"`
	Metadata            *VenueMetadata        `json:"metadata,omitempty"`
	Name                *string               `json:"name,omitempty"`
	NextSchedule        *BaseballSchedule     `json:"nextSchedule,omitempty"`
	ParentVenues        *[]Venue              `json:"parentVenues,omitempty"`
	PreviousSchedule    *BaseballSchedule     `json:"previousSchedule,omitempty"`
	RelatedApplications *[]RelatedApplication `json:"relatedApplications,omitempty"`
	RelatedImages       *[]Image              `json:"relatedImages,omitempty"`
	RelatedVenues       *[]Venue              `json:"relatedVenues,omitempty"`
	RequestingUserRole  *Role                 `json:"requestingUserRole,omitempty"`
	ResidentVenues      *[]Venue              `json:"residentVenues,omitempty"`
	Schedule            *BaseballSchedule     `json:"schedule,omitempty"`
	Season              *string               `json:"season,omitempty"`
	SocialMediaInfo     *SocialMediaInfo      `json:"socialMediaInfo,omitempty"`
	SportType           *SportTypeEnum        `json:"sportType,omitempty"`
	TimeZone            *TimeZone             `json:"timeZone,omitempty"`
	TimeZoneId          *string               `json:"timeZoneId,omitempty"`
	TrackingSystemOwner *TrackingSystemOwner  `json:"trackingSystemOwner,omitempty"`
	TrackingVersion     *TrackingVersion      `json:"trackingVersion,omitempty"`
	UserPrivileges      *[]Privilege          `json:"userPrivileges,omitempty"`
	XrefIds             *[]XrefId             `json:"xrefIds,omitempty"`
}

// VenueCms defines model for VenueCms.
type VenueCms struct {
	Menu *string `json:"menu,omitempty"`
}

// VenueMetadata defines model for VenueMetadata.
type VenueMetadata struct {
	Active    *bool            `json:"active,omitempty"`
	Capacity  *int32           `json:"capacity,omitempty"`
	EndYear   *int32           `json:"endYear,omitempty"`
	StartYear *int32           `json:"startYear,omitempty"`
	Types     *[]VenueTypeEnum `json:"types,omitempty"`
}

// VenueMetadataRestObject defines model for VenueMetadataRestObject.
type VenueMetadataRestObject struct {
	Active    *bool     `json:"active,omitempty"`
	Capacity  *int32    `json:"capacity,omitempty"`
	Copyright *string   `json:"copyright,omitempty"`
	EndYear   *int32    `json:"endYear,omitempty"`
	StartYear *int32    `json:"startYear,omitempty"`
	Types     *[]string `json:"types,omitempty"`
}

// VenueRestObject defines model for VenueRestObject.
type VenueRestObject struct {
	Active              *bool                       `json:"active,omitempty"`
	AppEnabled          *bool                       `json:"appEnabled,omitempty"`
	CoachingVideo       *[]MediaSourceType          `json:"coachingVideo,omitempty"`
	Copyright           *string                     `json:"copyright,omitempty"`
	FieldInfo           *FieldInfoRestObject        `json:"fieldInfo,omitempty"`
	Hydrations          *[]string                   `json:"hydrations,omitempty"`
	Id                  *int32                      `json:"id,omitempty"`
	Images              *map[string]ImageRestObject `json:"images,omitempty"`
	Link                *string                     `json:"link,omitempty"`
	Location            *LocationRestObject         `json:"location,omitempty"`
	Menu                *JsonNode                   `json:"menu,omitempty"`
	Metadata            *VenueMetadataRestObject    `json:"metadata,omitempty"`
	Name                *string                     `json:"name,omitempty"`
	NextSchedule        *ScheduleRestObject         `json:"nextSchedule,omitempty"`
	PreviousSchedule    *ScheduleRestObject         `json:"previousSchedule,omitempty"`
	RelatedApplications *[]ApplicationRestObject    `json:"relatedApplications,omitempty"`
	RuleSettings        *[]RuleSettingsRestObject   `json:"ruleSettings,omitempty"`
	Schedule            *ScheduleRestObject         `json:"schedule,omitempty"`
	Season              *string                     `json:"season,omitempty"`
	Social              *SocialMediaRestObject      `json:"social,omitempty"`
	TimeZone            *TimeZoneRestObject         `json:"timeZone,omitempty"`
	TrackingVersion     *TrackingVersionRestObject  `json:"trackingVersion,omitempty"`
	XrefIds             *[]XrefIdRestObject         `json:"xrefIds,omitempty"`
}

// VenueTypeEnum defines model for VenueTypeEnum.
type VenueTypeEnum string

// VenuesRestObject defines model for VenuesRestObject.
type VenuesRestObject struct {
	Copyright *string            `json:"copyright,omitempty"`
	Venues    *[]VenueRestObject `json:"venues,omitempty"`
}

// Video defines model for Video.
type Video struct {
	AtBatNumber    *int32     `json:"atBatNumber,omitempty"`
	Date           *time.Time `json:"date,omitempty"`
	PitchNumber    *int32     `json:"pitchNumber,omitempty"`
	PlayId         *string    `json:"playId,omitempty"`
	PlaybackGroups *JsonNode  `json:"playbackGroups,omitempty"`
}

// VideoResolution defines model for VideoResolution.
type VideoResolution string

// VideoResolutionEnumRestObject defines model for VideoResolutionEnumRestObject.
type VideoResolutionEnumRestObject struct {
	Code            *string `json:"code,omitempty"`
	ResolutionFull  *string `json:"resolutionFull,omitempty"`
	ResolutionShort *string `json:"resolutionShort,omitempty"`
}

// ViolationRestObject defines model for ViolationRestObject.
type ViolationRestObject struct {
	Copyright   *string                   `json:"copyright,omitempty"`
	Description *string                   `json:"description,omitempty"`
	Player      *BaseballPersonRestObject `json:"player,omitempty"`
	Subtype     *string                   `json:"subtype,omitempty"`
	Type        *string                   `json:"type,omitempty"`
}

// ViolationTypeRestObject defines model for ViolationTypeRestObject.
type ViolationTypeRestObject struct {
	Copyright         *string `json:"copyright,omitempty"`
	EventType         *string `json:"eventType,omitempty"`
	EventTypeCode     *string `json:"eventTypeCode,omitempty"`
	ParentId          *int32  `json:"parentId,omitempty"`
	ViolationTypeCode *string `json:"violationTypeCode,omitempty"`
	ViolationTypeDesc *string `json:"violationTypeDesc,omitempty"`
	ViolatorCode      *string `json:"violatorCode,omitempty"`
}

// Weather defines model for Weather.
type Weather struct {
	Temperature      *string `json:"temperature,omitempty"`
	WeatherCondition *string `json:"weatherCondition,omitempty"`
	Wind             *string `json:"wind,omitempty"`
}

// WeatherConditionFlagRestObject defines model for WeatherConditionFlagRestObject.
type WeatherConditionFlagRestObject struct {
	Copyright        *string `json:"copyright,omitempty"`
	Foul             *bool   `json:"foul,omitempty"`
	FoulChange       *bool   `json:"foulChange,omitempty"`
	HomeRun          *bool   `json:"homeRun,omitempty"`
	HomeRunChange    *bool   `json:"homeRunChange,omitempty"`
	OffTheWall       *bool   `json:"offTheWall,omitempty"`
	OffTheWallChange *bool   `json:"offTheWallChange,omitempty"`
}

// WeatherConditionsRestObject defines model for WeatherConditionsRestObject.
type WeatherConditionsRestObject struct {
	AnalysedTimeStamp *string `json:"analysedTimeStamp,omitempty"`
	Copyright         *string `json:"copyright,omitempty"`

	// DewPoint The atmospheric temperature below which dew will form.
	DewPoint          *float64 `json:"dewPoint,omitempty"`
	ObservedTimeStamp *string  `json:"observedTimeStamp,omitempty"`

	// Pressure Atmospheric pressure as measured in venue in mm of Hg.
	Pressure *float64 `json:"pressure,omitempty"`

	// RelativeHumidity Humidity as measured in venue in % relative humidity
	RelativeHumidity *float64               `json:"relativeHumidity,omitempty"`
	Temperature      *float64               `json:"temperature,omitempty"`
	Wind             *WeatherWindRestObject `json:"wind,omitempty"`
}

// WeatherContextRestObject defines model for WeatherContextRestObject.
type WeatherContextRestObject struct {
	ConditionType *string `json:"conditionType,omitempty"`
	Copyright     *string `json:"copyright,omitempty"`
}

// WeatherDeviationRestObject defines model for WeatherDeviationRestObject.
type WeatherDeviationRestObject struct {
	Apex       *float64 `json:"apex,omitempty"`
	Copyright  *string  `json:"copyright,omitempty"`
	Distance   *float64 `json:"distance,omitempty"`
	Height     *float64 `json:"height,omitempty"`
	Horizontal *float64 `json:"horizontal,omitempty"`
	Time       *float64 `json:"time,omitempty"`
}

// WeatherDeviationsRestObject defines model for WeatherDeviationsRestObject.
type WeatherDeviationsRestObject struct {
	Copyright *string                 `json:"copyright,omitempty"`
	Hit       *WeatherHitRestObject   `json:"hit,omitempty"`
	Pitch     *WeatherPitchRestObject `json:"pitch,omitempty"`
}

// WeatherFlyballStandard80RestObject defines model for WeatherFlyballStandard80RestObject.
type WeatherFlyballStandard80RestObject struct {
	Copyright  *string                `json:"copyright,omitempty"`
	FieldZones *[]FieldZoneRestObject `json:"fieldZones,omitempty"`
}

// WeatherForecastRestObject defines model for WeatherForecastRestObject.
type WeatherForecastRestObject struct {
	Conditions *WeatherConditionsRestObject `json:"conditions,omitempty"`
	Context    *WeatherContextRestObject    `json:"context,omitempty"`
	Copyright  *string                      `json:"copyright,omitempty"`
	Deviations *WeatherDeviationsRestObject `json:"deviations,omitempty"`
}

// WeatherHitRestObject defines model for WeatherHitRestObject.
type WeatherHitRestObject struct {
	Copyright         *string                             `json:"copyright,omitempty"`
	FlyballStandard80 *WeatherFlyballStandard80RestObject `json:"flyballStandard80,omitempty"`
}

// WeatherHitSegmentActual Hit segment data for the actual batted ball.
type WeatherHitSegmentActual struct {
	Conditions     *WeatherMetricRestObject            `json:"conditions,omitempty"`
	Copyright      *string                             `json:"copyright,omitempty"`
	Deviations     *WeatherDeviationRestObject         `json:"deviations,omitempty"`
	Flags          *WeatherConditionFlagRestObject     `json:"flags,omitempty"`
	LandingData    *LandingDataRestObject              `json:"landingData,omitempty"`
	TrajectoryData *WeatherHitTrajectoryDataRestObject `json:"trajectoryData,omitempty"`
}

// WeatherHitSegmentCalm Hit segment data for the calm scenario. Wind speed is fixed at 0.
type WeatherHitSegmentCalm struct {
	Conditions     *WeatherMetricRestObject            `json:"conditions,omitempty"`
	Copyright      *string                             `json:"copyright,omitempty"`
	Deviations     *WeatherDeviationRestObject         `json:"deviations,omitempty"`
	Flags          *WeatherConditionFlagRestObject     `json:"flags,omitempty"`
	LandingData    *LandingDataRestObject              `json:"landingData,omitempty"`
	TrajectoryData *WeatherHitTrajectoryDataRestObject `json:"trajectoryData,omitempty"`
}

// WeatherHitSegmentRestObject Hit segment data for the indoor scenario. `conditions.pressure`: fixed at 22.92 mm Hg or 1 standard atmosphere. `conditions.relativeHumidity`: fixed at 55%. `conditions.temperature`: fixed at 72 degrees Fahrenheit. `conditions.windDirection`: fixed at 0.
type WeatherHitSegmentRestObject struct {
	Conditions     *WeatherMetricRestObject            `json:"conditions,omitempty"`
	Copyright      *string                             `json:"copyright,omitempty"`
	Deviations     *WeatherDeviationRestObject         `json:"deviations,omitempty"`
	Flags          *WeatherConditionFlagRestObject     `json:"flags,omitempty"`
	LandingData    *LandingDataRestObject              `json:"landingData,omitempty"`
	TrajectoryData *WeatherHitTrajectoryDataRestObject `json:"trajectoryData,omitempty"`
}

// WeatherHitTrajectoryDataRestObject defines model for WeatherHitTrajectoryDataRestObject.
type WeatherHitTrajectoryDataRestObject struct {
	Apex                 *float64                                   `json:"apex,omitempty"`
	Copyright            *string                                    `json:"copyright,omitempty"`
	HitPositionAt110Feet *CoordinatesRestObject                     `json:"hitPositionAt110Feet,omitempty"`
	MaxHeightPosition    *CoordinatesRestObject                     `json:"maxHeightPosition,omitempty"`
	MeasuredTimeInterval *[]float64                                 `json:"measuredTimeInterval,omitempty"`
	ReducedConfidence    *[]string                                  `json:"reducedConfidence,omitempty"`
	TrajectoryConfidence *WeatherTrajectoryConfidenceTypeRestObject `json:"trajectoryConfidence,omitempty"`

	// TrajectoryPolynomialX Polynomial describing x position of the ball's hit trajectory.
	TrajectoryPolynomialX *[]float64 `json:"trajectoryPolynomialX,omitempty"`

	// TrajectoryPolynomialY Polynomial describing y position of the ball's hit trajectory.
	TrajectoryPolynomialY *[]float64 `json:"trajectoryPolynomialY,omitempty"`

	// TrajectoryPolynomialZ Polynomial describing z position of the ball's hit trajectory.
	TrajectoryPolynomialZ *[]float64           `json:"trajectoryPolynomialZ,omitempty"`
	ValidTimeInterval     *[]float64           `json:"validTimeInterval,omitempty"`
	WindSpeed             *WindSpeedRestObject `json:"windSpeed,omitempty"`
}

// WeatherMetricRestObject defines model for WeatherMetricRestObject.
type WeatherMetricRestObject struct {
	Copyright *string `json:"copyright,omitempty"`

	// Pressure Atmospheric pressure in venue in mm Hg, as measured above the venue.
	Pressure *float64 `json:"pressure,omitempty"`

	// RelativeHumidity Relative humidity in venue in %, as measured above the venue.
	RelativeHumidity *float64 `json:"relativeHumidity,omitempty"`

	// Temperature Venue temperature in degrees Fahrenheit.
	Temperature *float64 `json:"temperature,omitempty"`

	// TimeStamp UTC timestamp for atmospheric condition measurements.
	TimeStamp *string                `json:"timeStamp,omitempty"`
	Wind      *WeatherWindRestObject `json:"wind,omitempty"`
}

// WeatherPitchHandRestObject defines model for WeatherPitchHandRestObject.
type WeatherPitchHandRestObject struct {
	Calm      *WeatherDeviationRestObject `json:"calm,omitempty"`
	Copyright *string                     `json:"copyright,omitempty"`
	Indoor    *WeatherDeviationRestObject `json:"indoor,omitempty"`
	PitchHand *PitchHandTypeRestObject    `json:"pitchHand,omitempty"`
}

// WeatherPitchRestObject defines model for WeatherPitchRestObject.
type WeatherPitchRestObject struct {
	Copyright  *string                       `json:"copyright,omitempty"`
	PitchTypes *[]WeatherPitchTypeRestObject `json:"pitchTypes,omitempty"`
}

// WeatherPitchSegmentActual Pitch segment data for the actual pitched ball.
type WeatherPitchSegmentActual struct {
	Conditions     *WeatherMetricRestObject              `json:"conditions,omitempty"`
	Copyright      *string                               `json:"copyright,omitempty"`
	Deviations     *WeatherDeviationRestObject           `json:"deviations,omitempty"`
	LandingData    *LandingDataRestObject                `json:"landingData,omitempty"`
	TrajectoryData *WeatherPitchTrajectoryDataRestObject `json:"trajectoryData,omitempty"`
}

// WeatherPitchSegmentCalm Pitch segment data for the calm scenario. Wind speed is fixed at 0.
type WeatherPitchSegmentCalm struct {
	Conditions     *WeatherMetricRestObject              `json:"conditions,omitempty"`
	Copyright      *string                               `json:"copyright,omitempty"`
	Deviations     *WeatherDeviationRestObject           `json:"deviations,omitempty"`
	LandingData    *LandingDataRestObject                `json:"landingData,omitempty"`
	TrajectoryData *WeatherPitchTrajectoryDataRestObject `json:"trajectoryData,omitempty"`
}

// WeatherPitchSegmentRestObject Pitch segment data for the indoor scenario. `conditions.pressure`: fixed at 22.92 mm Hg or 1 standard atmosphere. `conditions.relativeHumidity`: fixed at 55%. `conditions.temperature`: fixed at 72 degrees Fahrenheit. `conditions.windDirection`: fixed at 0.
type WeatherPitchSegmentRestObject struct {
	Conditions     *WeatherMetricRestObject              `json:"conditions,omitempty"`
	Copyright      *string                               `json:"copyright,omitempty"`
	Deviations     *WeatherDeviationRestObject           `json:"deviations,omitempty"`
	LandingData    *LandingDataRestObject                `json:"landingData,omitempty"`
	TrajectoryData *WeatherPitchTrajectoryDataRestObject `json:"trajectoryData,omitempty"`
}

// WeatherPitchTrajectoryDataRestObject defines model for WeatherPitchTrajectoryDataRestObject.
type WeatherPitchTrajectoryDataRestObject struct {
	Apex                 *float64                                   `json:"apex,omitempty"`
	Copyright            *string                                    `json:"copyright,omitempty"`
	Location             *CoordinatesRestObject                     `json:"location,omitempty"`
	TrajectoryConfidence *WeatherTrajectoryConfidenceTypeRestObject `json:"trajectoryConfidence,omitempty"`

	// TrajectoryPolynomialX Polynomial describing x position of the ball's pitch trajectory.
	TrajectoryPolynomialX *[]float64 `json:"trajectoryPolynomialX,omitempty"`

	// TrajectoryPolynomialY Polynomial describing y position of the ball's pitch trajectory.
	TrajectoryPolynomialY *[]float64 `json:"trajectoryPolynomialY,omitempty"`

	// TrajectoryPolynomialZ Polynomial describing z position of the ball's pitch trajectory.
	TrajectoryPolynomialZ *[]float64           `json:"trajectoryPolynomialZ,omitempty"`
	WindSpeed             *WindSpeedRestObject `json:"windSpeed,omitempty"`
}

// WeatherPitchTypeRestObject defines model for WeatherPitchTypeRestObject.
type WeatherPitchTypeRestObject struct {
	Copyright  *string                       `json:"copyright,omitempty"`
	PitchHands *[]WeatherPitchHandRestObject `json:"pitchHands,omitempty"`
	PitchType  *PitchTypeRestObject          `json:"pitchType,omitempty"`
}

// WeatherPlayRestObject defines model for WeatherPlayRestObject.
type WeatherPlayRestObject struct {
	Copyright *string `json:"copyright,omitempty"`

	// HitSegmentActual Hit segment data for the actual batted ball.
	HitSegmentActual *WeatherHitSegmentActual `json:"hitSegmentActual,omitempty"`

	// HitSegmentCalm Hit segment data for the calm scenario. Wind speed is fixed at 0.
	HitSegmentCalm *WeatherHitSegmentCalm `json:"hitSegmentCalm,omitempty"`

	// HitSegmentIndoor Hit segment data for the indoor scenario. `conditions.pressure`: fixed at 22.92 mm Hg or 1 standard atmosphere. `conditions.relativeHumidity`: fixed at 55%. `conditions.temperature`: fixed at 72 degrees Fahrenheit. `conditions.windDirection`: fixed at 0.
	HitSegmentIndoor *WeatherHitSegmentRestObject `json:"hitSegmentIndoor,omitempty"`

	// PitchSegmentActual Pitch segment data for the actual pitched ball.
	PitchSegmentActual *WeatherPitchSegmentActual `json:"pitchSegmentActual,omitempty"`

	// PitchSegmentCalm Pitch segment data for the calm scenario. Wind speed is fixed at 0.
	PitchSegmentCalm *WeatherPitchSegmentCalm `json:"pitchSegmentCalm,omitempty"`

	// PitchSegmentIndoor Pitch segment data for the indoor scenario. `conditions.pressure`: fixed at 22.92 mm Hg or 1 standard atmosphere. `conditions.relativeHumidity`: fixed at 55%. `conditions.temperature`: fixed at 72 degrees Fahrenheit. `conditions.windDirection`: fixed at 0.
	PitchSegmentIndoor *WeatherPitchSegmentRestObject `json:"pitchSegmentIndoor,omitempty"`
}

// WeatherRestObject defines model for WeatherRestObject.
type WeatherRestObject struct {
	Condition *string `json:"condition,omitempty"`
	Copyright *string `json:"copyright,omitempty"`
	Temp      *string `json:"temp,omitempty"`
	Wind      *string `json:"wind,omitempty"`
}

// WeatherTrajectoryConfidenceTypeRestObject defines model for WeatherTrajectoryConfidenceTypeRestObject.
type WeatherTrajectoryConfidenceTypeRestObject struct {
	Copyright   *string `json:"copyright,omitempty"`
	Description *string `json:"description,omitempty"`
	Value       *string `json:"value,omitempty"`
}

// WeatherWindRestObject defines model for WeatherWindRestObject.
type WeatherWindRestObject struct {
	Copyright *string `json:"copyright,omitempty"`

	// Direction Azimuth direction in degrees from North, of the prevailing wind. wind.direction increases clockwise from North.
	Direction *float64 `json:"direction,omitempty"`

	// Gust Peak transient wind speed in mph.
	Gust *float64 `json:"gust,omitempty"`

	// Speed Prevailing wind speed in mph.
	Speed *float64 `json:"speed,omitempty"`
}

// WeatherWrapperRestObject defines model for WeatherWrapperRestObject.
type WeatherWrapperRestObject struct {
	Copyright *string     `json:"copyright,omitempty"`
	Data      *RestObject `json:"data,omitempty"`
	Units     *JsonNode   `json:"units,omitempty"`
}

// WinLossRecord defines model for WinLossRecord.
type WinLossRecord struct {
	Losses *int32  `json:"losses,omitempty"`
	Ties   *int32  `json:"ties,omitempty"`
	Type   *string `json:"type,omitempty"`
	Wins   *int32  `json:"wins,omitempty"`
}

// WinLossRecordRestObject defines model for WinLossRecordRestObject.
type WinLossRecordRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
	Losses    *int32  `json:"losses,omitempty"`
	Pct       *string `json:"pct,omitempty"`
	Ties      *int32  `json:"ties,omitempty"`
	Type      *string `json:"type,omitempty"`
	Wins      *int32  `json:"wins,omitempty"`
}

// WindSpeedRestObject defines model for WindSpeedRestObject.
type WindSpeedRestObject struct {
	Copyright *string `json:"copyright,omitempty"`

	// Side Mean wind speed calculated at a right angle (transverse) to the trajectory of the ball in the horizontal direction.
	Side *float64 `json:"side,omitempty"`

	// Tail Mean wind speed calculated along the trajectory of the ball. A tail wind is positive and a headwind is negative.
	Tail *float64 `json:"tail,omitempty"`

	// Vertical Mean wind speed component affecting the pitch trajectory in the vertical (z) direction.
	Vertical *float64 `json:"vertical,omitempty"`
}

// XrefId defines model for XrefId.
type XrefId struct {
	Season    *string `json:"season,omitempty"`
	XrefId    *string `json:"xrefId,omitempty"`
	XrefIdTwo *string `json:"xrefIdTwo,omitempty"`
	XrefType  *string `json:"xrefType,omitempty"`
}

// XrefIdRestObject defines model for XrefIdRestObject.
type XrefIdRestObject struct {
	Copyright *string `json:"copyright,omitempty"`
	Season    *string `json:"season,omitempty"`
	XrefId    *string `json:"xrefId,omitempty"`
	XrefIdTwo *string `json:"xrefIdTwo,omitempty"`
	XrefType  *string `json:"xrefType,omitempty"`
}

// LiveGameV1Params defines parameters for LiveGameV1.
type LiveGameV1Params struct {
	// Timecode Use this parameter to return a snapshot of the data at the specified time. Format: YYYYMMDD_HHMMSS
	Timecode *string `form:"timecode,omitempty" json:"timecode,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// InclusiveTimecode True to include plays that happen before or at the specified timecode
	InclusiveTimecode *bool `form:"inclusiveTimecode,omitempty" json:"inclusiveTimecode,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool `form:"accent,omitempty" json:"accent,omitempty"`
}

// LiveGameDiffPatchV1Params defines parameters for LiveGameDiffPatchV1.
type LiveGameDiffPatchV1Params struct {
	// StartTimecode Start time code will give you everything since that time. Format: MMDDYYYY_HHMMSS
	StartTimecode *string `form:"startTimecode,omitempty" json:"startTimecode,omitempty"`

	// EndTimecode End time code will give you a snapshot at that specific time. Format: MMDDYYYY_HHMMSS
	EndTimecode *string `form:"endTimecode,omitempty" json:"endTimecode,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool `form:"accent,omitempty" json:"accent,omitempty"`
}

// GameGuidsFromPostgresRangeByGameParams defines parameters for GameGuidsFromPostgresRangeByGame.
type GameGuidsFromPostgresRangeByGameParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// GameModeId Statcast game mode. Format: 0 = Batting Practive, 1 = Warmup 2 = Live
	GameModeId *int32 `form:"gameModeId,omitempty" json:"gameModeId,omitempty"`

	// IsPitch If there was a pitch
	IsPitch *bool `form:"isPitch,omitempty" json:"isPitch,omitempty"`

	// IsHit If there was a hit ball tracked
	IsHit *bool `form:"isHit,omitempty" json:"isHit,omitempty"`

	// IsPickoff If there was a pickoff
	IsPickoff *bool `form:"isPickoff,omitempty" json:"isPickoff,omitempty"`

	// IsNonStatcast If non statcast games need to be included
	IsNonStatcast *bool `form:"isNonStatcast,omitempty" json:"isNonStatcast,omitempty"`

	// GamedayType Indicates the level of Gameday (tracking, play-by-play, linescore, etc...)
	GamedayType *string `form:"gamedayType,omitempty" json:"gamedayType,omitempty"`

	// HasUpdates True if updated by an auditor
	HasUpdates *bool `form:"hasUpdates,omitempty" json:"hasUpdates,omitempty"`

	// LastPlayTime Returns all data that was created after the specified timestamp. Format: YYYY-MM-DDTHH:MM:SSZ
	LastPlayTime *time.Time `form:"lastPlayTime,omitempty" json:"lastPlayTime,omitempty"`

	// LastVideoUpdatedTime The last time SportyBot video was updated
	LastVideoUpdatedTime *time.Time `form:"lastVideoUpdatedTime,omitempty" json:"lastVideoUpdatedTime,omitempty"`

	// LastUpdatedTime Return data updated since a specified date. Format: YYYY-MM-DDTHH:MM:SSZ
	LastUpdatedTime *time.Time `form:"lastUpdatedTime,omitempty" json:"lastUpdatedTime,omitempty"`

	// LastMetricsUpdatedTime Return data updated since a specified date. Format: YYYY-MM-DDTHH:MM:SSZ
	LastMetricsUpdatedTime *time.Time `form:"lastMetricsUpdatedTime,omitempty" json:"lastMetricsUpdatedTime,omitempty"`

	// LastAuditUpdatedTime Return data updated since a specified date. Format: YYYY-MM-DDTHH:MM:SSZ
	LastAuditUpdatedTime *time.Time `form:"lastAuditUpdatedTime,omitempty" json:"lastAuditUpdatedTime,omitempty"`

	// GameDate Date of Game. Format: YYYY-MM-DD
	GameDate *openapi_types.Date `form:"gameDate,omitempty" json:"gameDate,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// TrackingSystemOwner Owner of the tracking system
	TrackingSystemOwner *TrackingSystemOwner `form:"trackingSystemOwner,omitempty" json:"trackingSystemOwner,omitempty"`

	// SortBy Sort the set of data by the specified field
	SortBy *string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// ScheduleEventTypes Comma delimited list of type of event types
	ScheduleEventTypes *[]ScheduleEventTypes `form:"scheduleEventTypes,omitempty" json:"scheduleEventTypes,omitempty"`
}

// GameGuidsFromPostgresRangeParams defines parameters for GameGuidsFromPostgresRange.
type GameGuidsFromPostgresRangeParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// GameModeId Statcast game mode. Format: 0 = Batting Practive, 1 = Warmup 2 = Live
	GameModeId *int32 `form:"gameModeId,omitempty" json:"gameModeId,omitempty"`

	// IsPitch If there was a pitch
	IsPitch *bool `form:"isPitch,omitempty" json:"isPitch,omitempty"`

	// IsHit If there was a hit ball tracked
	IsHit *bool `form:"isHit,omitempty" json:"isHit,omitempty"`

	// IsPickoff If there was a pickoff
	IsPickoff *bool `form:"isPickoff,omitempty" json:"isPickoff,omitempty"`

	// IsNonStatcast If non statcast games need to be included
	IsNonStatcast *bool `form:"isNonStatcast,omitempty" json:"isNonStatcast,omitempty"`

	// GamedayType Indicates the level of Gameday (tracking, play-by-play, linescore, etc...)
	GamedayType *string `form:"gamedayType,omitempty" json:"gamedayType,omitempty"`

	// HasUpdates True if updated by an auditor
	HasUpdates *bool `form:"hasUpdates,omitempty" json:"hasUpdates,omitempty"`

	// LastPlayTime Returns all data that was created after the specified timestamp. Format: YYYY-MM-DDTHH:MM:SSZ
	LastPlayTime *time.Time `form:"lastPlayTime,omitempty" json:"lastPlayTime,omitempty"`

	// LastUpdatedTime Return data updated since a specified date. Format: YYYY-MM-DDTHH:MM:SSZ
	LastUpdatedTime *time.Time `form:"lastUpdatedTime,omitempty" json:"lastUpdatedTime,omitempty"`

	// LastMetricsUpdatedTime Return data updated since a specified date. Format: YYYY-MM-DDTHH:MM:SSZ
	LastMetricsUpdatedTime *time.Time `form:"lastMetricsUpdatedTime,omitempty" json:"lastMetricsUpdatedTime,omitempty"`

	// LastAuditUpdatedTime Return data updated since a specified date. Format: YYYY-MM-DDTHH:MM:SSZ
	LastAuditUpdatedTime *time.Time `form:"lastAuditUpdatedTime,omitempty" json:"lastAuditUpdatedTime,omitempty"`

	// LastVideoUpdatedTime The last time SportyBot video was updated
	LastVideoUpdatedTime *time.Time `form:"lastVideoUpdatedTime,omitempty" json:"lastVideoUpdatedTime,omitempty"`

	// GameDate Date of Game. Format: YYYY-MM-DD
	GameDate *openapi_types.Date `form:"gameDate,omitempty" json:"gameDate,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// TrackingSystemOwner Owner of the tracking system
	TrackingSystemOwner *TrackingSystemOwner `form:"trackingSystemOwner,omitempty" json:"trackingSystemOwner,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// SortBy Sort the set of data by the specified field
	SortBy *string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetTeamAttendanceParams defines parameters for GetTeamAttendance.
type GetTeamAttendanceParams struct {
	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *[]int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// LeagueId Comma delimited list of Unique league identifiers
	LeagueId *[]int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// Season Comma delimited list of Seasons of play
	Season *[]string `form:"season,omitempty" json:"season,omitempty"`

	// LeagueListId Unique League List Identifier
	LeagueListId *LeagueListsEnum `form:"leagueListId,omitempty" json:"leagueListId,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *[]GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// AwardsParams defines parameters for Awards.
type AwardsParams struct {
	// OrgId Comma delimited list of top level organizations of a sport
	OrgId *[]int32 `form:"orgId,omitempty" json:"orgId,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Awards1Params defines parameters for Awards1.
type Awards1Params struct {
	// OrgId Comma delimited list of top level organizations of a sport
	OrgId *[]int32 `form:"orgId,omitempty" json:"orgId,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// AwardRecipientsParams defines parameters for AwardRecipients.
type AwardRecipientsParams struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// LeagueId Comma delimited list of Unique league identifiers
	LeagueId *[]int32  `form:"leagueId,omitempty" json:"leagueId,omitempty"`
	Fields   *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// BatTrackingParams defines parameters for BatTracking.
type BatTrackingParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetBroadcastsParams defines parameters for GetBroadcasts.
type GetBroadcastsParams struct {
	// BroadcasterIds All of the broadcast details
	BroadcasterIds []int32 `form:"broadcasterIds" json:"broadcasterIds"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetAllBroadcastersParams defines parameters for GetAllBroadcasters.
type GetAllBroadcastersParams struct {
	// ActiveStatus Current status of the broadcaster. Format: Active = y, inactive = n, both = b
	ActiveStatus *BroadcasterActiveStatusEnum `form:"activeStatus,omitempty" json:"activeStatus,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// ConferencesParams defines parameters for Conferences.
type ConferencesParams struct {
	// Season Season of play
	Season          *string `form:"season,omitempty" json:"season,omitempty"`
	IncludeInactive *bool   `form:"includeInactive,omitempty" json:"includeInactive,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Conferences1Params defines parameters for Conferences1.
type Conferences1Params struct {
	// Season Season of play
	Season          *string `form:"season,omitempty" json:"season,omitempty"`
	IncludeInactive *bool   `form:"includeInactive,omitempty" json:"includeInactive,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DivisionsParams defines parameters for Divisions.
type DivisionsParams struct {
	// IncludeInactive Whether or not to include inactive
	IncludeInactive *bool `form:"includeInactive,omitempty" json:"includeInactive,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Divisions1Params defines parameters for Divisions1.
type Divisions1Params struct {
	// IncludeInactive Whether or not to include inactive
	IncludeInactive *bool `form:"includeInactive,omitempty" json:"includeInactive,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DraftPicksParams defines parameters for DraftPicks.
type DraftPicksParams struct {
	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Order The order of sorting, ascending or descending
	Order *SortOrderEnum `form:"order,omitempty" json:"order,omitempty"`

	// SortBy Sort the set of data by the specified field
	SortBy *string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// Drafted Whether or not the players been drafted
	Drafted *bool `form:"drafted,omitempty" json:"drafted,omitempty"`

	// Round Round in which a player was drafted
	Round *string `form:"round,omitempty" json:"round,omitempty"`

	// Name Filter players by the first letter of their name using using the specific character
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// School Filter players by the first letter of their school using using the specific character
	School *string `form:"school,omitempty" json:"school,omitempty"`

	// Position Position number. Format: 1, 2, 3, etc
	Position *BaseballPosition `form:"position,omitempty" json:"position,omitempty"`

	// Team Unique Team Code. Format: tor, nya, etc
	Team *string `form:"team,omitempty" json:"team,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// State State where the venue is located. Format: Ohio
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Country Filter players by their home country
	Country *string `form:"country,omitempty" json:"country,omitempty"`

	// PlayerId A unique identifier for a player
	PlayerId *int32 `form:"playerId,omitempty" json:"playerId,omitempty"`

	// BisPlayerId A unique identifier for a player in the EBIS system
	BisPlayerId *int32 `form:"bisPlayerId,omitempty" json:"bisPlayerId,omitempty"`
}

// DraftProspectsParams defines parameters for DraftProspects.
type DraftProspectsParams struct {
	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Order The order of sorting, ascending or descending
	Order *SortOrderEnum `form:"order,omitempty" json:"order,omitempty"`

	// SortBy Sort the set of data by the specified field
	SortBy *string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// Drafted Whether or not the players been drafted
	Drafted *bool `form:"drafted,omitempty" json:"drafted,omitempty"`

	// Round Round in which a player was drafted
	Round *string `form:"round,omitempty" json:"round,omitempty"`

	// Name Filter players by the first letter of their name using using the specific character
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// School Filter players by the first letter of their school using using the specific character
	School *string `form:"school,omitempty" json:"school,omitempty"`

	// Position Position number. Format: 1, 2, 3, etc
	Position *BaseballPosition `form:"position,omitempty" json:"position,omitempty"`

	// Team Unique Team Code. Format: tor, nya, etc
	Team *string `form:"team,omitempty" json:"team,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// State State where the venue is located. Format: Ohio
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Country Filter players by their home country
	Country *string `form:"country,omitempty" json:"country,omitempty"`

	// PlayerId A unique identifier for a player
	PlayerId *int32 `form:"playerId,omitempty" json:"playerId,omitempty"`

	// BisPlayerId A unique identifier for a player in the EBIS system
	BisPlayerId *int32 `form:"bisPlayerId,omitempty" json:"bisPlayerId,omitempty"`
}

// DraftProspects1Params defines parameters for DraftProspects1.
type DraftProspects1Params struct {
	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Order The order of sorting, ascending or descending
	Order *SortOrderEnum `form:"order,omitempty" json:"order,omitempty"`

	// SortBy Sort the set of data by the specified field
	SortBy *string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// Drafted Whether or not the players been drafted
	Drafted *bool `form:"drafted,omitempty" json:"drafted,omitempty"`

	// Round Round in which a player was drafted
	Round *string `form:"round,omitempty" json:"round,omitempty"`

	// Name Filter players by the first letter of their name using using the specific character
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// School Filter players by the first letter of their school using using the specific character
	School *string `form:"school,omitempty" json:"school,omitempty"`

	// Position Position number. Format: 1, 2, 3, etc
	Position *BaseballPosition `form:"position,omitempty" json:"position,omitempty"`

	// Team Unique Team Code. Format: tor, nya, etc
	Team *string `form:"team,omitempty" json:"team,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// State State where the venue is located. Format: Ohio
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Country Filter players by their home country
	Country *string `form:"country,omitempty" json:"country,omitempty"`

	// PlayerId A unique identifier for a player
	PlayerId *int32 `form:"playerId,omitempty" json:"playerId,omitempty"`

	// BisPlayerId A unique identifier for a player in the EBIS system
	BisPlayerId *int32 `form:"bisPlayerId,omitempty" json:"bisPlayerId,omitempty"`
}

// DraftPicks1Params defines parameters for DraftPicks1.
type DraftPicks1Params struct {
	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Order The order of sorting, ascending or descending
	Order *SortOrderEnum `form:"order,omitempty" json:"order,omitempty"`

	// SortBy Sort the set of data by the specified field
	SortBy *string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// Drafted Whether or not the players been drafted
	Drafted *bool `form:"drafted,omitempty" json:"drafted,omitempty"`

	// Round Round in which a player was drafted
	Round *string `form:"round,omitempty" json:"round,omitempty"`

	// Name Filter players by the first letter of their name using using the specific character
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// School Filter players by the first letter of their school using using the specific character
	School *string `form:"school,omitempty" json:"school,omitempty"`

	// Position Position number. Format: 1, 2, 3, etc
	Position *BaseballPosition `form:"position,omitempty" json:"position,omitempty"`

	// Team Unique Team Code. Format: tor, nya, etc
	Team *string `form:"team,omitempty" json:"team,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// State State where the venue is located. Format: Ohio
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Country Filter players by their home country
	Country *string `form:"country,omitempty" json:"country,omitempty"`

	// PlayerId A unique identifier for a player
	PlayerId *int32 `form:"playerId,omitempty" json:"playerId,omitempty"`

	// BisPlayerId A unique identifier for a player in the EBIS system
	BisPlayerId *int32 `form:"bisPlayerId,omitempty" json:"bisPlayerId,omitempty"`
}

// LatestDraftPicksParams defines parameters for LatestDraftPicks.
type LatestDraftPicksParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// EventTypesParams defines parameters for EventTypes.
type EventTypesParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// CurrentGameStats1Params defines parameters for CurrentGameStats1.
type CurrentGameStats1Params struct {
	// UpdatedSince Format: YYYY-MM-DDTHH:MM:SSZ
	UpdatedSince *time.Time `form:"updatedSince,omitempty" json:"updatedSince,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// SportIds Comma delimited list of top level organizations of a sport
	SportIds *[]int32 `form:"sportIds,omitempty" json:"sportIds,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// GameTypes Comma delimited list of type of Game. Available types in /api/v1/gameTypes
	GameTypes *[]GameTypeEnum `form:"gameTypes,omitempty" json:"gameTypes,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// GamePks Comma delimited list of unique primary keys
	GamePks *[]int32 `form:"gamePks,omitempty" json:"gamePks,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GameLastPitchParams defines parameters for GameLastPitch.
type GameLastPitchParams struct {
	// GamePks Unique Primary Key Representing a Game
	GamePks []int32 `form:"gamePks" json:"gamePks"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetGameContextMetricsParams defines parameters for GetGameContextMetrics.
type GetGameContextMetricsParams struct {
	// Timecode Use this parameter to return a snapshot of the data at the specified time. Format: YYYYMMDD_HHMMSS
	Timecode *string `form:"timecode,omitempty" json:"timecode,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GameGuidsParams defines parameters for GameGuids.
type GameGuidsParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// GameModeId Statcast game mode. Format: 0 = Batting Practive, 1 = Warmup 2 = Live
	GameModeId *int32 `form:"gameModeId,omitempty" json:"gameModeId,omitempty"`

	// IsPitch If there was a pitch
	IsPitch *bool `form:"isPitch,omitempty" json:"isPitch,omitempty"`

	// IsHit If there was a hit ball tracked
	IsHit *bool `form:"isHit,omitempty" json:"isHit,omitempty"`

	// IsPickoff If there was a pickoff
	IsPickoff *bool `form:"isPickoff,omitempty" json:"isPickoff,omitempty"`

	// HasUpdates True if updated by an auditor
	HasUpdates *bool `form:"hasUpdates,omitempty" json:"hasUpdates,omitempty"`

	// Since Returns all data that was created after the specified timestamp. Format: YYYY-MM-DDTHH:MM:SSZ
	Since *time.Time `form:"since,omitempty" json:"since,omitempty"`

	// UpdatedSince Return data updated since a specified date. Format: YYYY-MM-DDTHH:MM:SSZ
	UpdatedSince *time.Time `form:"updatedSince,omitempty" json:"updatedSince,omitempty"`

	// LastPlayTime Returns all data that was created after the specified timestamp. Format: YYYY-MM-DDTHH:MM:SSZ
	LastPlayTime *time.Time `form:"lastPlayTime,omitempty" json:"lastPlayTime,omitempty"`

	// LastUpdatedTime Return data updated since a specified date. Format: YYYY-MM-DDTHH:MM:SSZ
	LastUpdatedTime *time.Time `form:"lastUpdatedTime,omitempty" json:"lastUpdatedTime,omitempty"`

	// LastMetricsUpdatedTime Return data updated since a specified date. Format: YYYY-MM-DDTHH:MM:SSZ
	LastMetricsUpdatedTime *time.Time `form:"lastMetricsUpdatedTime,omitempty" json:"lastMetricsUpdatedTime,omitempty"`

	// LastAuditUpdatedTime Return data updated since a specified date. Format: YYYY-MM-DDTHH:MM:SSZ
	LastAuditUpdatedTime *time.Time `form:"lastAuditUpdatedTime,omitempty" json:"lastAuditUpdatedTime,omitempty"`

	// LastVideoUpdatedTime The last time SportyBot video was updated
	LastVideoUpdatedTime *time.Time `form:"lastVideoUpdatedTime,omitempty" json:"lastVideoUpdatedTime,omitempty"`
}

// GetWinProbabilityParams defines parameters for GetWinProbability.
type GetWinProbabilityParams struct {
	// Timecode Use this parameter to return a snapshot of the data at the specified time. Format: YYYYMMDD_HHMMSS
	Timecode *string `form:"timecode,omitempty" json:"timecode,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// InclusiveTimecode True to include plays that happen before or at the specified timecode
	InclusiveTimecode *bool `form:"inclusiveTimecode,omitempty" json:"inclusiveTimecode,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool `form:"accent,omitempty" json:"accent,omitempty"`
}

// GetGameWithMetricsParams defines parameters for GetGameWithMetrics.
type GetGameWithMetricsParams struct {
	// Timecode Use this parameter to return a snapshot of the data at the specified time. Format: YYYYMMDD_HHMMSS
	Timecode *string `form:"timecode,omitempty" json:"timecode,omitempty"`

	// InclusiveTimecode True to include plays that happen before or at the specified timecode
	InclusiveTimecode *bool `form:"inclusiveTimecode,omitempty" json:"inclusiveTimecode,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool `form:"accent,omitempty" json:"accent,omitempty"`
}

// ParsedJsonFormattedAnalyticsParams defines parameters for ParsedJsonFormattedAnalytics.
type ParsedJsonFormattedAnalyticsParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// ContextMetricsParams defines parameters for ContextMetrics.
type ContextMetricsParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// ContextMetricsWithAveragesParams defines parameters for ContextMetricsWithAverages.
type ContextMetricsWithAveragesParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// ContextMetricsWithAveragesPostParams defines parameters for ContextMetricsWithAveragesPost.
type ContextMetricsWithAveragesPostParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// HomeRunBallparksParams defines parameters for HomeRunBallparks.
type HomeRunBallparksParams struct {
	IsHomeRunParks bool `form:"isHomeRunParks" json:"isHomeRunParks"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// BiomechanicalParams defines parameters for Biomechanical.
type BiomechanicalParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// SkeletalChunkedParams defines parameters for SkeletalChunked.
type SkeletalChunkedParams struct {
	// FileName Skeletal chunked file name
	FileName string `form:"fileName" json:"fileName"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// SkeletalDataFileNamesParams defines parameters for SkeletalDataFileNames.
type SkeletalDataFileNamesParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// BoxscoreParams defines parameters for Boxscore.
type BoxscoreParams struct {
	// Timecode Use this parameter to return a snapshot of the data at the specified time. Format: YYYYMMDD_HHMMSS
	Timecode *string `form:"timecode,omitempty" json:"timecode,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// InclusiveTimecode True to include plays that happen before or at the specified timecode
	InclusiveTimecode *bool `form:"inclusiveTimecode,omitempty" json:"inclusiveTimecode,omitempty"`

	// NumPlayers Number of top player game scores to show. Default is 3.
	NumPlayers *int32 `form:"numPlayers,omitempty" json:"numPlayers,omitempty"`

	// NoTies If set to false, will show all players tied for the last spot in the game scores list.
	NoTies *bool `form:"noTies,omitempty" json:"noTies,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool `form:"accent,omitempty" json:"accent,omitempty"`
}

// ContentParams defines parameters for Content.
type ContentParams struct {
	// HighlightLimit Number of results to return
	HighlightLimit *int32 `form:"highlightLimit,omitempty" json:"highlightLimit,omitempty"`
}

// ColorFeedParams defines parameters for ColorFeed.
type ColorFeedParams struct {
	// Timecode Use this parameter to return a snapshot of the data at the specified time. Format: YYYYMMDD_HHMMSS
	Timecode *string `form:"timecode,omitempty" json:"timecode,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// LinescoreParams defines parameters for Linescore.
type LinescoreParams struct {
	// Timecode Use this parameter to return a snapshot of the data at the specified time. Format: YYYYMMDD_HHMMSS
	Timecode *string `form:"timecode,omitempty" json:"timecode,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// InclusiveTimecode True to include plays that happen before or at the specified timecode
	InclusiveTimecode *bool `form:"inclusiveTimecode,omitempty" json:"inclusiveTimecode,omitempty"`
}

// PlayByPlayParams defines parameters for PlayByPlay.
type PlayByPlayParams struct {
	// Timecode Use this parameter to return a snapshot of the data at the specified time. Format: YYYYMMDD_HHMMSS
	Timecode *string `form:"timecode,omitempty" json:"timecode,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// InclusiveTimecode True to include plays that happen before or at the specified timecode
	InclusiveTimecode *bool `form:"inclusiveTimecode,omitempty" json:"inclusiveTimecode,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool `form:"accent,omitempty" json:"accent,omitempty"`
}

// GamePaceParams defines parameters for GamePace.
type GamePaceParams struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// TeamIds Comma delimited list of Unique Team identifiers
	TeamIds *[]int32 `form:"teamIds,omitempty" json:"teamIds,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// LeagueListId Unique League List Identifier
	LeagueListId *LeagueListsEnum `form:"leagueListId,omitempty" json:"leagueListId,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// SportIds Comma delimited list of top level organizations of a sport
	SportIds *[]int32 `form:"sportIds,omitempty" json:"sportIds,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// VenueIds Comma delimited list of Unique venue identifiers
	VenueIds *[]int32 `form:"venueIds,omitempty" json:"venueIds,omitempty"`

	// ExcludeVenueIds Comma delimited list of Unique venue identifiers
	ExcludeVenueIds *[]int32 `form:"excludeVenueIds,omitempty" json:"excludeVenueIds,omitempty"`

	// ExcludeGamePks Comma delimited list of unique primary keys
	ExcludeGamePks *[]int32 `form:"excludeGamePks,omitempty" json:"excludeGamePks,omitempty"`

	// OrgType Organization level. Format: T(Team), L(League), S(Sport)
	OrgType *OrganizationType `form:"orgType,omitempty" json:"orgType,omitempty"`

	// IncludeChildren Determines weather to include results from an organization's children (ex. a sport would also include results for the teams and leagues)
	IncludeChildren *bool `form:"includeChildren,omitempty" json:"includeChildren,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GameTypesParams defines parameters for GameTypes.
type GameTypesParams struct {
	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`
}

// GamedayTypesParams defines parameters for GamedayTypes.
type GamedayTypesParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// HighLowParams defines parameters for HighLow.
type HighLowParams struct {
	// StatGroup Comma delimited list of  categories of statistic to return. Available types in /api/v1/statGroups
	StatGroup *[]StatGroup `form:"statGroup,omitempty" json:"statGroup,omitempty"`

	// SortStat Comma delimited list of baseball stats to sort splits by.
	SortStat *[]HighLowStatEnum `form:"sortStat,omitempty" json:"sortStat,omitempty"`

	// Season Comma delimited list of Seasons of play
	Season *[]string `form:"season,omitempty" json:"season,omitempty"`

	// GameType Comma delimited list of type of Game. Available types in /api/v1/gameTypes
	GameType *[]GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// HitTrajectoriesParams defines parameters for HitTrajectories.
type HitTrajectoriesParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// HomeRunDerbyBracket1Params defines parameters for HomeRunDerbyBracket1.
type HomeRunDerbyBracket1Params struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// HomeRunDerbyBracket3Params defines parameters for HomeRunDerbyBracket3.
type HomeRunDerbyBracket3Params struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// HomeRunDerbyMixedMode1Params defines parameters for HomeRunDerbyMixedMode1.
type HomeRunDerbyMixedMode1Params struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// HomeRunDerbyPool1Params defines parameters for HomeRunDerbyPool1.
type HomeRunDerbyPool1Params struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// HomeRunDerbyBracketParams defines parameters for HomeRunDerbyBracket.
type HomeRunDerbyBracketParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// HomeRunDerbyBracket2Params defines parameters for HomeRunDerbyBracket2.
type HomeRunDerbyBracket2Params struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// HomeRunDerbyMixedModeParams defines parameters for HomeRunDerbyMixedMode.
type HomeRunDerbyMixedModeParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// HomeRunDerbyPoolParams defines parameters for HomeRunDerbyPool.
type HomeRunDerbyPoolParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// JobTypesParams defines parameters for JobTypes.
type JobTypesParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetJobsByTypeParams defines parameters for GetJobsByType.
type GetJobsByTypeParams struct {
	// JobType Job Type Identifier (ie. UMPR, etc..)
	JobType string `form:"jobType" json:"jobType"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DatacastersParams defines parameters for Datacasters.
type DatacastersParams struct {
	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// OfficialScorersParams defines parameters for OfficialScorers.
type OfficialScorersParams struct {
	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// UmpiresParams defines parameters for Umpires.
type UmpiresParams struct {
	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`
}

// UmpireScheduleParams defines parameters for UmpireSchedule.
type UmpireScheduleParams struct {
	// Season Season of play
	Season string `form:"season" json:"season"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// LeagueParams defines parameters for League.
type LeagueParams struct {
	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// ActiveStatus Flag for fetching leagues that are currently active (Y), inactive (N), pending (P), or all teams (B)
	ActiveStatus *LeagueActiveStatusEnum `form:"activeStatus,omitempty" json:"activeStatus,omitempty"`
}

// AllStarBallotParams defines parameters for AllStarBallot.
type AllStarBallotParams struct {
	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// League1Params defines parameters for League1.
type League1Params struct {
	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// ActiveStatus Flag for fetching leagues that are currently active (Y), inactive (N), pending (P), or all teams (B)
	ActiveStatus *LeagueActiveStatusEnum `form:"activeStatus,omitempty" json:"activeStatus,omitempty"`
}

// AllStarBallot1Params defines parameters for AllStarBallot1.
type AllStarBallot1Params struct {
	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// AllStarFinalVoteParams defines parameters for AllStarFinalVote.
type AllStarFinalVoteParams struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// AllStarWriteInsParams defines parameters for AllStarWriteIns.
type AllStarWriteInsParams struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// League2Params defines parameters for League2.
type League2Params struct {
	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// ActiveStatus Flag for fetching leagues that are currently active (Y), inactive (N), pending (P), or all teams (B)
	ActiveStatus *LeagueActiveStatusEnum `form:"activeStatus,omitempty" json:"activeStatus,omitempty"`
}

// AllStarBallot2Params defines parameters for AllStarBallot2.
type AllStarBallot2Params struct {
	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// League3Params defines parameters for League3.
type League3Params struct {
	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// ActiveStatus Flag for fetching leagues that are currently active (Y), inactive (N), pending (P), or all teams (B)
	ActiveStatus *LeagueActiveStatusEnum `form:"activeStatus,omitempty" json:"activeStatus,omitempty"`
}

// AllStarBallot3Params defines parameters for AllStarBallot3.
type AllStarBallot3Params struct {
	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// AllStarFinalVote1Params defines parameters for AllStarFinalVote1.
type AllStarFinalVote1Params struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// AllStarWriteIns1Params defines parameters for AllStarWriteIns1.
type AllStarWriteIns1Params struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// LogicalEventsParams defines parameters for LogicalEvents.
type LogicalEventsParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// MilestonesParams defines parameters for Milestones.
type MilestonesParams struct {
	// OrgType Organization level. Format: T(Team), L(League), S(Sport)
	OrgType *OrganizationType `form:"orgType,omitempty" json:"orgType,omitempty"`

	// AchievementStatuses Comma delimited list of milestone achievement types
	AchievementStatuses *[]MilestoneAchievementType `form:"achievementStatuses,omitempty" json:"achievementStatuses,omitempty"`

	// MilestoneTypes Comma delimited list of milestone types
	MilestoneTypes *[]MilestoneType `form:"milestoneTypes,omitempty" json:"milestoneTypes,omitempty"`

	// IsLastAchievement Filters out milestones that have already been surpassed.
	IsLastAchievement *bool `form:"isLastAchievement,omitempty" json:"isLastAchievement,omitempty"`

	// MilestoneStatistics Comma delimited list of milestone statistics
	MilestoneStatistics *[]Statistic `form:"milestoneStatistics,omitempty" json:"milestoneStatistics,omitempty"`

	// MilestoneValues Comma delimited list of milestone values
	MilestoneValues *[]int32 `form:"milestoneValues,omitempty" json:"milestoneValues,omitempty"`

	// PlayerIds A unique identifier for players
	PlayerIds *[]int32 `form:"playerIds,omitempty" json:"playerIds,omitempty"`

	// TeamIds Comma delimited list of Unique Team identifiers
	TeamIds *[]int32 `form:"teamIds,omitempty" json:"teamIds,omitempty"`

	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// StatGroup Category of statistic to return. Available types in /api/v1/statGroups
	StatGroup *StatGroup `form:"statGroup,omitempty" json:"statGroup,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// VenueIds Comma delimited list of Unique venue identifiers
	VenueIds *[]int32 `form:"venueIds,omitempty" json:"venueIds,omitempty"`

	// GamePks Comma delimited list of unique primary keys
	GamePks *[]int32 `form:"gamePks,omitempty" json:"gamePks,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// ShowFirsts True to show play first milestones, like first HR, first Save, etc
	ShowFirsts *bool `form:"showFirsts,omitempty" json:"showFirsts,omitempty"`
}

// MoundVisitTypesParams defines parameters for MoundVisitTypes.
type MoundVisitTypesParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Person1Params defines parameters for Person1.
type Person1Params struct {
	// PersonIds Comma delimited list of person ID. Format: 1234, 2345
	PersonIds *[]int32 `form:"personIds,omitempty" json:"personIds,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool `form:"accent,omitempty" json:"accent,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group *[]StatGroup `form:"group,omitempty" json:"group,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// CurrentGameStatsParams defines parameters for CurrentGameStats.
type CurrentGameStatsParams struct {
	// UpdatedSince Format: YYYY-MM-DDTHH:MM:SSZ
	UpdatedSince time.Time `form:"updatedSince" json:"updatedSince"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool `form:"accent,omitempty" json:"accent,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// FreeAgentsParams defines parameters for FreeAgents.
type FreeAgentsParams struct {
	// Season Season of play
	Season string `form:"season" json:"season"`

	// Order The order of sorting, ascending or descending
	Order *SortOrderEnum `form:"order,omitempty" json:"order,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool     `form:"accent,omitempty" json:"accent,omitempty"`
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// SearchParams defines parameters for Search.
type SearchParams struct {
	// Names Name a player uses
	Names *[]string `form:"names,omitempty" json:"names,omitempty"`

	// PersonIds Comma delimited list of person ID. Format: 1234, 2345
	PersonIds *[]int32 `form:"personIds,omitempty" json:"personIds,omitempty"`

	// SportIds Comma delimited list of top level organizations of a sport
	SportIds *[]int32 `form:"sportIds,omitempty" json:"sportIds,omitempty"`

	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// TeamIds Comma delimited list of Unique Team identifiers
	TeamIds *[]int32 `form:"teamIds,omitempty" json:"teamIds,omitempty"`

	// LeagueListId Unique League List Identifier
	LeagueListId *LeagueListsEnum `form:"leagueListId,omitempty" json:"leagueListId,omitempty"`

	// Active Whether or not a player is active
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Verified Complete and confirmed all biographical data
	Verified *bool `form:"verified,omitempty" json:"verified,omitempty"`

	// Rookie Whether or not a player is a rookie
	Rookie *bool `form:"rookie,omitempty" json:"rookie,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool `form:"accent,omitempty" json:"accent,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// PersonParams defines parameters for Person.
type PersonParams struct {
	// PersonIds Comma delimited list of person ID. Format: 1234, 2345
	PersonIds *[]int32 `form:"personIds,omitempty" json:"personIds,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool `form:"accent,omitempty" json:"accent,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group *[]StatGroup `form:"group,omitempty" json:"group,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// AwardParams defines parameters for Award.
type AwardParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Stats3Params defines parameters for Stats3.
type Stats3Params struct {
	// Stats Type of statistics. Format: Individual, Team, Career, etc. Available types in /api/v1/statTypes
	Stats []StatType `form:"stats" json:"stats"`

	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group *[]StatGroup `form:"group,omitempty" json:"group,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// OpposingTeamId A unique identifier for the opposing team. Must be used with Team ID
	OpposingTeamId *int32 `form:"opposingTeamId,omitempty" json:"opposingTeamId,omitempty"`

	// OpposingPlayerId A unique identifier for the opposing team
	OpposingPlayerId *int32 `form:"opposingPlayerId,omitempty" json:"opposingPlayerId,omitempty"`

	// Metrics Name of metric(s) for metric log stats.  Available metrics in /api/v1/metrics
	Metrics *[]MetricType `form:"metrics,omitempty" json:"metrics,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// LeagueListId Unique League List Identifier
	LeagueListId *LeagueListsEnum `form:"leagueListId,omitempty" json:"leagueListId,omitempty"`

	// SitCodes Situation code for a given stat split.
	SitCodes *[]string `form:"sitCodes,omitempty" json:"sitCodes,omitempty"`

	// CombineSits If true, gathers stats where all of the situational criteria are met. If false, returns stats where any of the situational criteria are met. Default: false
	CombineSits *bool `form:"combineSits,omitempty" json:"combineSits,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// DaysBack Returns results from the last 'X' days (Starting from yesterday).
	DaysBack *int32 `form:"daysBack,omitempty" json:"daysBack,omitempty"`

	// GamesBack Returns results from the last 'X' games played.
	GamesBack *int32 `form:"gamesBack,omitempty" json:"gamesBack,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// EventType Type of event
	EventType *[]EventType `form:"eventType,omitempty" json:"eventType,omitempty"`

	// PitchType Classification of pitch (fastball, curveball, etc...)
	PitchType *[]string `form:"pitchType,omitempty" json:"pitchType,omitempty"`

	// HitTrajectory Trajectory of hit (line drive, fly ball, etc...)
	HitTrajectory *[]HitTrajectory `form:"hitTrajectory,omitempty" json:"hitTrajectory,omitempty"`

	// BatSide Bat side of hitter
	BatSide *string `form:"batSide,omitempty" json:"batSide,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *[]GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// GroupBy Group stats by PLAYER, TEAM, SEASON, VENUE, SPORT or STAT_GROUP
	GroupBy *[]GroupByEnum `form:"groupBy,omitempty" json:"groupBy,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool `form:"accent,omitempty" json:"accent,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PlayerGameStatsParams defines parameters for PlayerGameStats.
type PlayerGameStatsParams struct {
	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group *[]StatGroup `form:"group,omitempty" json:"group,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// StatsMetricsParams defines parameters for StatsMetrics.
type StatsMetricsParams struct {
	// Stats Type of statistics. Format: Individual, Team, Career, etc. Available types in /api/v1/statTypes
	Stats []StatType `form:"stats" json:"stats"`

	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group *[]StatGroup `form:"group,omitempty" json:"group,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// OpposingTeamId A unique identifier for the opposing team. Must be used with Team ID
	OpposingTeamId *int32 `form:"opposingTeamId,omitempty" json:"opposingTeamId,omitempty"`

	// OpposingPlayerId A unique identifier for the opposing team
	OpposingPlayerId *int32 `form:"opposingPlayerId,omitempty" json:"opposingPlayerId,omitempty"`

	// Metrics Name of metric(s) for metric log stats.  Available metrics in /api/v1/metrics
	Metrics *[]MetricType `form:"metrics,omitempty" json:"metrics,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// LeagueListId Unique League List Identifier
	LeagueListId *LeagueListsEnum `form:"leagueListId,omitempty" json:"leagueListId,omitempty"`

	// SitCodes Situation code for a given stat split.
	SitCodes *[]string `form:"sitCodes,omitempty" json:"sitCodes,omitempty"`

	// CombineSits If true, gathers stats where all of the situational criteria are met. If false, returns stats where any of the situational criteria are met. Default: false
	CombineSits *bool `form:"combineSits,omitempty" json:"combineSits,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// DaysBack Returns results from the last 'X' days (Starting from yesterday).
	DaysBack *int32 `form:"daysBack,omitempty" json:"daysBack,omitempty"`

	// GamesBack Returns results from the last 'X' games played.
	GamesBack *int32 `form:"gamesBack,omitempty" json:"gamesBack,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// EventType Type of event
	EventType *[]EventType `form:"eventType,omitempty" json:"eventType,omitempty"`

	// PitchType Classification of pitch (fastball, curveball, etc...)
	PitchType *[]string `form:"pitchType,omitempty" json:"pitchType,omitempty"`

	// HitTrajectory Trajectory of hit (line drive, fly ball, etc...)
	HitTrajectory *[]HitTrajectory `form:"hitTrajectory,omitempty" json:"hitTrajectory,omitempty"`

	// BatSide Bat side of hitter
	BatSide *string `form:"batSide,omitempty" json:"batSide,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *[]GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// GroupBy Group stats by PLAYER, TEAM, SEASON, VENUE, SPORT or STAT_GROUP
	GroupBy *[]GroupByEnum `form:"groupBy,omitempty" json:"groupBy,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool `form:"accent,omitempty" json:"accent,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PitchCodesParams defines parameters for PitchCodes.
type PitchCodesParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PitchTypesParams defines parameters for PitchTypes.
type PitchTypesParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PlayerStatusCodesParams defines parameters for PlayerStatusCodes.
type PlayerStatusCodesParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetPropsParams defines parameters for GetProps.
type GetPropsParams struct {
	// BatterId Unique Player Identifier. Format: 434538, 429665, etc
	BatterId *int32 `form:"batterId,omitempty" json:"batterId,omitempty"`

	// PitcherId Unique Player Identifier. Format: 434538, 429665, etc
	PitcherId *int32 `form:"pitcherId,omitempty" json:"pitcherId,omitempty"`

	// VenueId Unique Venue Identifier
	VenueId *int32 `form:"venueId,omitempty" json:"venueId,omitempty"`

	// BatSide Bat side of hitter
	BatSide *string `form:"batSide,omitempty" json:"batSide,omitempty"`

	// PitchHand Handedness of pitcher
	PitchHand *string `form:"pitchHand,omitempty" json:"pitchHand,omitempty"`

	// BatterPosition Position abbreviation. Format: SS, P, 1B, etc
	BatterPosition *string `form:"batterPosition,omitempty" json:"batterPosition,omitempty"`

	// PitcherPosition Position abbreviation. Format: SS, P, 1B, etc
	PitcherPosition *string `form:"pitcherPosition,omitempty" json:"pitcherPosition,omitempty"`
}

// GetPropsAdjustParams defines parameters for GetPropsAdjust.
type GetPropsAdjustParams struct {
	// GamePk Unique Primary Key Representing a Game
	GamePk int32 `form:"gamePk" json:"gamePk"`
}

// GetReviewInfoParams defines parameters for GetReviewInfo.
type GetReviewInfoParams struct {
	// SportId Unique Team Identifier. Format: 141, 147, etc
	SportId int32 `form:"sportId" json:"sportId"`

	// Season Comma delimited list of Seasons of play
	Season string `form:"season" json:"season"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// ReviewReasonsParams defines parameters for ReviewReasons.
type ReviewReasonsParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// ScheduleParams defines parameters for Schedule.
type ScheduleParams struct {
	// CalendarTypes Comma delimited list of type of calendar types
	CalendarTypes *[]CalendarTypes `form:"calendarTypes,omitempty" json:"calendarTypes,omitempty"`

	// EventTypes Comma delimited list of type of events. <b>Note: Don't Use. This will be deprecated in favor of calendarTypes</b>
	EventTypes *[]CalendarTypes `form:"eventTypes,omitempty" json:"eventTypes,omitempty"`

	// ScheduleEventTypes Comma delimited list of type of event types
	ScheduleEventTypes *[]ScheduleEventTypes `form:"scheduleEventTypes,omitempty" json:"scheduleEventTypes,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *[]int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *[]int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// SportId Top level organization of a sport
	SportId *[]int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// GamePk Unique Primary Key Representing a Game
	GamePk *int32 `form:"gamePk,omitempty" json:"gamePk,omitempty"`

	// GamePks Comma delimited list of unique primary keys
	GamePks *[]int32 `form:"gamePks,omitempty" json:"gamePks,omitempty"`

	// EventIds A unique identifier for non-game event
	EventIds *[]int32 `form:"eventIds,omitempty" json:"eventIds,omitempty"`

	// VenueIds Unique Venue Identifier
	VenueIds *[]int32 `form:"venueIds,omitempty" json:"venueIds,omitempty"`

	// PerformerIds A unique identifier for non-team event performers
	PerformerIds *[]int32 `form:"performerIds,omitempty" json:"performerIds,omitempty"`

	// GameTypes Comma delimited list of type of Game. Available types in /api/v1/gameTypes
	GameTypes *[]GameTypeEnum `form:"gameTypes,omitempty" json:"gameTypes,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *[]GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Season Season of play
	Season *[]string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// Timecode Use this parameter to return a snapshot of the data at the specified time. Format: YYYYMMDD_HHMMSS
	Timecode       *string `form:"timecode,omitempty" json:"timecode,omitempty"`
	UseLatestGames *bool   `form:"useLatestGames,omitempty" json:"useLatestGames,omitempty"`

	// OpponentId A unique identifier for the opposing team. Must be used with Team ID
	OpponentId *[]int32 `form:"opponentId,omitempty" json:"opponentId,omitempty"`

	// PublicFacing Return public, non-public or all games. Format: Public Facing = 'Y', Non-Public Facing = 'N', All = 'A'
	PublicFacing *PublicFacingEnum `form:"publicFacing,omitempty" json:"publicFacing,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields               *[]string `form:"fields,omitempty" json:"fields,omitempty"`
	UsingPrivateEndpoint bool      `form:"usingPrivateEndpoint" json:"usingPrivateEndpoint"`
}

// TieGamesParams defines parameters for TieGames.
type TieGamesParams struct {
	// SportId Top level organization of a sport
	SportId *[]int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// GameTypes Comma delimited list of type of Game. Available types in /api/v1/gameTypes
	GameTypes *[]GameTypeEnum `form:"gameTypes,omitempty" json:"gameTypes,omitempty"`

	// Season Season of play
	Season string `form:"season" json:"season"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostseasonScheduleParams defines parameters for PostseasonSchedule.
type PostseasonScheduleParams struct {
	// GameTypes Comma delimited list of type of Game. Available types in /api/v1/gameTypes
	GameTypes    *[]GameTypeEnum `form:"gameTypes,omitempty" json:"gameTypes,omitempty"`
	SeriesNumber *int32          `form:"seriesNumber,omitempty" json:"seriesNumber,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// SportId Unique League Identifier
	SportId         *int32  `form:"sportId,omitempty" json:"sportId,omitempty"`
	UseLatestGames  *bool   `form:"useLatestGames,omitempty" json:"useLatestGames,omitempty"`
	UseFeaturedGame *bool   `form:"useFeaturedGame,omitempty" json:"useFeaturedGame,omitempty"`
	Season          *string `form:"season,omitempty" json:"season,omitempty"`

	// PublicFacing Return public, non-public or all games. Format: Public Facing = 'Y', Non-Public Facing = 'N', All = 'A'
	PublicFacing *PublicFacingEnum `form:"publicFacing,omitempty" json:"publicFacing,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostseasonScheduleSeriesParams defines parameters for PostseasonScheduleSeries.
type PostseasonScheduleSeriesParams struct {
	// GameTypes Comma delimited list of type of Game. Available types in /api/v1/gameTypes
	GameTypes    *[]GameTypeEnum `form:"gameTypes,omitempty" json:"gameTypes,omitempty"`
	SeriesNumber *int32          `form:"seriesNumber,omitempty" json:"seriesNumber,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// SportId Unique League Identifier
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate         *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`
	UseLatestGames  *bool               `form:"useLatestGames,omitempty" json:"useLatestGames,omitempty"`
	UseFeaturedGame *bool               `form:"useFeaturedGame,omitempty" json:"useFeaturedGame,omitempty"`
	Season          *string             `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// TuneInParams defines parameters for TuneIn.
type TuneInParams struct {
	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// SportId Unique League Identifier
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// Season Unique Primary Key Representing a Game
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// TrackingEventsScheduleParams defines parameters for TrackingEventsSchedule.
type TrackingEventsScheduleParams struct {
	// CalendarTypes Comma delimited list of type of calendar types
	CalendarTypes *[]CalendarTypes `form:"calendarTypes,omitempty" json:"calendarTypes,omitempty"`

	// EventTypes Comma delimited list of type of events. <b>Note: Don't Use. This will be deprecated in favor of calendarTypes</b>
	EventTypes *[]CalendarTypes `form:"eventTypes,omitempty" json:"eventTypes,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *[]int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *[]int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// SportId Top level organization of a sport
	SportId *[]int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// GamePk Unique Primary Key Representing a Game
	GamePk *int32 `form:"gamePk,omitempty" json:"gamePk,omitempty"`

	// GamePks Comma delimited list of unique primary keys
	GamePks *[]int32 `form:"gamePks,omitempty" json:"gamePks,omitempty"`

	// EventIds A unique identifier for non-game event
	EventIds *[]int32 `form:"eventIds,omitempty" json:"eventIds,omitempty"`

	// VenueIds Unique Venue Identifier
	VenueIds *[]int32 `form:"venueIds,omitempty" json:"venueIds,omitempty"`

	// PerformerIds A unique identifier for non-team event performers
	PerformerIds *[]int32 `form:"performerIds,omitempty" json:"performerIds,omitempty"`

	// GameTypes Comma delimited list of type of Game. Available types in /api/v1/gameTypes
	GameTypes *[]GameTypeEnum `form:"gameTypes,omitempty" json:"gameTypes,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *[]GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Season Season of play
	Season *[]string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// Timecode Use this parameter to return a snapshot of the data at the specified time. Format: YYYYMMDD_HHMMSS
	Timecode       *string `form:"timecode,omitempty" json:"timecode,omitempty"`
	UseLatestGames *bool   `form:"useLatestGames,omitempty" json:"useLatestGames,omitempty"`

	// OpponentId A unique identifier for the opposing team. Must be used with Team ID
	OpponentId *[]int32 `form:"opponentId,omitempty" json:"opponentId,omitempty"`

	// PublicFacing Return public, non-public or all games. Format: Public Facing = 'Y', Non-Public Facing = 'N', All = 'A'
	PublicFacing *PublicFacingEnum `form:"publicFacing,omitempty" json:"publicFacing,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Schedule1Params defines parameters for Schedule1.
type Schedule1Params struct {
	// CalendarTypes Comma delimited list of type of calendar types
	CalendarTypes *[]CalendarTypes `form:"calendarTypes,omitempty" json:"calendarTypes,omitempty"`

	// EventTypes Comma delimited list of type of events. <b>Note: Don't Use. This will be deprecated in favor of calendarTypes</b>
	EventTypes *[]CalendarTypes `form:"eventTypes,omitempty" json:"eventTypes,omitempty"`

	// ScheduleEventTypes Comma delimited list of type of event types
	ScheduleEventTypes *[]ScheduleEventTypes `form:"scheduleEventTypes,omitempty" json:"scheduleEventTypes,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *[]int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *[]int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// SportId Top level organization of a sport
	SportId *[]int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// GamePk Unique Primary Key Representing a Game
	GamePk *int32 `form:"gamePk,omitempty" json:"gamePk,omitempty"`

	// GamePks Comma delimited list of unique primary keys
	GamePks *[]int32 `form:"gamePks,omitempty" json:"gamePks,omitempty"`

	// EventIds A unique identifier for non-game event
	EventIds *[]int32 `form:"eventIds,omitempty" json:"eventIds,omitempty"`

	// VenueIds Unique Venue Identifier
	VenueIds *[]int32 `form:"venueIds,omitempty" json:"venueIds,omitempty"`

	// PerformerIds A unique identifier for non-team event performers
	PerformerIds *[]int32 `form:"performerIds,omitempty" json:"performerIds,omitempty"`

	// GameTypes Comma delimited list of type of Game. Available types in /api/v1/gameTypes
	GameTypes *[]GameTypeEnum `form:"gameTypes,omitempty" json:"gameTypes,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *[]GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Season Season of play
	Season *[]string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// Timecode Use this parameter to return a snapshot of the data at the specified time. Format: YYYYMMDD_HHMMSS
	Timecode       *string `form:"timecode,omitempty" json:"timecode,omitempty"`
	UseLatestGames *bool   `form:"useLatestGames,omitempty" json:"useLatestGames,omitempty"`

	// OpponentId A unique identifier for the opposing team. Must be used with Team ID
	OpponentId *[]int32 `form:"opponentId,omitempty" json:"opponentId,omitempty"`

	// PublicFacing Return public, non-public or all games. Format: Public Facing = 'Y', Non-Public Facing = 'N', All = 'A'
	PublicFacing *PublicFacingEnum `form:"publicFacing,omitempty" json:"publicFacing,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields               *[]string `form:"fields,omitempty" json:"fields,omitempty"`
	UsingPrivateEndpoint bool      `form:"usingPrivateEndpoint" json:"usingPrivateEndpoint"`
}

// ScheduleEventTypesParams defines parameters for ScheduleEventTypes.
type ScheduleEventTypesParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// SeasonsParams defines parameters for Seasons.
type SeasonsParams struct {
	// Season Season of play
	Season *[]string `form:"season,omitempty" json:"season,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// WithGameTypeDates Retrieve dates for each game type
	WithGameTypeDates *bool `form:"withGameTypeDates,omitempty" json:"withGameTypeDates,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// AllSeasonsParams defines parameters for AllSeasons.
type AllSeasonsParams struct {
	// DivisionId Unique Division Identifier
	DivisionId *int32 `form:"divisionId,omitempty" json:"divisionId,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// WithGameTypeDates Retrieve dates for each game type
	WithGameTypeDates *bool `form:"withGameTypeDates,omitempty" json:"withGameTypeDates,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Seasons1Params defines parameters for Seasons1.
type Seasons1Params struct {
	// Season Season of play
	Season *[]string `form:"season,omitempty" json:"season,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// WithGameTypeDates Retrieve dates for each game type
	WithGameTypeDates *bool `form:"withGameTypeDates,omitempty" json:"withGameTypeDates,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// SitCodesParams defines parameters for SitCodes.
type SitCodesParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// StatGroup Category of statistic to return. Available types in /api/v1/statGroups
	StatGroup *StatGroup `form:"statGroup,omitempty" json:"statGroup,omitempty"`
}

// SkyParams defines parameters for Sky.
type SkyParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// SportsParams defines parameters for Sports.
type SportsParams struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// HasStats Returns sports that have individual player stats
	HasStats *bool `form:"hasStats,omitempty" json:"hasStats,omitempty"`

	// ActiveStatus Flag for fetching sports that are currently active (Y), inactive (N), pending (P), or all teams (B)
	ActiveStatus *SportActiveStatusEnum `form:"activeStatus,omitempty" json:"activeStatus,omitempty"`
}

// Sports1Params defines parameters for Sports1.
type Sports1Params struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// HasStats Returns sports that have individual player stats
	HasStats *bool `form:"hasStats,omitempty" json:"hasStats,omitempty"`

	// ActiveStatus Flag for fetching sports that are currently active (Y), inactive (N), pending (P), or all teams (B)
	ActiveStatus *SportActiveStatusEnum `form:"activeStatus,omitempty" json:"activeStatus,omitempty"`
}

// AllSportBallotParams defines parameters for AllSportBallot.
type AllSportBallotParams struct {
	// Season season
	Season string    `form:"season" json:"season"`
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// SportPlayersParams defines parameters for SportPlayers.
type SportPlayersParams struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// HasStats Returns sports that have individual player stats
	HasStats *bool `form:"hasStats,omitempty" json:"hasStats,omitempty"`

	// Accent Boolean value to specify wanting a person's name with accents or without
	Accent *bool `form:"accent,omitempty" json:"accent,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Standings1Params defines parameters for Standings1.
type Standings1Params struct {
	// LeagueId Unique League Identifier
	LeagueId *[]int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// StandingsTypes Type of season. Available types in /api/v1/standingsTypes
	StandingsTypes *[]StandingsType `form:"standingsTypes,omitempty" json:"standingsTypes,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// IncludeMLB Determines whether to include major league teams when using the 'BY_ORGANIZATION' standings type
	IncludeMLB *bool `form:"includeMLB,omitempty" json:"includeMLB,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// StandingsParams defines parameters for Standings.
type StandingsParams struct {
	// LeagueId Unique League Identifier
	LeagueId *[]int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// StandingsTypes Type of season. Available types in /api/v1/standingsTypes
	StandingsTypes *[]StandingsType `form:"standingsTypes,omitempty" json:"standingsTypes,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// IncludeMLB Determines whether to include major league teams when using the 'BY_ORGANIZATION' standings type
	IncludeMLB *bool `form:"includeMLB,omitempty" json:"includeMLB,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Stats2Params defines parameters for Stats2.
type Stats2Params struct {
	// Stats Type of statistics. Format: Individual, Team, Career, etc. Available types in /api/v1/statTypes
	Stats []StatType `form:"stats" json:"stats"`

	// PersonId Unique Player Identifier. Format: 434538, 429665, etc
	PersonId *int32 `form:"personId,omitempty" json:"personId,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// TeamIds Comma delimited list of Unique Team identifiers
	TeamIds *[]int32 `form:"teamIds,omitempty" json:"teamIds,omitempty"`

	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group []StatGroup `form:"group" json:"group"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// SportIds Comma delimited list of top level organizations of a sport
	SportIds *[]int32 `form:"sportIds,omitempty" json:"sportIds,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// LeagueListId Unique League List Identifier
	LeagueListId *LeagueListsEnum `form:"leagueListId,omitempty" json:"leagueListId,omitempty"`

	// Metrics Name of metric(s) for metric log stats.  Available metrics in /api/v1/metrics
	Metrics *[]MetricType `form:"metrics,omitempty" json:"metrics,omitempty"`

	// GamePk Unique Primary Key Representing a Game
	GamePk *int32 `form:"gamePk,omitempty" json:"gamePk,omitempty"`

	// BatterTeamId A unique identifier for the batter's team
	BatterTeamId *[]int32 `form:"batterTeamId,omitempty" json:"batterTeamId,omitempty"`

	// PitcherTeamId A unique identifier for the pitcher's team
	PitcherTeamId *[]int32 `form:"pitcherTeamId,omitempty" json:"pitcherTeamId,omitempty"`

	// BatterId Unique Player Identifier. Format: 434538, 429665, etc
	BatterId *int32 `form:"batterId,omitempty" json:"batterId,omitempty"`

	// PitcherId Unique Player Identifier. Format: 434538, 429665, etc
	PitcherId *int32 `form:"pitcherId,omitempty" json:"pitcherId,omitempty"`

	// SitCodes Situation code for a given stat split.
	SitCodes *[]string `form:"sitCodes,omitempty" json:"sitCodes,omitempty"`

	// CombineSits If true, gathers stats where all of the situational criteria are met. If false, returns stats where any of the situational criteria are met. Default: false
	CombineSits *bool `form:"combineSits,omitempty" json:"combineSits,omitempty"`

	// OpposingTeamId A unique identifier for the opposing team. Must be used with Team ID
	OpposingTeamId *int32    `form:"opposingTeamId,omitempty" json:"opposingTeamId,omitempty"`
	Fields         *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// SortStat Baseball stat to sort splits by.
	SortStat *BaseballStatsEnum `form:"sortStat,omitempty" json:"sortStat,omitempty"`

	// Order The order of sorting, ascending or descending
	Order *SortOrderEnum `form:"order,omitempty" json:"order,omitempty"`

	// PlayerPool Return "ALL" or only "QUALIFIED" players based on plate appearances.
	PlayerPool *PlayerPoolEnum `form:"playerPool,omitempty" json:"playerPool,omitempty"`

	// Position Position number. Format: 1, 2, 3, etc
	Position *[]BaseballPosition `form:"position,omitempty" json:"position,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// DaysBack Returns results from the last 'X' days (Starting from yesterday).
	DaysBack *int32 `form:"daysBack,omitempty" json:"daysBack,omitempty"`

	// GamesBack Returns results from the last 'X' games played.
	GamesBack *int32 `form:"gamesBack,omitempty" json:"gamesBack,omitempty"`

	// ExcludeTradedPlayers Excludes players who have since been traded from the input team
	ExcludeTradedPlayers *bool `form:"excludeTradedPlayers,omitempty" json:"excludeTradedPlayers,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetOutsAboveAverageParams defines parameters for GetOutsAboveAverage.
type GetOutsAboveAverageParams struct {
	GamePk   int32   `form:"gamePk" json:"gamePk"`
	Timecode *string `form:"timecode,omitempty" json:"timecode,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetSprayChartParams defines parameters for GetSprayChart.
type GetSprayChartParams struct {
	GamePk   int32   `form:"gamePk" json:"gamePk"`
	Timecode *string `form:"timecode,omitempty" json:"timecode,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetStolenBaseProbabilityParams defines parameters for GetStolenBaseProbability.
type GetStolenBaseProbabilityParams struct {
	GamePk   int32   `form:"gamePk" json:"gamePk"`
	Timecode *string `form:"timecode,omitempty" json:"timecode,omitempty"`
}

// GroupedStatsParams defines parameters for GroupedStats.
type GroupedStatsParams struct {
	// Stats Type of statistics. Format: Individual, Team, Career, etc. Available types in /api/v1/statTypes
	Stats []StatType `form:"stats" json:"stats"`

	// PersonId Unique Player Identifier. Format: 434538, 429665, etc
	PersonId *int32 `form:"personId,omitempty" json:"personId,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// TeamIds Comma delimited list of Unique Team identifiers
	TeamIds *[]int32 `form:"teamIds,omitempty" json:"teamIds,omitempty"`

	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group []StatGroup `form:"group" json:"group"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// SportIds Comma delimited list of top level organizations of a sport
	SportIds *[]int32 `form:"sportIds,omitempty" json:"sportIds,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// LeagueListId Unique League List Identifier
	LeagueListId *LeagueListsEnum `form:"leagueListId,omitempty" json:"leagueListId,omitempty"`

	// Metrics Name of metric(s) for metric log stats.  Available metrics in /api/v1/metrics
	Metrics *[]MetricType `form:"metrics,omitempty" json:"metrics,omitempty"`

	// GamePk Unique Primary Key Representing a Game
	GamePk *int32 `form:"gamePk,omitempty" json:"gamePk,omitempty"`

	// BatterTeamId A unique identifier for the batter's team
	BatterTeamId *[]int32 `form:"batterTeamId,omitempty" json:"batterTeamId,omitempty"`

	// PitcherTeamId A unique identifier for the pitcher's team
	PitcherTeamId *[]int32 `form:"pitcherTeamId,omitempty" json:"pitcherTeamId,omitempty"`

	// BatterId Unique Player Identifier. Format: 434538, 429665, etc
	BatterId *int32 `form:"batterId,omitempty" json:"batterId,omitempty"`

	// PitcherId Unique Player Identifier. Format: 434538, 429665, etc
	PitcherId *int32 `form:"pitcherId,omitempty" json:"pitcherId,omitempty"`

	// SitCodes Situation code for a given stat split.
	SitCodes *[]string `form:"sitCodes,omitempty" json:"sitCodes,omitempty"`

	// CombineSits If true, gathers stats where all of the situational criteria are met. If false, returns stats where any of the situational criteria are met. Default: false
	CombineSits *bool `form:"combineSits,omitempty" json:"combineSits,omitempty"`

	// OpposingTeamId A unique identifier for the opposing team. Must be used with Team ID
	OpposingTeamId *int32 `form:"opposingTeamId,omitempty" json:"opposingTeamId,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// SortStat Baseball stat to sort splits by.
	SortStat *BaseballStatsEnum `form:"sortStat,omitempty" json:"sortStat,omitempty"`

	// Order The order of sorting, ascending or descending
	Order *SortOrderEnum `form:"order,omitempty" json:"order,omitempty"`

	// PlayerPool Return "ALL" or only "QUALIFIED" players based on plate appearances.
	PlayerPool *PlayerPoolEnum `form:"playerPool,omitempty" json:"playerPool,omitempty"`

	// Position Position number. Format: 1, 2, 3, etc
	Position *[]BaseballPosition `form:"position,omitempty" json:"position,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// DaysBack Returns results from the last 'X' days (Starting from yesterday).
	DaysBack *int32 `form:"daysBack,omitempty" json:"daysBack,omitempty"`

	// GamesBack Returns results from the last 'X' games played.
	GamesBack *int32 `form:"gamesBack,omitempty" json:"gamesBack,omitempty"`

	// ExcludeTradedPlayers Excludes players who have since been traded from the input team
	ExcludeTradedPlayers *bool `form:"excludeTradedPlayers,omitempty" json:"excludeTradedPlayers,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// StatFields Baseball stat fields to populate
	StatFields *[]StatField `form:"statFields,omitempty" json:"statFields,omitempty"`

	// SortField Baseball statField to sort on.  If no statField is given, sortField defaults to BASIC.  If 1 statField is given, that is the default sortField.
	SortField *StatField `form:"sortField,omitempty" json:"sortField,omitempty"`
}

// Leaders2Params defines parameters for Leaders2.
type Leaders2Params struct {
	LeaderCategories *[]PersonLeadersEnum    `form:"leaderCategories,omitempty" json:"leaderCategories,omitempty"`
	LeaderGameTypes  *[]GameTypeEnum         `form:"leaderGameTypes,omitempty" json:"leaderGameTypes,omitempty"`
	StatGroup        *[]StatGroup            `form:"statGroup,omitempty" json:"statGroup,omitempty"`
	Season           *string                 `form:"season,omitempty" json:"season,omitempty"`
	Expand           *[]ExpandEnum           `form:"expand,omitempty" json:"expand,omitempty"`
	SportId          *int32                  `form:"sportId,omitempty" json:"sportId,omitempty"`
	SportIds         *[]int32                `form:"sportIds,omitempty" json:"sportIds,omitempty"`
	Stats            *[]StatType             `form:"stats,omitempty" json:"stats,omitempty"`
	Limit            *int32                  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset           *int32                  `form:"offset,omitempty" json:"offset,omitempty"`
	TeamId           *int32                  `form:"teamId,omitempty" json:"teamId,omitempty"`
	TeamIds          *[]int32                `form:"teamIds,omitempty" json:"teamIds,omitempty"`
	LeagueId         *int32                  `form:"leagueId,omitempty" json:"leagueId,omitempty"`
	LeagueIds        *[]int32                `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`
	LeagueListId     *LeagueListsEnum        `form:"leagueListId,omitempty" json:"leagueListId,omitempty"`
	PlayerPool       *PlayerPoolEnum         `form:"playerPool,omitempty" json:"playerPool,omitempty"`
	StatType         *StatType               `form:"statType,omitempty" json:"statType,omitempty"`
	PlayerActive     *PlayerActiveStatusEnum `form:"playerActive,omitempty" json:"playerActive,omitempty"`
	Position         *[]BaseballPosition     `form:"position,omitempty" json:"position,omitempty"`
	SitCodes         *[]string               `form:"sitCodes,omitempty" json:"sitCodes,omitempty"`
	OpposingTeamId   *int32                  `form:"opposingTeamId,omitempty" json:"opposingTeamId,omitempty"`
	StartDate        *openapi_types.Date     `form:"startDate,omitempty" json:"startDate,omitempty"`
	EndDate          *openapi_types.Date     `form:"endDate,omitempty" json:"endDate,omitempty"`
	DaysBack         *int32                  `form:"daysBack,omitempty" json:"daysBack,omitempty"`
	GamesBack        *int32                  `form:"gamesBack,omitempty" json:"gamesBack,omitempty"`
	GroupBy          *GroupByEnum            `form:"groupBy,omitempty" json:"groupBy,omitempty"`
	Fields           *[]string               `form:"fields,omitempty" json:"fields,omitempty"`
}

// MetricStatsParams defines parameters for MetricStats.
type MetricStatsParams struct {
	// PersonId Unique Player Identifier. Format: 434538, 429665, etc
	PersonId *int32 `form:"personId,omitempty" json:"personId,omitempty"`

	// PersonIds Unique Player Identifier. Format: 434538, 429665, etc
	PersonIds *[]int32 `form:"personIds,omitempty" json:"personIds,omitempty"`

	// BatterId Unique Player Identifier. Format: 434538, 429665, etc
	BatterId *int32 `form:"batterId,omitempty" json:"batterId,omitempty"`

	// PitcherId Unique Player Identifier. Format: 434538, 429665, etc
	PitcherId *int32 `form:"pitcherId,omitempty" json:"pitcherId,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// Stats Type of statistics. Format: Individual, Team, Career, etc. Available types in /api/v1/statTypes
	Stats []StatType `form:"stats" json:"stats"`

	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group *[]StatGroup `form:"group,omitempty" json:"group,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// OpposingTeamId A unique identifier for the opposing team. Must be used with Team ID
	OpposingTeamId *int32 `form:"opposingTeamId,omitempty" json:"opposingTeamId,omitempty"`

	// OpposingPlayerId A unique identifier for the opposing team
	OpposingPlayerId *int32 `form:"opposingPlayerId,omitempty" json:"opposingPlayerId,omitempty"`

	// Position All of the details of a player's position
	Position *[]BaseballPosition `form:"position,omitempty" json:"position,omitempty"`

	// EventType Type of event
	EventType *[]EventType `form:"eventType,omitempty" json:"eventType,omitempty"`

	// PitchType Classification of pitch (fastball, curveball, etc...)
	PitchType *[]string `form:"pitchType,omitempty" json:"pitchType,omitempty"`

	// HitTrajectory Trajectory of hit (line drive, fly ball, etc...)
	HitTrajectory *[]HitTrajectory `form:"hitTrajectory,omitempty" json:"hitTrajectory,omitempty"`

	// BatSide Bat side of hitter
	BatSide *string `form:"batSide,omitempty" json:"batSide,omitempty"`

	// PitchHand Handedness of pitcher
	PitchHand *string `form:"pitchHand,omitempty" json:"pitchHand,omitempty"`

	// VenueId All of the details of a venue
	VenueId *[]int32 `form:"venueId,omitempty" json:"venueId,omitempty"`

	// Metrics Name of metric(s) for metric log stats.  Available metrics in /api/v1/metrics
	Metrics []MetricType `form:"metrics" json:"metrics"`

	// GamePk Unique Primary Key Representing a Game
	GamePk *int32 `form:"gamePk,omitempty" json:"gamePk,omitempty"`

	// MinValue Minimum value to filter on
	MinValue *float64 `form:"minValue,omitempty" json:"minValue,omitempty"`

	// MaxValue Maximum value to filter on
	MaxValue *float64 `form:"maxValue,omitempty" json:"maxValue,omitempty"`

	// Percentile Only return averages above this percentile. used for best effort plays
	Percentile *int32 `form:"percentile,omitempty" json:"percentile,omitempty"`

	// MinOccurrences Minimum occurrences to filter upon
	MinOccurrences *int32 `form:"minOccurrences,omitempty" json:"minOccurrences,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order of sorting, ascending or descending
	Order *SortOrderEnum `form:"order,omitempty" json:"order,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// BatterTeamId A unique identifier for the batter's team
	BatterTeamId *[]int32 `form:"batterTeamId,omitempty" json:"batterTeamId,omitempty"`

	// PitcherTeamId A unique identifier for the pitcher's team
	PitcherTeamId *[]int32 `form:"pitcherTeamId,omitempty" json:"pitcherTeamId,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
	Debug  *bool     `form:"debug,omitempty" json:"debug,omitempty"`
}

// BeastStatsParams defines parameters for BeastStats.
type BeastStatsParams struct {
	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group []StatGroup `form:"group" json:"group"`

	// GamePks Comma delimited list of unique primary keys
	GamePks *[]int32 `form:"gamePks,omitempty" json:"gamePks,omitempty"`

	// PlayIds Comma delimited list of unique play identifiers
	PlayIds *[]string `form:"playIds,omitempty" json:"playIds,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// GameTypes Type of Game. Available types in /api/v1/gameTypes
	GameTypes *[]GameTypeEnum `form:"gameTypes,omitempty" json:"gameTypes,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// StartDate Date of Game. Format: YYYY-MM-DD
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate Date of Game. Format: YYYY-MM-DD
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// TeamIds Unique Team Identifier. Format: 141, 147, etc
	TeamIds *[]int32 `form:"teamIds,omitempty" json:"teamIds,omitempty"`

	// PitcherTeamIds Unique Team Identifier. Format: 141, 147, etc
	PitcherTeamIds *[]int32 `form:"pitcherTeamIds,omitempty" json:"pitcherTeamIds,omitempty"`

	// BatterTeamIds Unique Team Identifier. Format: 141, 147, etc
	BatterTeamIds *[]int32 `form:"batterTeamIds,omitempty" json:"batterTeamIds,omitempty"`

	// SportIds Comma delimited list of top level organizations of a sport
	SportIds *[]int32 `form:"sportIds,omitempty" json:"sportIds,omitempty"`

	// PitcherSportIds Comma delimited list of top level organizations of a sport
	PitcherSportIds *[]int32 `form:"pitcherSportIds,omitempty" json:"pitcherSportIds,omitempty"`

	// BatterSportIds Comma delimited list of top level organizations of a sport
	BatterSportIds *[]int32 `form:"batterSportIds,omitempty" json:"batterSportIds,omitempty"`

	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// PitcherLeagueIds Comma delimited list of Unique league identifiers
	PitcherLeagueIds *[]int32 `form:"pitcherLeagueIds,omitempty" json:"pitcherLeagueIds,omitempty"`

	// BatterLeagueIds Comma delimited list of Unique league identifiers
	BatterLeagueIds *[]int32 `form:"batterLeagueIds,omitempty" json:"batterLeagueIds,omitempty"`

	// DivisionIds Comma delimited list of Unique League Identifiers
	DivisionIds *[]int32 `form:"divisionIds,omitempty" json:"divisionIds,omitempty"`

	// PitcherDivisionIds Comma delimited list of Unique League Identifiers
	PitcherDivisionIds *[]int32 `form:"pitcherDivisionIds,omitempty" json:"pitcherDivisionIds,omitempty"`

	// BatterDivisionIds Comma delimited list of Unique League Identifiers
	BatterDivisionIds *[]int32 `form:"batterDivisionIds,omitempty" json:"batterDivisionIds,omitempty"`

	// PitchersOnTeamIds Unique Team Identifier. Format: 141, 147, etc
	PitchersOnTeamIds *[]int32 `form:"pitchersOnTeamIds,omitempty" json:"pitchersOnTeamIds,omitempty"`

	// BattersOnTeamIds Unique Team Identifier. Format: 141, 147, etc
	BattersOnTeamIds *[]int32 `form:"battersOnTeamIds,omitempty" json:"battersOnTeamIds,omitempty"`

	// PlayerIds A unique identifier for a player
	PlayerIds *[]int32 `form:"playerIds,omitempty" json:"playerIds,omitempty"`

	// PlayerPool Return "ALL" or only "QUALIFIED" players based on plate appearances.
	PlayerPool *PlayerPoolEnum `form:"playerPool,omitempty" json:"playerPool,omitempty"`

	// PitcherIds A unique identifier for a player
	PitcherIds *[]int32 `form:"pitcherIds,omitempty" json:"pitcherIds,omitempty"`

	// BatterIds A unique identifier for a player
	BatterIds *[]int32 `form:"batterIds,omitempty" json:"batterIds,omitempty"`

	// CatcherIds A unique identifier for a player
	CatcherIds *[]int32 `form:"catcherIds,omitempty" json:"catcherIds,omitempty"`

	// FirstBasemanIds A unique identifier for a player
	FirstBasemanIds *[]int32 `form:"firstBasemanIds,omitempty" json:"firstBasemanIds,omitempty"`

	// SecondBasemanIds A unique identifier for a player
	SecondBasemanIds *[]int32 `form:"secondBasemanIds,omitempty" json:"secondBasemanIds,omitempty"`

	// ThirdBasemanIds A unique identifier for a player
	ThirdBasemanIds *[]int32 `form:"thirdBasemanIds,omitempty" json:"thirdBasemanIds,omitempty"`

	// ShortstopIds A unique identifier for a player
	ShortstopIds *[]int32 `form:"shortstopIds,omitempty" json:"shortstopIds,omitempty"`

	// LeftFielderIds A unique identifier for a player
	LeftFielderIds *[]int32 `form:"leftFielderIds,omitempty" json:"leftFielderIds,omitempty"`

	// CenterFielderIds A unique identifier for a player
	CenterFielderIds *[]int32 `form:"centerFielderIds,omitempty" json:"centerFielderIds,omitempty"`

	// RightFielderIds A unique identifier for a player
	RightFielderIds *[]int32 `form:"rightFielderIds,omitempty" json:"rightFielderIds,omitempty"`

	// RunnerFirstIds A unique identifier for a player
	RunnerFirstIds *[]int32 `form:"runnerFirstIds,omitempty" json:"runnerFirstIds,omitempty"`

	// RunnerSecondIds A unique identifier for a player
	RunnerSecondIds *[]int32 `form:"runnerSecondIds,omitempty" json:"runnerSecondIds,omitempty"`

	// RunnerThirdIds A unique identifier for a player
	RunnerThirdIds *[]int32 `form:"runnerThirdIds,omitempty" json:"runnerThirdIds,omitempty"`

	// VenueIds Unique Venue Identifier
	VenueIds *[]int32 `form:"venueIds,omitempty" json:"venueIds,omitempty"`

	// PitchHand Handedness of pitcher
	PitchHand *string `form:"pitchHand,omitempty" json:"pitchHand,omitempty"`

	// BatSide Bat side of hitter
	BatSide *string `form:"batSide,omitempty" json:"batSide,omitempty"`

	// PitchTypes Classification of pitch (fastball, curveball, etc...)
	PitchTypes *[]PitchType `form:"pitchTypes,omitempty" json:"pitchTypes,omitempty"`

	// PitchCodes Result of the pitch (ball, called strike, etc...)
	PitchCodes *[]PitchCode `form:"pitchCodes,omitempty" json:"pitchCodes,omitempty"`

	// EventTypes Type of event
	EventTypes *[]EventType `form:"eventTypes,omitempty" json:"eventTypes,omitempty"`

	// Positions All of the details of a player's position
	Positions *[]BaseballPosition `form:"positions,omitempty" json:"positions,omitempty"`

	// PrimaryPositions All of the details of a player's position
	PrimaryPositions *[]BaseballPosition `form:"primaryPositions,omitempty" json:"primaryPositions,omitempty"`

	// MinPitchSpeed Minimum value to filter on
	MinPitchSpeed *float64 `form:"minPitchSpeed,omitempty" json:"minPitchSpeed,omitempty"`

	// MaxPitchSpeed Maximum value to filter on
	MaxPitchSpeed *float64 `form:"maxPitchSpeed,omitempty" json:"maxPitchSpeed,omitempty"`

	// MinSpinRate Minimum value to filter on
	MinSpinRate *float64 `form:"minSpinRate,omitempty" json:"minSpinRate,omitempty"`

	// MaxSpinRate Maximum value to filter on
	MaxSpinRate *float64 `form:"maxSpinRate,omitempty" json:"maxSpinRate,omitempty"`

	// MinExtension Minimum value to filter on
	MinExtension *float64 `form:"minExtension,omitempty" json:"minExtension,omitempty"`

	// MaxExtension Maximum value to filter on
	MaxExtension *float64 `form:"maxExtension,omitempty" json:"maxExtension,omitempty"`

	// MinExitVelocityAgainst Minimum value to filter on
	MinExitVelocityAgainst *float64 `form:"minExitVelocityAgainst,omitempty" json:"minExitVelocityAgainst,omitempty"`

	// MaxExitVelocityAgainst Maximum value to filter on
	MaxExitVelocityAgainst *float64 `form:"maxExitVelocityAgainst,omitempty" json:"maxExitVelocityAgainst,omitempty"`

	// MinLaunchAngleAgainst Minimum value to filter on
	MinLaunchAngleAgainst *float64 `form:"minLaunchAngleAgainst,omitempty" json:"minLaunchAngleAgainst,omitempty"`

	// MaxLaunchAngleAgainst Maximum value to filter on
	MaxLaunchAngleAgainst *float64 `form:"maxLaunchAngleAgainst,omitempty" json:"maxLaunchAngleAgainst,omitempty"`

	// MinExitVelocity Minimum value to filter on
	MinExitVelocity *float64 `form:"minExitVelocity,omitempty" json:"minExitVelocity,omitempty"`

	// MaxExitVelocity Maximum value to filter on
	MaxExitVelocity *float64 `form:"maxExitVelocity,omitempty" json:"maxExitVelocity,omitempty"`

	// MinLaunchAngle Minimum value to filter on
	MinLaunchAngle *float64 `form:"minLaunchAngle,omitempty" json:"minLaunchAngle,omitempty"`

	// MaxLaunchAngle Maximum value to filter on
	MaxLaunchAngle *float64 `form:"maxLaunchAngle,omitempty" json:"maxLaunchAngle,omitempty"`

	// MinHomeRunDistance Minimum value to filter on
	MinHomeRunDistance *float64 `form:"minHomeRunDistance,omitempty" json:"minHomeRunDistance,omitempty"`

	// MaxHomeRunDistance Maximum value to filter on
	MaxHomeRunDistance *float64 `form:"maxHomeRunDistance,omitempty" json:"maxHomeRunDistance,omitempty"`

	// MinHitDistance Minimum value to filter on
	MinHitDistance *float64 `form:"minHitDistance,omitempty" json:"minHitDistance,omitempty"`

	// MaxHitDistance Maximum value to filter on
	MaxHitDistance *float64 `form:"maxHitDistance,omitempty" json:"maxHitDistance,omitempty"`

	// MinHangTime Minimum value to filter on
	MinHangTime *float64 `form:"minHangTime,omitempty" json:"minHangTime,omitempty"`

	// MaxHangTime Maximum value to filter on
	MaxHangTime *float64 `form:"maxHangTime,omitempty" json:"maxHangTime,omitempty"`

	// MinHitProbability Minimum value to filter on
	MinHitProbability *float64 `form:"minHitProbability,omitempty" json:"minHitProbability,omitempty"`

	// MaxHitProbability Maximum value to filter on
	MaxHitProbability *float64 `form:"maxHitProbability,omitempty" json:"maxHitProbability,omitempty"`

	// MinCatchProbability Minimum value to filter on
	MinCatchProbability *float64 `form:"minCatchProbability,omitempty" json:"minCatchProbability,omitempty"`

	// MaxCatchProbability Maximum value to filter on
	MaxCatchProbability *float64 `form:"maxCatchProbability,omitempty" json:"maxCatchProbability,omitempty"`

	// MinAttackAngle Minimum value to filter on
	MinAttackAngle *float64 `form:"minAttackAngle,omitempty" json:"minAttackAngle,omitempty"`

	// MaxAttackAngle Maximum value to filter on
	MaxAttackAngle *float64 `form:"maxAttackAngle,omitempty" json:"maxAttackAngle,omitempty"`

	// MinBatSpeed Minimum value to filter on
	MinBatSpeed *float64 `form:"minBatSpeed,omitempty" json:"minBatSpeed,omitempty"`

	// MaxBatSpeed Maximum value to filter on
	MaxBatSpeed *float64 `form:"maxBatSpeed,omitempty" json:"maxBatSpeed,omitempty"`

	// MinHomeRunXBallparks Minimum value to filter on
	MinHomeRunXBallparks *float64 `form:"minHomeRunXBallparks,omitempty" json:"minHomeRunXBallparks,omitempty"`

	// MaxHomeRunXBallparks Maximum value to filter on
	MaxHomeRunXBallparks *float64 `form:"maxHomeRunXBallparks,omitempty" json:"maxHomeRunXBallparks,omitempty"`

	// IsBarrel Whether or not a play resulted in a barreled ball
	IsBarrel *bool `form:"isBarrel,omitempty" json:"isBarrel,omitempty"`

	// HitTrajectories Trajectory of hit (line drive, fly ball, etc...)
	HitTrajectories *[]HitTrajectory `form:"hitTrajectories,omitempty" json:"hitTrajectories,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// GroupBy Group stats by PLAYER, TEAM, SEASON, VENUE, SPORT or STAT_GROUP
	GroupBy *[]GroupByEnum `form:"groupBy,omitempty" json:"groupBy,omitempty"`

	// CompareOver Group stats by PLAYER, TEAM, SEASON, VENUE, SPORT or STAT_GROUP
	CompareOver *[]GroupByEnum `form:"compareOver,omitempty" json:"compareOver,omitempty"`

	// SortStat Baseball stat to sort splits by.
	SortStat *BaseballStatsEnum `form:"sortStat,omitempty" json:"sortStat,omitempty"`

	// SortModifier The prefix modifier for the sort stat.  avg, min, max. I.E minExitVelocity, maxLaunchAngle, avgHitDistance
	SortModifier *AggregateSortTypeEnum `form:"sortModifier,omitempty" json:"sortModifier,omitempty"`

	// SortOrder The order of sorting, ascending or descending
	SortOrder *SortOrderEnum `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// Percentile Only return averages above this percentile. used for best effort plays
	Percentile *int32 `form:"percentile,omitempty" json:"percentile,omitempty"`

	// MinOccurrences Minimum occurrences to filter upon
	MinOccurrences *int32 `form:"minOccurrences,omitempty" json:"minOccurrences,omitempty"`

	// MinPlateAppearances Minimum occurrences to filter upon
	MinPlateAppearances *int32 `form:"minPlateAppearances,omitempty" json:"minPlateAppearances,omitempty"`

	// MinInnings Minimum occurrences to filter upon
	MinInnings *int32 `form:"minInnings,omitempty" json:"minInnings,omitempty"`

	// QualifierRate Minimum occurrences to filter upon
	QualifierRate *float64 `form:"qualifierRate,omitempty" json:"qualifierRate,omitempty"`

	// SitCodes Situation code for a given stat split.
	SitCodes *[]string `form:"sitCodes,omitempty" json:"sitCodes,omitempty"`

	// ShowTotals Columns to return totals
	ShowTotals *bool `form:"showTotals,omitempty" json:"showTotals,omitempty"`

	// IncludeNullMetrics Show events with null metrics
	IncludeNullMetrics *bool `form:"includeNullMetrics,omitempty" json:"includeNullMetrics,omitempty"`

	// StatFields Baseball stat fields to populate
	StatFields *[]StatField `form:"statFields,omitempty" json:"statFields,omitempty"`

	// AtBatNumbers The at bat number of a given game. Format: 1, 2, 3, etc
	AtBatNumbers *[]int32 `form:"atBatNumbers,omitempty" json:"atBatNumbers,omitempty"`

	// PitchNumbers The pitch number of a given game. Format: 1, 2, 3, etc
	PitchNumbers *[]int32 `form:"pitchNumbers,omitempty" json:"pitchNumbers,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
	Debug  *bool     `form:"debug,omitempty" json:"debug,omitempty"`

	// ActiveStatus Whether or not a player is active
	ActiveStatus *PlayerActiveStatusEnum `form:"activeStatus,omitempty" json:"activeStatus,omitempty"`
}

// StatSearchConfigParams defines parameters for StatSearchConfig.
type StatSearchConfigParams struct {
	// FilterLevel Categories of filters for stat search
	FilterLevel *FilterLevelEnum `form:"filterLevel,omitempty" json:"filterLevel,omitempty"`

	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group *StatGroup `form:"group,omitempty" json:"group,omitempty"`
}

// StatSearchGroupByTypesParams defines parameters for StatSearchGroupByTypes.
type StatSearchGroupByTypesParams struct {
	// FilterLevel Categories of filters for stat search
	FilterLevel *FilterLevelEnum `form:"filterLevel,omitempty" json:"filterLevel,omitempty"`
}

// StatSearchParamsParams defines parameters for StatSearchParams.
type StatSearchParamsParams struct {
	// FilterLevel Categories of filters for stat search
	FilterLevel *FilterLevelEnum `form:"filterLevel,omitempty" json:"filterLevel,omitempty"`
}

// StatSearchStatsParams defines parameters for StatSearchStats.
type StatSearchStatsParams struct {
	// FilterLevel Categories of filters for stat search
	FilterLevel *FilterLevelEnum `form:"filterLevel,omitempty" json:"filterLevel,omitempty"`
}

// GetStreaksParams defines parameters for GetStreaks.
type GetStreaksParams struct {
	StreakOrg       *OrganizationType `form:"streakOrg,omitempty" json:"streakOrg,omitempty"`
	StreakStat      *[]StreakStatEnum `form:"streakStat,omitempty" json:"streakStat,omitempty"`
	StreakSpan      *StreakSpanEnum   `form:"streakSpan,omitempty" json:"streakSpan,omitempty"`
	StreakLevel     *StreakLevelEnum  `form:"streakLevel,omitempty" json:"streakLevel,omitempty"`
	StreakThreshold *int32            `form:"streakThreshold,omitempty" json:"streakThreshold,omitempty"`
	Inverse         *bool             `form:"inverse,omitempty" json:"inverse,omitempty"`
	StartersOnly    *bool             `form:"startersOnly,omitempty" json:"startersOnly,omitempty"`

	// StatGroup Category of statistic to return. Available types in /api/v1/statGroups
	StatGroup *[]StatGroup `form:"statGroup,omitempty" json:"statGroup,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *[]GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Season Season of play
	Season *[]string `form:"season,omitempty" json:"season,omitempty"`

	// TeamId Unique Team Identifier. Format: 141, 147, etc
	TeamId *[]int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *[]int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// SportId Top level organization of a sport
	SportId *[]int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// ActiveStreak Whether or not a player is active
	ActiveStreak *bool `form:"activeStreak,omitempty" json:"activeStreak,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// PlayerId A unique identifier for a player
	PlayerId *[]int32 `form:"playerId,omitempty" json:"playerId,omitempty"`
}

// TeamsParams defines parameters for Teams.
type TeamsParams struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// DivisionId Unique Division Identifier
	DivisionId *int32 `form:"divisionId,omitempty" json:"divisionId,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// SportIds Comma delimited list of top level organizations of a sport
	SportIds *[]int32 `form:"sportIds,omitempty" json:"sportIds,omitempty"`

	// ActiveStatus Flag for fetching teams that are currently active (Y), inactive (N), pending (P), or all teams (B)
	ActiveStatus *TeamActiveStatusEnum `form:"activeStatus,omitempty" json:"activeStatus,omitempty"`

	// LeagueListId Unique League List Identifier
	LeagueListId    *LeagueListsEnum `form:"leagueListId,omitempty" json:"leagueListId,omitempty"`
	AllStarStatuses *[]AllStarEnum   `form:"allStarStatuses,omitempty" json:"allStarStatuses,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Affiliates1Params defines parameters for Affiliates1.
type Affiliates1Params struct {
	// TeamIds Unique Team Identifier. Format: 141, 147, etc
	TeamIds *[]int32 `form:"teamIds,omitempty" json:"teamIds,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// AllTeams1Params defines parameters for AllTeams1.
type AllTeams1Params struct {
	// TeamIds Comma delimited list of Unique Team identifiers
	TeamIds *[]int32 `form:"teamIds,omitempty" json:"teamIds,omitempty"`

	// StartSeason Start date for range of data (used with end date optionally). Example: '2018' or '2018.2'
	StartSeason *string `form:"startSeason,omitempty" json:"startSeason,omitempty"`

	// EndSeason End date for range of data (used with start date optionally). Format: '2018' or '2018.2'
	EndSeason *string   `form:"endSeason,omitempty" json:"endSeason,omitempty"`
	Fields    *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Stats1Params defines parameters for Stats1.
type Stats1Params struct {
	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Stats Type of statistics. Format: Individual, Team, Career, etc. Available types in /api/v1/statTypes
	Stats *[]StatType `form:"stats,omitempty" json:"stats,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// SportIds Comma delimited list of top level organizations of a sport
	SportIds *[]int32 `form:"sportIds,omitempty" json:"sportIds,omitempty"`

	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group []StatGroup `form:"group" json:"group"`

	// SortStat Baseball stat to sort splits by.
	SortStat *BaseballStatsEnum `form:"sortStat,omitempty" json:"sortStat,omitempty"`

	// Order The order of sorting, ascending or descending
	Order *SortOrderEnum `form:"order,omitempty" json:"order,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// DaysBack Returns results from the last 'X' days (Starting from yesterday).
	DaysBack *int32 `form:"daysBack,omitempty" json:"daysBack,omitempty"`

	// SitCodes Situation code for a given stat split.
	SitCodes *string `form:"sitCodes,omitempty" json:"sitCodes,omitempty"`

	// CombineSits If true, gathers stats where all of the situational criteria are met. If false, returns stats where any of the situational criteria are met. Default: false
	CombineSits *bool `form:"combineSits,omitempty" json:"combineSits,omitempty"`

	// OpposingTeamId A unique identifier for the opposing team. Must be used with Team ID
	OpposingTeamId *int32 `form:"opposingTeamId,omitempty" json:"opposingTeamId,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of results to return
	Limit  *int32    `form:"limit,omitempty" json:"limit,omitempty"`
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Leaders1Params defines parameters for Leaders1.
type Leaders1Params struct {
	// LeaderCategories TBD
	LeaderCategories *[]PersonLeadersEnum `form:"leaderCategories,omitempty" json:"leaderCategories,omitempty"`

	// GameTypes Type of Game. Available types in /api/v1/gameTypes
	GameTypes *[]GameTypeEnum `form:"gameTypes,omitempty" json:"gameTypes,omitempty"`

	// Stats Type of statistics. Format: Individual, Team, Career, etc. Available types in /api/v1/statTypes
	Stats    *[]StatType `form:"stats,omitempty" json:"stats,omitempty"`
	StatType *StatType   `form:"statType,omitempty" json:"statType,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// SportIds Comma delimited list of top level organizations of a sport
	SportIds *[]int32 `form:"sportIds,omitempty" json:"sportIds,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// StatGroup Category of statistic to return. Available types in /api/v1/statGroups
	StatGroup *[]StatGroup `form:"statGroup,omitempty" json:"statGroup,omitempty"`

	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group *[]StatGroup `form:"group,omitempty" json:"group,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// DaysBack Returns results from the last 'X' days (Starting from yesterday).
	DaysBack *int32 `form:"daysBack,omitempty" json:"daysBack,omitempty"`

	// SitCodes Situation code for a given stat split.
	SitCodes *string `form:"sitCodes,omitempty" json:"sitCodes,omitempty"`

	// OpposingTeamId A unique identifier for the opposing team. Must be used with Team ID
	OpposingTeamId *int32 `form:"opposingTeamId,omitempty" json:"opposingTeamId,omitempty"`

	// Limit Number of results to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The pointer to start for a return set; used for pagination
	Offset *int32    `form:"offset,omitempty" json:"offset,omitempty"`
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Teams1Params defines parameters for Teams1.
type Teams1Params struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// DivisionId Unique Division Identifier
	DivisionId *int32 `form:"divisionId,omitempty" json:"divisionId,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// SportIds Comma delimited list of top level organizations of a sport
	SportIds *[]int32 `form:"sportIds,omitempty" json:"sportIds,omitempty"`

	// ActiveStatus Flag for fetching teams that are currently active (Y), inactive (N), pending (P), or all teams (B)
	ActiveStatus *TeamActiveStatusEnum `form:"activeStatus,omitempty" json:"activeStatus,omitempty"`

	// LeagueListId Unique League List Identifier
	LeagueListId    *LeagueListsEnum `form:"leagueListId,omitempty" json:"leagueListId,omitempty"`
	AllStarStatuses *[]AllStarEnum   `form:"allStarStatuses,omitempty" json:"allStarStatuses,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// AffiliatesParams defines parameters for Affiliates.
type AffiliatesParams struct {
	// TeamIds Unique Team Identifier. Format: 141, 147, etc
	TeamIds *[]int32 `form:"teamIds,omitempty" json:"teamIds,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// AlumniParams defines parameters for Alumni.
type AlumniParams struct {
	// Season Season of play
	Season string `form:"season" json:"season"`

	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group  *StatGroup `form:"group,omitempty" json:"group,omitempty"`
	Fields *[]string  `form:"fields,omitempty" json:"fields,omitempty"`
}

// UpdateAlumniParams defines parameters for UpdateAlumni.
type UpdateAlumniParams struct {
	// Season Season of play
	Season string `form:"season" json:"season"`

	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group  *StatGroup `form:"group,omitempty" json:"group,omitempty"`
	Fields *[]string  `form:"fields,omitempty" json:"fields,omitempty"`
}

// CoachesParams defines parameters for Coaches.
type CoachesParams struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date   *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`
	Fields *[]string           `form:"fields,omitempty" json:"fields,omitempty"`
}

// AllTeamsParams defines parameters for AllTeams.
type AllTeamsParams struct {
	// TeamIds Comma delimited list of Unique Team identifiers
	TeamIds *[]int32 `form:"teamIds,omitempty" json:"teamIds,omitempty"`

	// StartSeason Start date for range of data (used with end date optionally). Example: '2018' or '2018.2'
	StartSeason *string `form:"startSeason,omitempty" json:"startSeason,omitempty"`

	// EndSeason End date for range of data (used with start date optionally). Format: '2018' or '2018.2'
	EndSeason *string   `form:"endSeason,omitempty" json:"endSeason,omitempty"`
	Fields    *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// LeadersParams defines parameters for Leaders.
type LeadersParams struct {
	LeaderCategories *[]PersonLeadersEnum `form:"leaderCategories,omitempty" json:"leaderCategories,omitempty"`
	Season           *string              `form:"season,omitempty" json:"season,omitempty"`
	LeaderGameTypes  *[]GameTypeEnum      `form:"leaderGameTypes,omitempty" json:"leaderGameTypes,omitempty"`
	Expand           *[]ExpandEnum        `form:"expand,omitempty" json:"expand,omitempty"`
	Limit            *int32               `form:"limit,omitempty" json:"limit,omitempty"`
	Offset           *int32               `form:"offset,omitempty" json:"offset,omitempty"`
	PlayerPool       *PlayerPoolEnum      `form:"playerPool,omitempty" json:"playerPool,omitempty"`
	Fields           *[]string            `form:"fields,omitempty" json:"fields,omitempty"`
}

// PersonnelParams defines parameters for Personnel.
type PersonnelParams struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date   *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`
	Fields *[]string           `form:"fields,omitempty" json:"fields,omitempty"`
}

// RosterParams defines parameters for Roster.
type RosterParams struct {
	// RosterType Type of roster. Available types in /api/v1/rosterTypes
	RosterType *string `form:"rosterType,omitempty" json:"rosterType,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// Roster1Params defines parameters for Roster1.
type Roster1Params struct {
	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// StatsParams defines parameters for Stats.
type StatsParams struct {
	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// Stats Type of statistics. Format: Individual, Team, Career, etc. Available types in /api/v1/statTypes
	Stats *[]StatType `form:"stats,omitempty" json:"stats,omitempty"`

	// Group Category of statistic to return. Available types in /api/v1/statGroups
	Group []StatGroup `form:"group" json:"group"`

	// SortStat Baseball stat to sort splits by.
	SortStat *BaseballStatsEnum `form:"sortStat,omitempty" json:"sortStat,omitempty"`

	// Order The order of sorting, ascending or descending
	Order *SortOrderEnum `form:"order,omitempty" json:"order,omitempty"`

	// GroupBy Group stats by PLAYER, TEAM, SEASON, VENUE, SPORT or STAT_GROUP
	GroupBy *[]GroupByEnum `form:"groupBy,omitempty" json:"groupBy,omitempty"`

	// OpposingTeamId A unique identifier for the opposing team. Must be used with Team ID
	OpposingTeamId *int32 `form:"opposingTeamId,omitempty" json:"opposingTeamId,omitempty"`

	// OpposingPlayerId A unique identifier for the opposing team
	OpposingPlayerId *int32 `form:"opposingPlayerId,omitempty" json:"opposingPlayerId,omitempty"`

	// SitCodes Situation code for a given stat split.
	SitCodes *string `form:"sitCodes,omitempty" json:"sitCodes,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// TransactionTypesParams defines parameters for TransactionTypes.
type TransactionTypesParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// TransactionsParams defines parameters for Transactions.
type TransactionsParams struct {
	// LeagueId Comma delimited list of Unique league identifiers
	LeagueId *[]int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// SportId Comma delimited list of top level organizations of a sport
	SportId *[]int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// TeamId Comma delimited list of Unique Team identifiers
	TeamId *[]int32 `form:"teamId,omitempty" json:"teamId,omitempty"`

	// PlayerId A unique identifier for a player
	PlayerId *[]int32 `form:"playerId,omitempty" json:"playerId,omitempty"`

	// Date Date of Game. Format: YYYY-MM-DD
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// StartDate Start date for range of data (must be used with end date). Format: MM/DD/YYYY
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for range of data (must be used with start date). Format: MM/DD/YYYY
	EndDate          *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`
	TransactionIds   *[]int32            `form:"transactionIds,omitempty" json:"transactionIds,omitempty"`
	TransactionTypes *[]string           `form:"transactionTypes,omitempty" json:"transactionTypes,omitempty"`
	DivisionIds      *[]int32            `form:"divisionIds,omitempty" json:"divisionIds,omitempty"`
	Order            *SortOrderEnum      `form:"order,omitempty" json:"order,omitempty"`
	Limit            *int32              `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// UniformsByGameParams defines parameters for UniformsByGame.
type UniformsByGameParams struct {
	// GamePks Comma delimited list of unique primary keys
	GamePks []int32 `form:"gamePks" json:"gamePks"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// UniformsByTeamParams defines parameters for UniformsByTeam.
type UniformsByTeamParams struct {
	TeamIds []int32 `form:"teamIds" json:"teamIds"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// VenuesParams defines parameters for Venues.
type VenuesParams struct {
	// VenueIds Comma delimited list of Unique venue identifiers
	VenueIds *[]int32 `form:"venueIds,omitempty" json:"venueIds,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// GameTypes Comma delimited list of type of Game. Available types in /api/v1/gameTypes
	GameTypes *[]GameTypeEnum `form:"gameTypes,omitempty" json:"gameTypes,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Active Whether or not a player is active
	Active        *bool `form:"active,omitempty" json:"active,omitempty"`
	IncludeEvents *bool `form:"includeEvents,omitempty" json:"includeEvents,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// SportIds Comma delimited list of top level organizations of a sport
	SportIds *[]int32 `form:"sportIds,omitempty" json:"sportIds,omitempty"`
}

// Venues1Params defines parameters for Venues1.
type Venues1Params struct {
	// VenueIds Comma delimited list of Unique venue identifiers
	VenueIds *[]int32 `form:"venueIds,omitempty" json:"venueIds,omitempty"`

	// LeagueId Unique League Identifier
	LeagueId *int32 `form:"leagueId,omitempty" json:"leagueId,omitempty"`

	// LeagueIds Comma delimited list of Unique league identifiers
	LeagueIds *[]int32 `form:"leagueIds,omitempty" json:"leagueIds,omitempty"`

	// GameType Type of Game. Available types in /api/v1/gameTypes
	GameType *GameTypeEnum `form:"gameType,omitempty" json:"gameType,omitempty"`

	// GameTypes Comma delimited list of type of Game. Available types in /api/v1/gameTypes
	GameTypes *[]GameTypeEnum `form:"gameTypes,omitempty" json:"gameTypes,omitempty"`

	// Season Season of play
	Season *string `form:"season,omitempty" json:"season,omitempty"`

	// Seasons Comma delimited list of Seasons of play
	Seasons *[]string `form:"seasons,omitempty" json:"seasons,omitempty"`

	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Active Whether or not a player is active
	Active        *bool `form:"active,omitempty" json:"active,omitempty"`
	IncludeEvents *bool `form:"includeEvents,omitempty" json:"includeEvents,omitempty"`

	// SportId Top level organization of a sport
	SportId *int32 `form:"sportId,omitempty" json:"sportId,omitempty"`

	// SportIds Comma delimited list of top level organizations of a sport
	SportIds *[]int32 `form:"sportIds,omitempty" json:"sportIds,omitempty"`
}

// WeatherForecastParams defines parameters for WeatherForecast.
type WeatherForecastParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// WeatherDataBasedOnPlayParams defines parameters for WeatherDataBasedOnPlay.
type WeatherDataBasedOnPlayParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// WeatherBasicParams defines parameters for WeatherBasic.
type WeatherBasicParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// WeatherFullParams defines parameters for WeatherFull.
type WeatherFullParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// WindDirectionParams defines parameters for WindDirection.
type WindDirectionParams struct {
	// Fields Comma delimited list of specific fields to be returned. Format: topLevelNode, childNode, attribute
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// LiveGameV1 request
	LiveGameV1(ctx context.Context, gamePk int32, params *LiveGameV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LiveGameDiffPatchV1 request
	LiveGameDiffPatchV1(ctx context.Context, gamePk int32, params *LiveGameDiffPatchV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LiveTimestampv11 request
	LiveTimestampv11(ctx context.Context, gamePk int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AchievementStatuses request
	AchievementStatuses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GameGuidsFromPostgresRangeByGame request
	GameGuidsFromPostgresRangeByGame(ctx context.Context, params *GameGuidsFromPostgresRangeByGameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GameGuidsFromPostgresRange request
	GameGuidsFromPostgresRange(ctx context.Context, params *GameGuidsFromPostgresRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamAttendance request
	GetTeamAttendance(ctx context.Context, params *GetTeamAttendanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Awards request
	Awards(ctx context.Context, params *AwardsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Awards1 request
	Awards1(ctx context.Context, awardId string, params *Awards1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AwardRecipients request
	AwardRecipients(ctx context.Context, awardId string, params *AwardRecipientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BaseballStats request
	BaseballStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BatTracking request
	BatTracking(ctx context.Context, gamePk int32, playId string, params *BatTrackingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBroadcasts request
	GetBroadcasts(ctx context.Context, params *GetBroadcastsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BroadcastAvailabilityTypes request
	BroadcastAvailabilityTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllBroadcasters request
	GetAllBroadcasters(ctx context.Context, params *GetAllBroadcastersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CoachingVideoTypes request
	CoachingVideoTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Conferences request
	Conferences(ctx context.Context, params *ConferencesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Conferences1 request
	Conferences1(ctx context.Context, conferenceId int32, params *Conferences1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Divisions request
	Divisions(ctx context.Context, params *DivisionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Divisions1 request
	Divisions1(ctx context.Context, divisionId int32, params *Divisions1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DraftPicks request
	DraftPicks(ctx context.Context, params *DraftPicksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DraftProspects request
	DraftProspects(ctx context.Context, params *DraftProspectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DraftProspects1 request
	DraftProspects1(ctx context.Context, year int32, params *DraftProspects1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DraftPicks1 request
	DraftPicks1(ctx context.Context, year int32, params *DraftPicks1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LatestDraftPicks request
	LatestDraftPicks(ctx context.Context, year int32, params *LatestDraftPicksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventStatus request
	EventStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventTypes request
	EventTypes(ctx context.Context, params *EventTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FielderDetailTypes request
	FielderDetailTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FreeGameTypes request
	FreeGameTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CurrentGameStats1 request
	CurrentGameStats1(ctx context.Context, params *CurrentGameStats1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GameLastPitch request
	GameLastPitch(ctx context.Context, params *GameLastPitchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGameContextMetrics request
	GetGameContextMetrics(ctx context.Context, gamePk int32, params *GetGameContextMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GameGuids request
	GameGuids(ctx context.Context, gamePk int32, params *GameGuidsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWinProbability request
	GetWinProbability(ctx context.Context, gamePk int32, params *GetWinProbabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGameWithMetrics request
	GetGameWithMetrics(ctx context.Context, gamePk int32, params *GetGameWithMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ParsedJsonFormattedAnalytics request
	ParsedJsonFormattedAnalytics(ctx context.Context, gamePk int32, guid string, params *ParsedJsonFormattedAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContextMetrics request
	ContextMetrics(ctx context.Context, gamePk int32, guid string, params *ContextMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContextMetricsWithAverages request
	ContextMetricsWithAverages(ctx context.Context, gamePk int32, guid string, params *ContextMetricsWithAveragesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContextMetricsWithAveragesPost request
	ContextMetricsWithAveragesPost(ctx context.Context, gamePk int32, guid string, params *ContextMetricsWithAveragesPostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HomeRunBallparks request
	HomeRunBallparks(ctx context.Context, gamePk int32, guid string, params *HomeRunBallparksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Biomechanical request
	Biomechanical(ctx context.Context, gamePk int32, playId string, positionId int32, params *BiomechanicalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SkeletalChunked request
	SkeletalChunked(ctx context.Context, gamePk int32, playId string, params *SkeletalChunkedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SkeletalDataFileNames request
	SkeletalDataFileNames(ctx context.Context, gamePk int32, playId string, params *SkeletalDataFileNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Boxscore request
	Boxscore(ctx context.Context, gamePk int32, params *BoxscoreParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Content request
	Content(ctx context.Context, gamePk int32, params *ContentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ColorFeed request
	ColorFeed(ctx context.Context, gamePk int32, params *ColorFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ColorTimestamps request
	ColorTimestamps(ctx context.Context, gamePk int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Linescore request
	Linescore(ctx context.Context, gamePk int32, params *LinescoreParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlayByPlay request
	PlayByPlay(ctx context.Context, gamePk int32, params *PlayByPlayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GamePace request
	GamePace(ctx context.Context, params *GamePaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GameStatus request
	GameStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGameStatuses request
	UpdateGameStatuses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GameTypes request
	GameTypes(ctx context.Context, params *GameTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GamedayTypes request
	GamedayTypes(ctx context.Context, params *GamedayTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupByTypes request
	GroupByTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HighLowStats request
	HighLowStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HighLow request
	HighLow(ctx context.Context, highLowType HighLowTypeEnum, params *HighLowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HitTrajectories request
	HitTrajectories(ctx context.Context, params *HitTrajectoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HomeRunDerbyBracket1 request
	HomeRunDerbyBracket1(ctx context.Context, params *HomeRunDerbyBracket1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HomeRunDerbyBracket3 request
	HomeRunDerbyBracket3(ctx context.Context, params *HomeRunDerbyBracket3Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HomeRunDerbyMixedMode1 request
	HomeRunDerbyMixedMode1(ctx context.Context, params *HomeRunDerbyMixedMode1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HomeRunDerbyPool1 request
	HomeRunDerbyPool1(ctx context.Context, params *HomeRunDerbyPool1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HomeRunDerbyBracket request
	HomeRunDerbyBracket(ctx context.Context, gamePk int32, params *HomeRunDerbyBracketParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HomeRunDerbyBracket2 request
	HomeRunDerbyBracket2(ctx context.Context, gamePk int32, params *HomeRunDerbyBracket2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HomeRunDerbyMixedMode request
	HomeRunDerbyMixedMode(ctx context.Context, gamePk int32, params *HomeRunDerbyMixedModeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HomeRunDerbyPool request
	HomeRunDerbyPool(ctx context.Context, gamePk int32, params *HomeRunDerbyPoolParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JobTypes request
	JobTypes(ctx context.Context, params *JobTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateJobTypes request
	UpdateJobTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobsByType request
	GetJobsByType(ctx context.Context, params *GetJobsByTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Datacasters request
	Datacasters(ctx context.Context, params *DatacastersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OfficialScorers request
	OfficialScorers(ctx context.Context, params *OfficialScorersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Umpires request
	Umpires(ctx context.Context, params *UmpiresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UmpireSchedule request
	UmpireSchedule(ctx context.Context, umpireId int32, params *UmpireScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Languages request
	Languages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// League request
	League(ctx context.Context, params *LeagueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllStarBallot request
	AllStarBallot(ctx context.Context, params *AllStarBallotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// League1 request
	League1(ctx context.Context, leagueId int32, params *League1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllStarBallot1 request
	AllStarBallot1(ctx context.Context, leagueId int32, params *AllStarBallot1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllStarFinalVote request
	AllStarFinalVote(ctx context.Context, leagueId int32, params *AllStarFinalVoteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllStarWriteIns request
	AllStarWriteIns(ctx context.Context, leagueId int32, params *AllStarWriteInsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeagueLeaderTypes request
	LeagueLeaderTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// League2 request
	League2(ctx context.Context, params *League2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllStarBallot2 request
	AllStarBallot2(ctx context.Context, params *AllStarBallot2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// League3 request
	League3(ctx context.Context, leagueId int32, params *League3Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllStarBallot3 request
	AllStarBallot3(ctx context.Context, leagueId int32, params *AllStarBallot3Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllStarFinalVote1 request
	AllStarFinalVote1(ctx context.Context, leagueId int32, params *AllStarFinalVote1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllStarWriteIns1 request
	AllStarWriteIns1(ctx context.Context, leagueId int32, params *AllStarWriteIns1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogicalEvents request
	LogicalEvents(ctx context.Context, params *LogicalEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLookupValues request
	GetLookupValues(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MediaStateTypes request
	MediaStateTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Metrics request
	Metrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MilestoneDurations request
	MilestoneDurations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MilestoneLookups request
	MilestoneLookups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MilestoneStatistics request
	MilestoneStatistics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MilestoneTypes request
	MilestoneTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Milestones request
	Milestones(ctx context.Context, params *MilestonesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MoundVisitTypes request
	MoundVisitTypes(ctx context.Context, params *MoundVisitTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Person1 request
	Person1(ctx context.Context, params *Person1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CurrentGameStats request
	CurrentGameStats(ctx context.Context, params *CurrentGameStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FreeAgents request
	FreeAgents(ctx context.Context, params *FreeAgentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search request
	Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Person request
	Person(ctx context.Context, personId int32, params *PersonParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Award request
	Award(ctx context.Context, personId int32, params *AwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Stats3 request
	Stats3(ctx context.Context, personId int32, params *Stats3Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlayerGameStats request
	PlayerGameStats(ctx context.Context, personId int32, gamePk int32, params *PlayerGameStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatsMetrics request
	StatsMetrics(ctx context.Context, personId int32, params *StatsMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PerformerTypes request
	PerformerTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PitchCodes request
	PitchCodes(ctx context.Context, params *PitchCodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PitchTypes request
	PitchTypes(ctx context.Context, params *PitchTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Platforms request
	Platforms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlayerStatusCodes request
	PlayerStatusCodes(ctx context.Context, params *PlayerStatusCodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Positions request
	Positions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProps request
	GetProps(ctx context.Context, params *GetPropsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPropsAdjust request
	GetPropsAdjust(ctx context.Context, params *GetPropsAdjustParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReviewInfo request
	GetReviewInfo(ctx context.Context, params *GetReviewInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReviewReasons request
	ReviewReasons(ctx context.Context, params *ReviewReasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RoofTypes request
	RoofTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RosterTypes request
	RosterTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RuleSettings request
	RuleSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunnerDetailTypes request
	RunnerDetailTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Schedule request
	Schedule(ctx context.Context, params *ScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TieGames request
	TieGames(ctx context.Context, params *TieGamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostseasonSchedule request
	PostseasonSchedule(ctx context.Context, params *PostseasonScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostseasonScheduleSeries request
	PostseasonScheduleSeries(ctx context.Context, params *PostseasonScheduleSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TuneIn request
	TuneIn(ctx context.Context, params *TuneInParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrackingEventsSchedule request
	TrackingEventsSchedule(ctx context.Context, params *TrackingEventsScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Schedule1 request
	Schedule1(ctx context.Context, scheduleType string, params *Schedule1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScheduleEventTypes request
	ScheduleEventTypes(ctx context.Context, params *ScheduleEventTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScheduleTypes request
	ScheduleTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Seasons request
	Seasons(ctx context.Context, params *SeasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllSeasons request
	AllSeasons(ctx context.Context, params *AllSeasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Seasons1 request
	Seasons1(ctx context.Context, seasonId string, params *Seasons1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SitCodes request
	SitCodes(ctx context.Context, params *SitCodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sky request
	Sky(ctx context.Context, params *SkyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AggregateSortEnum request
	AggregateSortEnum(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sports request
	Sports(ctx context.Context, params *SportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sports1 request
	Sports1(ctx context.Context, sportId int32, params *Sports1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllSportBallot request
	AllSportBallot(ctx context.Context, sportId int32, params *AllSportBallotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SportPlayers request
	SportPlayers(ctx context.Context, sportId int32, params *SportPlayersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Standings1 request
	Standings1(ctx context.Context, params *Standings1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Standings request
	Standings(ctx context.Context, standingsType string, params *StandingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StandingsTypes request
	StandingsTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatFields request
	StatFields(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatGroups request
	StatGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatTypes request
	StatTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatcastPositionTypes request
	StatcastPositionTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Stats2 request
	Stats2(ctx context.Context, params *Stats2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutsAboveAverage request
	GetOutsAboveAverage(ctx context.Context, params *GetOutsAboveAverageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSprayChart request
	GetSprayChart(ctx context.Context, params *GetSprayChartParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStolenBaseProbability request
	GetStolenBaseProbability(ctx context.Context, params *GetStolenBaseProbabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupedStats request
	GroupedStats(ctx context.Context, params *GroupedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Leaders2 request
	Leaders2(ctx context.Context, params *Leaders2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricStats request
	MetricStats(ctx context.Context, params *MetricStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BeastStats request
	BeastStats(ctx context.Context, params *BeastStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatSearchConfig request
	StatSearchConfig(ctx context.Context, params *StatSearchConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatSearchGroupByTypes request
	StatSearchGroupByTypes(ctx context.Context, params *StatSearchGroupByTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatSearchParams request
	StatSearchParams(ctx context.Context, params *StatSearchParamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatSearchStats request
	StatSearchStats(ctx context.Context, params *StatSearchStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreaks request
	GetStreaks(ctx context.Context, params *GetStreaksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreakTypes request
	StreakTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Teams request
	Teams(ctx context.Context, params *TeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Affiliates1 request
	Affiliates1(ctx context.Context, params *Affiliates1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllTeams1 request
	AllTeams1(ctx context.Context, params *AllTeams1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Stats1 request
	Stats1(ctx context.Context, params *Stats1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Leaders1 request
	Leaders1(ctx context.Context, params *Leaders1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Teams1 request
	Teams1(ctx context.Context, teamId int32, params *Teams1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Affiliates request
	Affiliates(ctx context.Context, teamId int32, params *AffiliatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Alumni request
	Alumni(ctx context.Context, teamId int32, params *AlumniParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAlumni request
	UpdateAlumni(ctx context.Context, teamId int32, params *UpdateAlumniParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Coaches request
	Coaches(ctx context.Context, teamId int32, params *CoachesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllTeams request
	AllTeams(ctx context.Context, teamId int32, params *AllTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Leaders request
	Leaders(ctx context.Context, teamId int32, params *LeadersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Personnel request
	Personnel(ctx context.Context, teamId int32, params *PersonnelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Roster request
	Roster(ctx context.Context, teamId int32, params *RosterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Roster1 request
	Roster1(ctx context.Context, teamId int32, rosterType string, params *Roster1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Stats request
	Stats(ctx context.Context, teamId int32, params *StatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrackingSoftwareVersions request
	TrackingSoftwareVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrackingSystemOwners request
	TrackingSystemOwners(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrackingVendors request
	TrackingVendors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrackingVersions request
	TrackingVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransactionTypes request
	TransactionTypes(ctx context.Context, params *TransactionTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Transactions request
	Transactions(ctx context.Context, params *TransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UniformsByGame request
	UniformsByGame(ctx context.Context, params *UniformsByGameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UniformsByTeam request
	UniformsByTeam(ctx context.Context, params *UniformsByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Venues request
	Venues(ctx context.Context, params *VenuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Venues1 request
	Venues1(ctx context.Context, venueId int32, params *Venues1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VideoResolutionTypes request
	VideoResolutionTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ViolationTypes request
	ViolationTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WeatherForecast request
	WeatherForecast(ctx context.Context, gamePk int32, roofType RoofType, params *WeatherForecastParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WeatherDataBasedOnPlay request
	WeatherDataBasedOnPlay(ctx context.Context, gamePk int32, playId string, params *WeatherDataBasedOnPlayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WeatherBasic request
	WeatherBasic(ctx context.Context, venueId int32, params *WeatherBasicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WeatherFull request
	WeatherFull(ctx context.Context, venueId int32, params *WeatherFullParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WeatherTrajectoryConfidences request
	WeatherTrajectoryConfidences(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WindDirection request
	WindDirection(ctx context.Context, params *WindDirectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) LiveGameV1(ctx context.Context, gamePk int32, params *LiveGameV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLiveGameV1Request(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LiveGameDiffPatchV1(ctx context.Context, gamePk int32, params *LiveGameDiffPatchV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLiveGameDiffPatchV1Request(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LiveTimestampv11(ctx context.Context, gamePk int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLiveTimestampv11Request(c.Server, gamePk)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AchievementStatuses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAchievementStatusesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GameGuidsFromPostgresRangeByGame(ctx context.Context, params *GameGuidsFromPostgresRangeByGameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGameGuidsFromPostgresRangeByGameRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GameGuidsFromPostgresRange(ctx context.Context, params *GameGuidsFromPostgresRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGameGuidsFromPostgresRangeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamAttendance(ctx context.Context, params *GetTeamAttendanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamAttendanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Awards(ctx context.Context, params *AwardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAwardsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Awards1(ctx context.Context, awardId string, params *Awards1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAwards1Request(c.Server, awardId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AwardRecipients(ctx context.Context, awardId string, params *AwardRecipientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAwardRecipientsRequest(c.Server, awardId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BaseballStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBaseballStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BatTracking(ctx context.Context, gamePk int32, playId string, params *BatTrackingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBatTrackingRequest(c.Server, gamePk, playId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBroadcasts(ctx context.Context, params *GetBroadcastsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBroadcastsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BroadcastAvailabilityTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBroadcastAvailabilityTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllBroadcasters(ctx context.Context, params *GetAllBroadcastersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBroadcastersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CoachingVideoTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCoachingVideoTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Conferences(ctx context.Context, params *ConferencesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConferencesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Conferences1(ctx context.Context, conferenceId int32, params *Conferences1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConferences1Request(c.Server, conferenceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Divisions(ctx context.Context, params *DivisionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDivisionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Divisions1(ctx context.Context, divisionId int32, params *Divisions1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDivisions1Request(c.Server, divisionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DraftPicks(ctx context.Context, params *DraftPicksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDraftPicksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DraftProspects(ctx context.Context, params *DraftProspectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDraftProspectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DraftProspects1(ctx context.Context, year int32, params *DraftProspects1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDraftProspects1Request(c.Server, year, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DraftPicks1(ctx context.Context, year int32, params *DraftPicks1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDraftPicks1Request(c.Server, year, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LatestDraftPicks(ctx context.Context, year int32, params *LatestDraftPicksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLatestDraftPicksRequest(c.Server, year, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventTypes(ctx context.Context, params *EventTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FielderDetailTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFielderDetailTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FreeGameTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFreeGameTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CurrentGameStats1(ctx context.Context, params *CurrentGameStats1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrentGameStats1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GameLastPitch(ctx context.Context, params *GameLastPitchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGameLastPitchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGameContextMetrics(ctx context.Context, gamePk int32, params *GetGameContextMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGameContextMetricsRequest(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GameGuids(ctx context.Context, gamePk int32, params *GameGuidsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGameGuidsRequest(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWinProbability(ctx context.Context, gamePk int32, params *GetWinProbabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWinProbabilityRequest(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGameWithMetrics(ctx context.Context, gamePk int32, params *GetGameWithMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGameWithMetricsRequest(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ParsedJsonFormattedAnalytics(ctx context.Context, gamePk int32, guid string, params *ParsedJsonFormattedAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewParsedJsonFormattedAnalyticsRequest(c.Server, gamePk, guid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContextMetrics(ctx context.Context, gamePk int32, guid string, params *ContextMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContextMetricsRequest(c.Server, gamePk, guid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContextMetricsWithAverages(ctx context.Context, gamePk int32, guid string, params *ContextMetricsWithAveragesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContextMetricsWithAveragesRequest(c.Server, gamePk, guid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContextMetricsWithAveragesPost(ctx context.Context, gamePk int32, guid string, params *ContextMetricsWithAveragesPostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContextMetricsWithAveragesPostRequest(c.Server, gamePk, guid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HomeRunBallparks(ctx context.Context, gamePk int32, guid string, params *HomeRunBallparksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHomeRunBallparksRequest(c.Server, gamePk, guid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Biomechanical(ctx context.Context, gamePk int32, playId string, positionId int32, params *BiomechanicalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBiomechanicalRequest(c.Server, gamePk, playId, positionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SkeletalChunked(ctx context.Context, gamePk int32, playId string, params *SkeletalChunkedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSkeletalChunkedRequest(c.Server, gamePk, playId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SkeletalDataFileNames(ctx context.Context, gamePk int32, playId string, params *SkeletalDataFileNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSkeletalDataFileNamesRequest(c.Server, gamePk, playId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Boxscore(ctx context.Context, gamePk int32, params *BoxscoreParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBoxscoreRequest(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Content(ctx context.Context, gamePk int32, params *ContentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContentRequest(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ColorFeed(ctx context.Context, gamePk int32, params *ColorFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewColorFeedRequest(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ColorTimestamps(ctx context.Context, gamePk int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewColorTimestampsRequest(c.Server, gamePk)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Linescore(ctx context.Context, gamePk int32, params *LinescoreParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinescoreRequest(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlayByPlay(ctx context.Context, gamePk int32, params *PlayByPlayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlayByPlayRequest(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GamePace(ctx context.Context, params *GamePaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGamePaceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GameStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGameStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGameStatuses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGameStatusesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GameTypes(ctx context.Context, params *GameTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGameTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GamedayTypes(ctx context.Context, params *GamedayTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGamedayTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupByTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupByTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HighLowStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHighLowStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HighLow(ctx context.Context, highLowType HighLowTypeEnum, params *HighLowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHighLowRequest(c.Server, highLowType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HitTrajectories(ctx context.Context, params *HitTrajectoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHitTrajectoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HomeRunDerbyBracket1(ctx context.Context, params *HomeRunDerbyBracket1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHomeRunDerbyBracket1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HomeRunDerbyBracket3(ctx context.Context, params *HomeRunDerbyBracket3Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHomeRunDerbyBracket3Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HomeRunDerbyMixedMode1(ctx context.Context, params *HomeRunDerbyMixedMode1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHomeRunDerbyMixedMode1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HomeRunDerbyPool1(ctx context.Context, params *HomeRunDerbyPool1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHomeRunDerbyPool1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HomeRunDerbyBracket(ctx context.Context, gamePk int32, params *HomeRunDerbyBracketParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHomeRunDerbyBracketRequest(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HomeRunDerbyBracket2(ctx context.Context, gamePk int32, params *HomeRunDerbyBracket2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHomeRunDerbyBracket2Request(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HomeRunDerbyMixedMode(ctx context.Context, gamePk int32, params *HomeRunDerbyMixedModeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHomeRunDerbyMixedModeRequest(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HomeRunDerbyPool(ctx context.Context, gamePk int32, params *HomeRunDerbyPoolParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHomeRunDerbyPoolRequest(c.Server, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JobTypes(ctx context.Context, params *JobTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJobTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJobTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobsByType(ctx context.Context, params *GetJobsByTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobsByTypeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Datacasters(ctx context.Context, params *DatacastersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatacastersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OfficialScorers(ctx context.Context, params *OfficialScorersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOfficialScorersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Umpires(ctx context.Context, params *UmpiresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUmpiresRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UmpireSchedule(ctx context.Context, umpireId int32, params *UmpireScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUmpireScheduleRequest(c.Server, umpireId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Languages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) League(ctx context.Context, params *LeagueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeagueRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllStarBallot(ctx context.Context, params *AllStarBallotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllStarBallotRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) League1(ctx context.Context, leagueId int32, params *League1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeague1Request(c.Server, leagueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllStarBallot1(ctx context.Context, leagueId int32, params *AllStarBallot1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllStarBallot1Request(c.Server, leagueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllStarFinalVote(ctx context.Context, leagueId int32, params *AllStarFinalVoteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllStarFinalVoteRequest(c.Server, leagueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllStarWriteIns(ctx context.Context, leagueId int32, params *AllStarWriteInsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllStarWriteInsRequest(c.Server, leagueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeagueLeaderTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeagueLeaderTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) League2(ctx context.Context, params *League2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeague2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllStarBallot2(ctx context.Context, params *AllStarBallot2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllStarBallot2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) League3(ctx context.Context, leagueId int32, params *League3Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeague3Request(c.Server, leagueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllStarBallot3(ctx context.Context, leagueId int32, params *AllStarBallot3Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllStarBallot3Request(c.Server, leagueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllStarFinalVote1(ctx context.Context, leagueId int32, params *AllStarFinalVote1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllStarFinalVote1Request(c.Server, leagueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllStarWriteIns1(ctx context.Context, leagueId int32, params *AllStarWriteIns1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllStarWriteIns1Request(c.Server, leagueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogicalEvents(ctx context.Context, params *LogicalEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogicalEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLookupValues(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLookupValuesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MediaStateTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMediaStateTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Metrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MilestoneDurations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMilestoneDurationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MilestoneLookups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMilestoneLookupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MilestoneStatistics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMilestoneStatisticsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MilestoneTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMilestoneTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Milestones(ctx context.Context, params *MilestonesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMilestonesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoundVisitTypes(ctx context.Context, params *MoundVisitTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoundVisitTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Person1(ctx context.Context, params *Person1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPerson1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CurrentGameStats(ctx context.Context, params *CurrentGameStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrentGameStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FreeAgents(ctx context.Context, params *FreeAgentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFreeAgentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Person(ctx context.Context, personId int32, params *PersonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonRequest(c.Server, personId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Award(ctx context.Context, personId int32, params *AwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAwardRequest(c.Server, personId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Stats3(ctx context.Context, personId int32, params *Stats3Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStats3Request(c.Server, personId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlayerGameStats(ctx context.Context, personId int32, gamePk int32, params *PlayerGameStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlayerGameStatsRequest(c.Server, personId, gamePk, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatsMetrics(ctx context.Context, personId int32, params *StatsMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsMetricsRequest(c.Server, personId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PerformerTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPerformerTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PitchCodes(ctx context.Context, params *PitchCodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPitchCodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PitchTypes(ctx context.Context, params *PitchTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPitchTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Platforms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlatformsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlayerStatusCodes(ctx context.Context, params *PlayerStatusCodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlayerStatusCodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Positions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPositionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProps(ctx context.Context, params *GetPropsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPropsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPropsAdjust(ctx context.Context, params *GetPropsAdjustParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPropsAdjustRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReviewInfo(ctx context.Context, params *GetReviewInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReviewInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReviewReasons(ctx context.Context, params *ReviewReasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReviewReasonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RoofTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRoofTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RosterTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRosterTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RuleSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRuleSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunnerDetailTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunnerDetailTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Schedule(ctx context.Context, params *ScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScheduleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TieGames(ctx context.Context, params *TieGamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTieGamesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostseasonSchedule(ctx context.Context, params *PostseasonScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostseasonScheduleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostseasonScheduleSeries(ctx context.Context, params *PostseasonScheduleSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostseasonScheduleSeriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TuneIn(ctx context.Context, params *TuneInParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTuneInRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrackingEventsSchedule(ctx context.Context, params *TrackingEventsScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrackingEventsScheduleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Schedule1(ctx context.Context, scheduleType string, params *Schedule1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchedule1Request(c.Server, scheduleType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScheduleEventTypes(ctx context.Context, params *ScheduleEventTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScheduleEventTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScheduleTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScheduleTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Seasons(ctx context.Context, params *SeasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSeasonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllSeasons(ctx context.Context, params *AllSeasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllSeasonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Seasons1(ctx context.Context, seasonId string, params *Seasons1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSeasons1Request(c.Server, seasonId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SitCodes(ctx context.Context, params *SitCodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSitCodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sky(ctx context.Context, params *SkyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSkyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AggregateSortEnum(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAggregateSortEnumRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sports(ctx context.Context, params *SportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSportsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sports1(ctx context.Context, sportId int32, params *Sports1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSports1Request(c.Server, sportId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllSportBallot(ctx context.Context, sportId int32, params *AllSportBallotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllSportBallotRequest(c.Server, sportId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SportPlayers(ctx context.Context, sportId int32, params *SportPlayersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSportPlayersRequest(c.Server, sportId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Standings1(ctx context.Context, params *Standings1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStandings1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Standings(ctx context.Context, standingsType string, params *StandingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStandingsRequest(c.Server, standingsType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StandingsTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStandingsTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatFields(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatFieldsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatcastPositionTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatcastPositionTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Stats2(ctx context.Context, params *Stats2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStats2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutsAboveAverage(ctx context.Context, params *GetOutsAboveAverageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutsAboveAverageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSprayChart(ctx context.Context, params *GetSprayChartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSprayChartRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStolenBaseProbability(ctx context.Context, params *GetStolenBaseProbabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStolenBaseProbabilityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupedStats(ctx context.Context, params *GroupedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupedStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Leaders2(ctx context.Context, params *Leaders2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaders2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricStats(ctx context.Context, params *MetricStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BeastStats(ctx context.Context, params *BeastStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBeastStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatSearchConfig(ctx context.Context, params *StatSearchConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatSearchConfigRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatSearchGroupByTypes(ctx context.Context, params *StatSearchGroupByTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatSearchGroupByTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatSearchParams(ctx context.Context, params *StatSearchParamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatSearchParamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatSearchStats(ctx context.Context, params *StatSearchStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatSearchStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreaks(ctx context.Context, params *GetStreaksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreaksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreakTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreakTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Teams(ctx context.Context, params *TeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Affiliates1(ctx context.Context, params *Affiliates1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAffiliates1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllTeams1(ctx context.Context, params *AllTeams1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllTeams1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Stats1(ctx context.Context, params *Stats1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStats1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Leaders1(ctx context.Context, params *Leaders1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaders1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Teams1(ctx context.Context, teamId int32, params *Teams1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeams1Request(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Affiliates(ctx context.Context, teamId int32, params *AffiliatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAffiliatesRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Alumni(ctx context.Context, teamId int32, params *AlumniParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlumniRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAlumni(ctx context.Context, teamId int32, params *UpdateAlumniParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAlumniRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Coaches(ctx context.Context, teamId int32, params *CoachesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCoachesRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllTeams(ctx context.Context, teamId int32, params *AllTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllTeamsRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Leaders(ctx context.Context, teamId int32, params *LeadersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeadersRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Personnel(ctx context.Context, teamId int32, params *PersonnelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonnelRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Roster(ctx context.Context, teamId int32, params *RosterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRosterRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Roster1(ctx context.Context, teamId int32, rosterType string, params *Roster1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRoster1Request(c.Server, teamId, rosterType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Stats(ctx context.Context, teamId int32, params *StatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrackingSoftwareVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrackingSoftwareVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrackingSystemOwners(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrackingSystemOwnersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrackingVendors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrackingVendorsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrackingVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrackingVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransactionTypes(ctx context.Context, params *TransactionTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransactionTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Transactions(ctx context.Context, params *TransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UniformsByGame(ctx context.Context, params *UniformsByGameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUniformsByGameRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UniformsByTeam(ctx context.Context, params *UniformsByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUniformsByTeamRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Venues(ctx context.Context, params *VenuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVenuesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Venues1(ctx context.Context, venueId int32, params *Venues1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVenues1Request(c.Server, venueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VideoResolutionTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVideoResolutionTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ViolationTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewViolationTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WeatherForecast(ctx context.Context, gamePk int32, roofType RoofType, params *WeatherForecastParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWeatherForecastRequest(c.Server, gamePk, roofType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WeatherDataBasedOnPlay(ctx context.Context, gamePk int32, playId string, params *WeatherDataBasedOnPlayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWeatherDataBasedOnPlayRequest(c.Server, gamePk, playId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WeatherBasic(ctx context.Context, venueId int32, params *WeatherBasicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWeatherBasicRequest(c.Server, venueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WeatherFull(ctx context.Context, venueId int32, params *WeatherFullParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWeatherFullRequest(c.Server, venueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WeatherTrajectoryConfidences(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWeatherTrajectoryConfidencesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WindDirection(ctx context.Context, params *WindDirectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWindDirectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewLiveGameV1Request generates requests for LiveGameV1
func NewLiveGameV1Request(server string, gamePk int32, params *LiveGameV1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "game_pk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1.1/game/%s/feed/live", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InclusiveTimecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inclusiveTimecode", runtime.ParamLocationQuery, *params.InclusiveTimecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLiveGameDiffPatchV1Request generates requests for LiveGameDiffPatchV1
func NewLiveGameDiffPatchV1Request(server string, gamePk int32, params *LiveGameDiffPatchV1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "game_pk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1.1/game/%s/feed/live/diffPatch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartTimecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimecode", runtime.ParamLocationQuery, *params.StartTimecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTimecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endTimecode", runtime.ParamLocationQuery, *params.EndTimecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLiveTimestampv11Request generates requests for LiveTimestampv11
func NewLiveTimestampv11Request(server string, gamePk int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "game_pk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1.1/game/%s/feed/live/timestamps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAchievementStatusesRequest generates requests for AchievementStatuses
func NewAchievementStatusesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/achievementStatuses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGameGuidsFromPostgresRangeByGameRequest generates requests for GameGuidsFromPostgresRangeByGame
func NewGameGuidsFromPostgresRangeByGameRequest(server string, params *GameGuidsFromPostgresRangeByGameParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/analytics/game")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameModeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameModeId", runtime.ParamLocationQuery, *params.GameModeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPitch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPitch", runtime.ParamLocationQuery, *params.IsPitch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsHit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHit", runtime.ParamLocationQuery, *params.IsHit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPickoff != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPickoff", runtime.ParamLocationQuery, *params.IsPickoff); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNonStatcast != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNonStatcast", runtime.ParamLocationQuery, *params.IsNonStatcast); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamedayType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamedayType", runtime.ParamLocationQuery, *params.GamedayType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasUpdates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasUpdates", runtime.ParamLocationQuery, *params.HasUpdates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastPlayTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastPlayTime", runtime.ParamLocationQuery, *params.LastPlayTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastVideoUpdatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastVideoUpdatedTime", runtime.ParamLocationQuery, *params.LastVideoUpdatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastUpdatedTime", runtime.ParamLocationQuery, *params.LastUpdatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastMetricsUpdatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastMetricsUpdatedTime", runtime.ParamLocationQuery, *params.LastMetricsUpdatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastAuditUpdatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastAuditUpdatedTime", runtime.ParamLocationQuery, *params.LastAuditUpdatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameDate", runtime.ParamLocationQuery, *params.GameDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TrackingSystemOwner != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trackingSystemOwner", runtime.ParamLocationQuery, *params.TrackingSystemOwner); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduleEventTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduleEventTypes", runtime.ParamLocationQuery, *params.ScheduleEventTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGameGuidsFromPostgresRangeRequest generates requests for GameGuidsFromPostgresRange
func NewGameGuidsFromPostgresRangeRequest(server string, params *GameGuidsFromPostgresRangeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/analytics/guids")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameModeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameModeId", runtime.ParamLocationQuery, *params.GameModeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPitch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPitch", runtime.ParamLocationQuery, *params.IsPitch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsHit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHit", runtime.ParamLocationQuery, *params.IsHit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPickoff != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPickoff", runtime.ParamLocationQuery, *params.IsPickoff); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNonStatcast != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNonStatcast", runtime.ParamLocationQuery, *params.IsNonStatcast); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamedayType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamedayType", runtime.ParamLocationQuery, *params.GamedayType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasUpdates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasUpdates", runtime.ParamLocationQuery, *params.HasUpdates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastPlayTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastPlayTime", runtime.ParamLocationQuery, *params.LastPlayTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastUpdatedTime", runtime.ParamLocationQuery, *params.LastUpdatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastMetricsUpdatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastMetricsUpdatedTime", runtime.ParamLocationQuery, *params.LastMetricsUpdatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastAuditUpdatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastAuditUpdatedTime", runtime.ParamLocationQuery, *params.LastAuditUpdatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastVideoUpdatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastVideoUpdatedTime", runtime.ParamLocationQuery, *params.LastVideoUpdatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameDate", runtime.ParamLocationQuery, *params.GameDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TrackingSystemOwner != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trackingSystemOwner", runtime.ParamLocationQuery, *params.TrackingSystemOwner); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamAttendanceRequest generates requests for GetTeamAttendance
func NewGetTeamAttendanceRequest(server string, params *GetTeamAttendanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/attendance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueListId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueListId", runtime.ParamLocationQuery, *params.LeagueListId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAwardsRequest generates requests for Awards
func NewAwardsRequest(server string, params *AwardsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/awards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrgId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgId", runtime.ParamLocationQuery, *params.OrgId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAwards1Request generates requests for Awards1
func NewAwards1Request(server string, awardId string, params *Awards1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "awardId", runtime.ParamLocationPath, awardId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/awards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrgId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgId", runtime.ParamLocationQuery, *params.OrgId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAwardRecipientsRequest generates requests for AwardRecipients
func NewAwardRecipientsRequest(server string, awardId string, params *AwardRecipientsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "awardId", runtime.ParamLocationPath, awardId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/awards/%s/recipients", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBaseballStatsRequest generates requests for BaseballStats
func NewBaseballStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/baseballStats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBatTrackingRequest generates requests for BatTracking
func NewBatTrackingRequest(server string, gamePk int32, playId string, params *BatTrackingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "playId", runtime.ParamLocationPath, playId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/batTracking/game/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBroadcastsRequest generates requests for GetBroadcasts
func NewGetBroadcastsRequest(server string, params *GetBroadcastsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/broadcast")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcasterIds", runtime.ParamLocationQuery, params.BroadcasterIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBroadcastAvailabilityTypesRequest generates requests for BroadcastAvailabilityTypes
func NewBroadcastAvailabilityTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/broadcastAvailability")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllBroadcastersRequest generates requests for GetAllBroadcasters
func NewGetAllBroadcastersRequest(server string, params *GetAllBroadcastersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/broadcasters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ActiveStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activeStatus", runtime.ParamLocationQuery, *params.ActiveStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCoachingVideoTypesRequest generates requests for CoachingVideoTypes
func NewCoachingVideoTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/coachingVideoTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConferencesRequest generates requests for Conferences
func NewConferencesRequest(server string, params *ConferencesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/conferences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeInactive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeInactive", runtime.ParamLocationQuery, *params.IncludeInactive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConferences1Request generates requests for Conferences1
func NewConferences1Request(server string, conferenceId int32, params *Conferences1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "conferenceId", runtime.ParamLocationPath, conferenceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/conferences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeInactive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeInactive", runtime.ParamLocationQuery, *params.IncludeInactive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDivisionsRequest generates requests for Divisions
func NewDivisionsRequest(server string, params *DivisionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/divisions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeInactive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeInactive", runtime.ParamLocationQuery, *params.IncludeInactive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDivisions1Request generates requests for Divisions1
func NewDivisions1Request(server string, divisionId int32, params *Divisions1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "divisionId", runtime.ParamLocationPath, divisionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/divisions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeInactive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeInactive", runtime.ParamLocationQuery, *params.IncludeInactive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDraftPicksRequest generates requests for DraftPicks
func NewDraftPicksRequest(server string, params *DraftPicksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/draft")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Drafted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "drafted", runtime.ParamLocationQuery, *params.Drafted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Round != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "round", runtime.ParamLocationQuery, *params.Round); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.School != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "school", runtime.ParamLocationQuery, *params.School); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Position != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "position", runtime.ParamLocationQuery, *params.Position); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Team != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team", runtime.ParamLocationQuery, *params.Team); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Country != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerId", runtime.ParamLocationQuery, *params.PlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BisPlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bisPlayerId", runtime.ParamLocationQuery, *params.BisPlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDraftProspectsRequest generates requests for DraftProspects
func NewDraftProspectsRequest(server string, params *DraftProspectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/draft/prospects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Drafted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "drafted", runtime.ParamLocationQuery, *params.Drafted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Round != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "round", runtime.ParamLocationQuery, *params.Round); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.School != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "school", runtime.ParamLocationQuery, *params.School); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Position != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "position", runtime.ParamLocationQuery, *params.Position); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Team != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team", runtime.ParamLocationQuery, *params.Team); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Country != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerId", runtime.ParamLocationQuery, *params.PlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BisPlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bisPlayerId", runtime.ParamLocationQuery, *params.BisPlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDraftProspects1Request generates requests for DraftProspects1
func NewDraftProspects1Request(server string, year int32, params *DraftProspects1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/draft/prospects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Drafted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "drafted", runtime.ParamLocationQuery, *params.Drafted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Round != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "round", runtime.ParamLocationQuery, *params.Round); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.School != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "school", runtime.ParamLocationQuery, *params.School); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Position != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "position", runtime.ParamLocationQuery, *params.Position); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Team != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team", runtime.ParamLocationQuery, *params.Team); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Country != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerId", runtime.ParamLocationQuery, *params.PlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BisPlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bisPlayerId", runtime.ParamLocationQuery, *params.BisPlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDraftPicks1Request generates requests for DraftPicks1
func NewDraftPicks1Request(server string, year int32, params *DraftPicks1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/draft/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Drafted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "drafted", runtime.ParamLocationQuery, *params.Drafted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Round != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "round", runtime.ParamLocationQuery, *params.Round); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.School != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "school", runtime.ParamLocationQuery, *params.School); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Position != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "position", runtime.ParamLocationQuery, *params.Position); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Team != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team", runtime.ParamLocationQuery, *params.Team); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Country != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerId", runtime.ParamLocationQuery, *params.PlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BisPlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bisPlayerId", runtime.ParamLocationQuery, *params.BisPlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLatestDraftPicksRequest generates requests for LatestDraftPicks
func NewLatestDraftPicksRequest(server string, year int32, params *LatestDraftPicksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/draft/%s/latest", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventStatusRequest generates requests for EventStatus
func NewEventStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/eventStatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventTypesRequest generates requests for EventTypes
func NewEventTypesRequest(server string, params *EventTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/eventTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFielderDetailTypesRequest generates requests for FielderDetailTypes
func NewFielderDetailTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/fielderDetailTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFreeGameTypesRequest generates requests for FreeGameTypes
func NewFreeGameTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/freeGameTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCurrentGameStats1Request generates requests for CurrentGameStats1
func NewCurrentGameStats1Request(server string, params *CurrentGameStats1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/changes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedSince", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportIds", runtime.ParamLocationQuery, *params.SportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameTypes", runtime.ParamLocationQuery, *params.GameTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamePks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePks", runtime.ParamLocationQuery, *params.GamePks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGameLastPitchRequest generates requests for GameLastPitch
func NewGameLastPitchRequest(server string, params *GameLastPitchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/lastPitch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePks", runtime.ParamLocationQuery, params.GamePks); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGameContextMetricsRequest generates requests for GetGameContextMetrics
func NewGetGameContextMetricsRequest(server string, gamePk int32, params *GetGameContextMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/contextMetrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGameGuidsRequest generates requests for GameGuids
func NewGameGuidsRequest(server string, gamePk int32, params *GameGuidsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/guids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameModeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameModeId", runtime.ParamLocationQuery, *params.GameModeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPitch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPitch", runtime.ParamLocationQuery, *params.IsPitch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsHit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHit", runtime.ParamLocationQuery, *params.IsHit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPickoff != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPickoff", runtime.ParamLocationQuery, *params.IsPickoff); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasUpdates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasUpdates", runtime.ParamLocationQuery, *params.HasUpdates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedSince", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastPlayTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastPlayTime", runtime.ParamLocationQuery, *params.LastPlayTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastUpdatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastUpdatedTime", runtime.ParamLocationQuery, *params.LastUpdatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastMetricsUpdatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastMetricsUpdatedTime", runtime.ParamLocationQuery, *params.LastMetricsUpdatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastAuditUpdatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastAuditUpdatedTime", runtime.ParamLocationQuery, *params.LastAuditUpdatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastVideoUpdatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastVideoUpdatedTime", runtime.ParamLocationQuery, *params.LastVideoUpdatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWinProbabilityRequest generates requests for GetWinProbability
func NewGetWinProbabilityRequest(server string, gamePk int32, params *GetWinProbabilityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/winProbability", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InclusiveTimecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inclusiveTimecode", runtime.ParamLocationQuery, *params.InclusiveTimecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGameWithMetricsRequest generates requests for GetGameWithMetrics
func NewGetGameWithMetricsRequest(server string, gamePk int32, params *GetGameWithMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/withMetrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InclusiveTimecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inclusiveTimecode", runtime.ParamLocationQuery, *params.InclusiveTimecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewParsedJsonFormattedAnalyticsRequest generates requests for ParsedJsonFormattedAnalytics
func NewParsedJsonFormattedAnalyticsRequest(server string, gamePk int32, guid string, params *ParsedJsonFormattedAnalyticsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "guid", runtime.ParamLocationPath, guid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/%s/analytics", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewContextMetricsRequest generates requests for ContextMetrics
func NewContextMetricsRequest(server string, gamePk int32, guid string, params *ContextMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "guid", runtime.ParamLocationPath, guid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/%s/contextMetrics", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewContextMetricsWithAveragesRequest generates requests for ContextMetricsWithAverages
func NewContextMetricsWithAveragesRequest(server string, gamePk int32, guid string, params *ContextMetricsWithAveragesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "guid", runtime.ParamLocationPath, guid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/%s/contextMetricsAverages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewContextMetricsWithAveragesPostRequest generates requests for ContextMetricsWithAveragesPost
func NewContextMetricsWithAveragesPostRequest(server string, gamePk int32, guid string, params *ContextMetricsWithAveragesPostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "guid", runtime.ParamLocationPath, guid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/%s/contextMetricsAverages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHomeRunBallparksRequest generates requests for HomeRunBallparks
func NewHomeRunBallparksRequest(server string, gamePk int32, guid string, params *HomeRunBallparksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "guid", runtime.ParamLocationPath, guid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/%s/homeRunBallparks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHomeRunParks", runtime.ParamLocationQuery, params.IsHomeRunParks); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBiomechanicalRequest generates requests for Biomechanical
func NewBiomechanicalRequest(server string, gamePk int32, playId string, positionId int32, params *BiomechanicalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "playId", runtime.ParamLocationPath, playId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "positionId", runtime.ParamLocationPath, positionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/%s/analytics/biomechanics/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSkeletalChunkedRequest generates requests for SkeletalChunked
func NewSkeletalChunkedRequest(server string, gamePk int32, playId string, params *SkeletalChunkedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "playId", runtime.ParamLocationPath, playId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/%s/analytics/skeletalData/chunked", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fileName", runtime.ParamLocationQuery, params.FileName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSkeletalDataFileNamesRequest generates requests for SkeletalDataFileNames
func NewSkeletalDataFileNamesRequest(server string, gamePk int32, playId string, params *SkeletalDataFileNamesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "playId", runtime.ParamLocationPath, playId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/%s/analytics/skeletalData/files", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBoxscoreRequest generates requests for Boxscore
func NewBoxscoreRequest(server string, gamePk int32, params *BoxscoreParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "game_pk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/boxscore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InclusiveTimecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inclusiveTimecode", runtime.ParamLocationQuery, *params.InclusiveTimecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NumPlayers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "numPlayers", runtime.ParamLocationQuery, *params.NumPlayers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoTies != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "noTies", runtime.ParamLocationQuery, *params.NoTies); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewContentRequest generates requests for Content
func NewContentRequest(server string, gamePk int32, params *ContentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "game_pk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.HighlightLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "highlightLimit", runtime.ParamLocationQuery, *params.HighlightLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewColorFeedRequest generates requests for ColorFeed
func NewColorFeedRequest(server string, gamePk int32, params *ColorFeedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "game_pk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/feed/color", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewColorTimestampsRequest generates requests for ColorTimestamps
func NewColorTimestampsRequest(server string, gamePk int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "game_pk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/feed/color/timestamps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinescoreRequest generates requests for Linescore
func NewLinescoreRequest(server string, gamePk int32, params *LinescoreParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "game_pk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/linescore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InclusiveTimecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inclusiveTimecode", runtime.ParamLocationQuery, *params.InclusiveTimecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPlayByPlayRequest generates requests for PlayByPlay
func NewPlayByPlayRequest(server string, gamePk int32, params *PlayByPlayParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "game_pk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/game/%s/playByPlay", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InclusiveTimecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inclusiveTimecode", runtime.ParamLocationQuery, *params.InclusiveTimecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGamePaceRequest generates requests for GamePace
func NewGamePaceRequest(server string, params *GamePaceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/gamePace")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamIds", runtime.ParamLocationQuery, *params.TeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueListId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueListId", runtime.ParamLocationQuery, *params.LeagueListId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportIds", runtime.ParamLocationQuery, *params.SportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VenueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "venueIds", runtime.ParamLocationQuery, *params.VenueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeVenueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeVenueIds", runtime.ParamLocationQuery, *params.ExcludeVenueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeGamePks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeGamePks", runtime.ParamLocationQuery, *params.ExcludeGamePks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrgType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgType", runtime.ParamLocationQuery, *params.OrgType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeChildren != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeChildren", runtime.ParamLocationQuery, *params.IncludeChildren); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGameStatusRequest generates requests for GameStatus
func NewGameStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/gameStatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGameStatusesRequest generates requests for UpdateGameStatuses
func NewUpdateGameStatusesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/gameStatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGameTypesRequest generates requests for GameTypes
func NewGameTypesRequest(server string, params *GameTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/gameTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGamedayTypesRequest generates requests for GamedayTypes
func NewGamedayTypesRequest(server string, params *GamedayTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/gamedayTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGroupByTypesRequest generates requests for GroupByTypes
func NewGroupByTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/groupByTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHighLowStatsRequest generates requests for HighLowStats
func NewHighLowStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/highLow/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHighLowRequest generates requests for HighLow
func NewHighLowRequest(server string, highLowType HighLowTypeEnum, params *HighLowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "highLowType", runtime.ParamLocationPath, highLowType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/highLow/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StatGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statGroup", runtime.ParamLocationQuery, *params.StatGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortStat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortStat", runtime.ParamLocationQuery, *params.SortStat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHitTrajectoriesRequest generates requests for HitTrajectories
func NewHitTrajectoriesRequest(server string, params *HitTrajectoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/hitTrajectories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHomeRunDerbyBracket1Request generates requests for HomeRunDerbyBracket1
func NewHomeRunDerbyBracket1Request(server string, params *HomeRunDerbyBracket1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/homeRunDerby")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHomeRunDerbyBracket3Request generates requests for HomeRunDerbyBracket3
func NewHomeRunDerbyBracket3Request(server string, params *HomeRunDerbyBracket3Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/homeRunDerby/bracket")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHomeRunDerbyMixedMode1Request generates requests for HomeRunDerbyMixedMode1
func NewHomeRunDerbyMixedMode1Request(server string, params *HomeRunDerbyMixedMode1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/homeRunDerby/mixed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHomeRunDerbyPool1Request generates requests for HomeRunDerbyPool1
func NewHomeRunDerbyPool1Request(server string, params *HomeRunDerbyPool1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/homeRunDerby/pool")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHomeRunDerbyBracketRequest generates requests for HomeRunDerbyBracket
func NewHomeRunDerbyBracketRequest(server string, gamePk int32, params *HomeRunDerbyBracketParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/homeRunDerby/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHomeRunDerbyBracket2Request generates requests for HomeRunDerbyBracket2
func NewHomeRunDerbyBracket2Request(server string, gamePk int32, params *HomeRunDerbyBracket2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/homeRunDerby/%s/bracket", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHomeRunDerbyMixedModeRequest generates requests for HomeRunDerbyMixedMode
func NewHomeRunDerbyMixedModeRequest(server string, gamePk int32, params *HomeRunDerbyMixedModeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/homeRunDerby/%s/mixed", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHomeRunDerbyPoolRequest generates requests for HomeRunDerbyPool
func NewHomeRunDerbyPoolRequest(server string, gamePk int32, params *HomeRunDerbyPoolParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/homeRunDerby/%s/pool", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJobTypesRequest generates requests for JobTypes
func NewJobTypesRequest(server string, params *JobTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateJobTypesRequest generates requests for UpdateJobTypes
func NewUpdateJobTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobsByTypeRequest generates requests for GetJobsByType
func NewGetJobsByTypeRequest(server string, params *GetJobsByTypeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobType", runtime.ParamLocationQuery, params.JobType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatacastersRequest generates requests for Datacasters
func NewDatacastersRequest(server string, params *DatacastersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs/datacasters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOfficialScorersRequest generates requests for OfficialScorers
func NewOfficialScorersRequest(server string, params *OfficialScorersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs/officialScorers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUmpiresRequest generates requests for Umpires
func NewUmpiresRequest(server string, params *UmpiresParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs/umpires")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUmpireScheduleRequest generates requests for UmpireSchedule
func NewUmpireScheduleRequest(server string, umpireId int32, params *UmpireScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "umpireId", runtime.ParamLocationPath, umpireId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs/umpires/games/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, params.Season); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLanguagesRequest generates requests for Languages
func NewLanguagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/languages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeagueRequest generates requests for League
func NewLeagueRequest(server string, params *LeagueParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/league")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActiveStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activeStatus", runtime.ParamLocationQuery, *params.ActiveStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllStarBallotRequest generates requests for AllStarBallot
func NewAllStarBallotRequest(server string, params *AllStarBallotParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/league/allStarBallot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeague1Request generates requests for League1
func NewLeague1Request(server string, leagueId int32, params *League1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "leagueId", runtime.ParamLocationPath, leagueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/league/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActiveStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activeStatus", runtime.ParamLocationQuery, *params.ActiveStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllStarBallot1Request generates requests for AllStarBallot1
func NewAllStarBallot1Request(server string, leagueId int32, params *AllStarBallot1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "leagueId", runtime.ParamLocationPath, leagueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/league/%s/allStarBallot", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllStarFinalVoteRequest generates requests for AllStarFinalVote
func NewAllStarFinalVoteRequest(server string, leagueId int32, params *AllStarFinalVoteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "leagueId", runtime.ParamLocationPath, leagueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/league/%s/allStarFinalVote", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllStarWriteInsRequest generates requests for AllStarWriteIns
func NewAllStarWriteInsRequest(server string, leagueId int32, params *AllStarWriteInsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "leagueId", runtime.ParamLocationPath, leagueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/league/%s/allStarWriteIns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeagueLeaderTypesRequest generates requests for LeagueLeaderTypes
func NewLeagueLeaderTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/leagueLeaderTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeague2Request generates requests for League2
func NewLeague2Request(server string, params *League2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/leagues")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActiveStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activeStatus", runtime.ParamLocationQuery, *params.ActiveStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllStarBallot2Request generates requests for AllStarBallot2
func NewAllStarBallot2Request(server string, params *AllStarBallot2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/leagues/allStarBallot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeague3Request generates requests for League3
func NewLeague3Request(server string, leagueId int32, params *League3Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "leagueId", runtime.ParamLocationPath, leagueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/leagues/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActiveStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activeStatus", runtime.ParamLocationQuery, *params.ActiveStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllStarBallot3Request generates requests for AllStarBallot3
func NewAllStarBallot3Request(server string, leagueId int32, params *AllStarBallot3Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "leagueId", runtime.ParamLocationPath, leagueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/leagues/%s/allStarBallot", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllStarFinalVote1Request generates requests for AllStarFinalVote1
func NewAllStarFinalVote1Request(server string, leagueId int32, params *AllStarFinalVote1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "leagueId", runtime.ParamLocationPath, leagueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/leagues/%s/allStarFinalVote", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllStarWriteIns1Request generates requests for AllStarWriteIns1
func NewAllStarWriteIns1Request(server string, leagueId int32, params *AllStarWriteIns1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "leagueId", runtime.ParamLocationPath, leagueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/leagues/%s/allStarWriteIns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogicalEventsRequest generates requests for LogicalEvents
func NewLogicalEventsRequest(server string, params *LogicalEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/logicalEvents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLookupValuesRequest generates requests for GetLookupValues
func NewGetLookupValuesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/lookup/values/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMediaStateTypesRequest generates requests for MediaStateTypes
func NewMediaStateTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/mediaState")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetricsRequest generates requests for Metrics
func NewMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMilestoneDurationsRequest generates requests for MilestoneDurations
func NewMilestoneDurationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/milestoneDurations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMilestoneLookupsRequest generates requests for MilestoneLookups
func NewMilestoneLookupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/milestoneLookups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMilestoneStatisticsRequest generates requests for MilestoneStatistics
func NewMilestoneStatisticsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/milestoneStatistics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMilestoneTypesRequest generates requests for MilestoneTypes
func NewMilestoneTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/milestoneTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMilestonesRequest generates requests for Milestones
func NewMilestonesRequest(server string, params *MilestonesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/milestones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrgType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgType", runtime.ParamLocationQuery, *params.OrgType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AchievementStatuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "achievementStatuses", runtime.ParamLocationQuery, *params.AchievementStatuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MilestoneTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "milestoneTypes", runtime.ParamLocationQuery, *params.MilestoneTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsLastAchievement != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isLastAchievement", runtime.ParamLocationQuery, *params.IsLastAchievement); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MilestoneStatistics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "milestoneStatistics", runtime.ParamLocationQuery, *params.MilestoneStatistics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MilestoneValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "milestoneValues", runtime.ParamLocationQuery, *params.MilestoneValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerIds", runtime.ParamLocationQuery, *params.PlayerIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamIds", runtime.ParamLocationQuery, *params.TeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statGroup", runtime.ParamLocationQuery, *params.StatGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VenueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "venueIds", runtime.ParamLocationQuery, *params.VenueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamePks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePks", runtime.ParamLocationQuery, *params.GamePks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowFirsts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "showFirsts", runtime.ParamLocationQuery, *params.ShowFirsts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMoundVisitTypesRequest generates requests for MoundVisitTypes
func NewMoundVisitTypesRequest(server string, params *MoundVisitTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/moundVisitTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPerson1Request generates requests for Person1
func NewPerson1Request(server string, params *Person1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/people")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PersonIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personIds", runtime.ParamLocationQuery, *params.PersonIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCurrentGameStatsRequest generates requests for CurrentGameStats
func NewCurrentGameStatsRequest(server string, params *CurrentGameStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/people/changes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedSince", runtime.ParamLocationQuery, params.UpdatedSince); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFreeAgentsRequest generates requests for FreeAgents
func NewFreeAgentsRequest(server string, params *FreeAgentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/people/freeAgents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, params.Season); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRequest generates requests for Search
func NewSearchRequest(server string, params *SearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/people/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personIds", runtime.ParamLocationQuery, *params.PersonIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportIds", runtime.ParamLocationQuery, *params.SportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamIds", runtime.ParamLocationQuery, *params.TeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueListId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueListId", runtime.ParamLocationQuery, *params.LeagueListId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Active != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Verified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "verified", runtime.ParamLocationQuery, *params.Verified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Rookie != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rookie", runtime.ParamLocationQuery, *params.Rookie); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersonRequest generates requests for Person
func NewPersonRequest(server string, personId int32, params *PersonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "personId", runtime.ParamLocationPath, personId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/people/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PersonIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personIds", runtime.ParamLocationQuery, *params.PersonIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAwardRequest generates requests for Award
func NewAwardRequest(server string, personId int32, params *AwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "personId", runtime.ParamLocationPath, personId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/people/%s/awards", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStats3Request generates requests for Stats3
func NewStats3Request(server string, personId int32, params *Stats3Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "personId", runtime.ParamLocationPath, personId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/people/%s/stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stats", runtime.ParamLocationQuery, params.Stats); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpposingTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opposingTeamId", runtime.ParamLocationQuery, *params.OpposingTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpposingPlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opposingPlayerId", runtime.ParamLocationQuery, *params.OpposingPlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Metrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metrics", runtime.ParamLocationQuery, *params.Metrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueListId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueListId", runtime.ParamLocationQuery, *params.LeagueListId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SitCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sitCodes", runtime.ParamLocationQuery, *params.SitCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CombineSits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "combineSits", runtime.ParamLocationQuery, *params.CombineSits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DaysBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "daysBack", runtime.ParamLocationQuery, *params.DaysBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamesBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamesBack", runtime.ParamLocationQuery, *params.GamesBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventType", runtime.ParamLocationQuery, *params.EventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitchType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitchType", runtime.ParamLocationQuery, *params.PitchType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HitTrajectory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hitTrajectory", runtime.ParamLocationQuery, *params.HitTrajectory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatSide != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batSide", runtime.ParamLocationQuery, *params.BatSide); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupBy", runtime.ParamLocationQuery, *params.GroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPlayerGameStatsRequest generates requests for PlayerGameStats
func NewPlayerGameStatsRequest(server string, personId int32, gamePk int32, params *PlayerGameStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "personId", runtime.ParamLocationPath, personId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/people/%s/stats/game/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatsMetricsRequest generates requests for StatsMetrics
func NewStatsMetricsRequest(server string, personId int32, params *StatsMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "personId", runtime.ParamLocationPath, personId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/people/%s/stats/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stats", runtime.ParamLocationQuery, params.Stats); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpposingTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opposingTeamId", runtime.ParamLocationQuery, *params.OpposingTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpposingPlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opposingPlayerId", runtime.ParamLocationQuery, *params.OpposingPlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Metrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metrics", runtime.ParamLocationQuery, *params.Metrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueListId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueListId", runtime.ParamLocationQuery, *params.LeagueListId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SitCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sitCodes", runtime.ParamLocationQuery, *params.SitCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CombineSits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "combineSits", runtime.ParamLocationQuery, *params.CombineSits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DaysBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "daysBack", runtime.ParamLocationQuery, *params.DaysBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamesBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamesBack", runtime.ParamLocationQuery, *params.GamesBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventType", runtime.ParamLocationQuery, *params.EventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitchType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitchType", runtime.ParamLocationQuery, *params.PitchType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HitTrajectory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hitTrajectory", runtime.ParamLocationQuery, *params.HitTrajectory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatSide != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batSide", runtime.ParamLocationQuery, *params.BatSide); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupBy", runtime.ParamLocationQuery, *params.GroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPerformerTypesRequest generates requests for PerformerTypes
func NewPerformerTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/performerTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPitchCodesRequest generates requests for PitchCodes
func NewPitchCodesRequest(server string, params *PitchCodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/pitchCodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPitchTypesRequest generates requests for PitchTypes
func NewPitchTypesRequest(server string, params *PitchTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/pitchTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPlatformsRequest generates requests for Platforms
func NewPlatformsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/platforms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPlayerStatusCodesRequest generates requests for PlayerStatusCodes
func NewPlayerStatusCodesRequest(server string, params *PlayerStatusCodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/playerStatusCodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPositionsRequest generates requests for Positions
func NewPositionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/positions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPropsRequest generates requests for GetProps
func NewGetPropsRequest(server string, params *GetPropsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/props/play/predictions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BatterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batterId", runtime.ParamLocationQuery, *params.BatterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitcherId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitcherId", runtime.ParamLocationQuery, *params.PitcherId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VenueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "venueId", runtime.ParamLocationQuery, *params.VenueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatSide != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batSide", runtime.ParamLocationQuery, *params.BatSide); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitchHand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitchHand", runtime.ParamLocationQuery, *params.PitchHand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatterPosition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batterPosition", runtime.ParamLocationQuery, *params.BatterPosition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitcherPosition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitcherPosition", runtime.ParamLocationQuery, *params.PitcherPosition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPropsAdjustRequest generates requests for GetPropsAdjust
func NewGetPropsAdjustRequest(server string, params *GetPropsAdjustParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/props/play/predictions/adjust")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePk", runtime.ParamLocationQuery, params.GamePk); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReviewInfoRequest generates requests for GetReviewInfo
func NewGetReviewInfoRequest(server string, params *GetReviewInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/review")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, params.SportId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, params.Season); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReviewReasonsRequest generates requests for ReviewReasons
func NewReviewReasonsRequest(server string, params *ReviewReasonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reviewReasons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRoofTypesRequest generates requests for RoofTypes
func NewRoofTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/roofTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRosterTypesRequest generates requests for RosterTypes
func NewRosterTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/rosterTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRuleSettingsRequest generates requests for RuleSettings
func NewRuleSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ruleSettings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunnerDetailTypesRequest generates requests for RunnerDetailTypes
func NewRunnerDetailTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/runnerDetailTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScheduleRequest generates requests for Schedule
func NewScheduleRequest(server string, params *ScheduleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/schedule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CalendarTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "calendarTypes", runtime.ParamLocationQuery, *params.CalendarTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventTypes", runtime.ParamLocationQuery, *params.EventTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduleEventTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduleEventTypes", runtime.ParamLocationQuery, *params.ScheduleEventTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamePk != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePk", runtime.ParamLocationQuery, *params.GamePk); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamePks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePks", runtime.ParamLocationQuery, *params.GamePks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventIds", runtime.ParamLocationQuery, *params.EventIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VenueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "venueIds", runtime.ParamLocationQuery, *params.VenueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerformerIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "performerIds", runtime.ParamLocationQuery, *params.PerformerIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameTypes", runtime.ParamLocationQuery, *params.GameTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UseLatestGames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useLatestGames", runtime.ParamLocationQuery, *params.UseLatestGames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpponentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opponentId", runtime.ParamLocationQuery, *params.OpponentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublicFacing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publicFacing", runtime.ParamLocationQuery, *params.PublicFacing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "usingPrivateEndpoint", runtime.ParamLocationQuery, params.UsingPrivateEndpoint); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTieGamesRequest generates requests for TieGames
func NewTieGamesRequest(server string, params *TieGamesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/schedule/games/tied")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameTypes", runtime.ParamLocationQuery, *params.GameTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, params.Season); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostseasonScheduleRequest generates requests for PostseasonSchedule
func NewPostseasonScheduleRequest(server string, params *PostseasonScheduleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/schedule/postseason")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GameTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameTypes", runtime.ParamLocationQuery, *params.GameTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seriesNumber", runtime.ParamLocationQuery, *params.SeriesNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UseLatestGames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useLatestGames", runtime.ParamLocationQuery, *params.UseLatestGames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UseFeaturedGame != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useFeaturedGame", runtime.ParamLocationQuery, *params.UseFeaturedGame); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublicFacing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publicFacing", runtime.ParamLocationQuery, *params.PublicFacing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostseasonScheduleSeriesRequest generates requests for PostseasonScheduleSeries
func NewPostseasonScheduleSeriesRequest(server string, params *PostseasonScheduleSeriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/schedule/postseason/series")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GameTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameTypes", runtime.ParamLocationQuery, *params.GameTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seriesNumber", runtime.ParamLocationQuery, *params.SeriesNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UseLatestGames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useLatestGames", runtime.ParamLocationQuery, *params.UseLatestGames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UseFeaturedGame != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useFeaturedGame", runtime.ParamLocationQuery, *params.UseFeaturedGame); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTuneInRequest generates requests for TuneIn
func NewTuneInRequest(server string, params *TuneInParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/schedule/postseason/tuneIn")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTrackingEventsScheduleRequest generates requests for TrackingEventsSchedule
func NewTrackingEventsScheduleRequest(server string, params *TrackingEventsScheduleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/schedule/trackingEvents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CalendarTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "calendarTypes", runtime.ParamLocationQuery, *params.CalendarTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventTypes", runtime.ParamLocationQuery, *params.EventTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamePk != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePk", runtime.ParamLocationQuery, *params.GamePk); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamePks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePks", runtime.ParamLocationQuery, *params.GamePks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventIds", runtime.ParamLocationQuery, *params.EventIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VenueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "venueIds", runtime.ParamLocationQuery, *params.VenueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerformerIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "performerIds", runtime.ParamLocationQuery, *params.PerformerIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameTypes", runtime.ParamLocationQuery, *params.GameTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UseLatestGames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useLatestGames", runtime.ParamLocationQuery, *params.UseLatestGames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpponentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opponentId", runtime.ParamLocationQuery, *params.OpponentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublicFacing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publicFacing", runtime.ParamLocationQuery, *params.PublicFacing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSchedule1Request generates requests for Schedule1
func NewSchedule1Request(server string, scheduleType string, params *Schedule1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scheduleType", runtime.ParamLocationPath, scheduleType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/schedule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CalendarTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "calendarTypes", runtime.ParamLocationQuery, *params.CalendarTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventTypes", runtime.ParamLocationQuery, *params.EventTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduleEventTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduleEventTypes", runtime.ParamLocationQuery, *params.ScheduleEventTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamePk != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePk", runtime.ParamLocationQuery, *params.GamePk); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamePks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePks", runtime.ParamLocationQuery, *params.GamePks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventIds", runtime.ParamLocationQuery, *params.EventIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VenueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "venueIds", runtime.ParamLocationQuery, *params.VenueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerformerIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "performerIds", runtime.ParamLocationQuery, *params.PerformerIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameTypes", runtime.ParamLocationQuery, *params.GameTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UseLatestGames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useLatestGames", runtime.ParamLocationQuery, *params.UseLatestGames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpponentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opponentId", runtime.ParamLocationQuery, *params.OpponentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublicFacing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publicFacing", runtime.ParamLocationQuery, *params.PublicFacing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "usingPrivateEndpoint", runtime.ParamLocationQuery, params.UsingPrivateEndpoint); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScheduleEventTypesRequest generates requests for ScheduleEventTypes
func NewScheduleEventTypesRequest(server string, params *ScheduleEventTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/scheduleEventTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScheduleTypesRequest generates requests for ScheduleTypes
func NewScheduleTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/scheduleTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSeasonsRequest generates requests for Seasons
func NewSeasonsRequest(server string, params *SeasonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/seasons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithGameTypeDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withGameTypeDates", runtime.ParamLocationQuery, *params.WithGameTypeDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllSeasonsRequest generates requests for AllSeasons
func NewAllSeasonsRequest(server string, params *AllSeasonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/seasons/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DivisionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "divisionId", runtime.ParamLocationQuery, *params.DivisionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithGameTypeDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withGameTypeDates", runtime.ParamLocationQuery, *params.WithGameTypeDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSeasons1Request generates requests for Seasons1
func NewSeasons1Request(server string, seasonId string, params *Seasons1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "seasonId", runtime.ParamLocationPath, seasonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/seasons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithGameTypeDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withGameTypeDates", runtime.ParamLocationQuery, *params.WithGameTypeDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSitCodesRequest generates requests for SitCodes
func NewSitCodesRequest(server string, params *SitCodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/situationCodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statGroup", runtime.ParamLocationQuery, *params.StatGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSkyRequest generates requests for Sky
func NewSkyRequest(server string, params *SkyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sky")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAggregateSortEnumRequest generates requests for AggregateSortEnum
func NewAggregateSortEnumRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sortModifiers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSportsRequest generates requests for Sports
func NewSportsRequest(server string, params *SportsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasStats != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasStats", runtime.ParamLocationQuery, *params.HasStats); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActiveStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activeStatus", runtime.ParamLocationQuery, *params.ActiveStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSports1Request generates requests for Sports1
func NewSports1Request(server string, sportId int32, params *Sports1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sportId", runtime.ParamLocationPath, sportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasStats != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasStats", runtime.ParamLocationQuery, *params.HasStats); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActiveStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activeStatus", runtime.ParamLocationQuery, *params.ActiveStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllSportBallotRequest generates requests for AllSportBallot
func NewAllSportBallotRequest(server string, sportId int32, params *AllSportBallotParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sportId", runtime.ParamLocationPath, sportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sports/%s/allSportBallot", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, params.Season); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSportPlayersRequest generates requests for SportPlayers
func NewSportPlayersRequest(server string, sportId int32, params *SportPlayersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sportId", runtime.ParamLocationPath, sportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sports/%s/players", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasStats != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasStats", runtime.ParamLocationQuery, *params.HasStats); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accent", runtime.ParamLocationQuery, *params.Accent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStandings1Request generates requests for Standings1
func NewStandings1Request(server string, params *Standings1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/standings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StandingsTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "standingsTypes", runtime.ParamLocationQuery, *params.StandingsTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeMLB != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeMLB", runtime.ParamLocationQuery, *params.IncludeMLB); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStandingsRequest generates requests for Standings
func NewStandingsRequest(server string, standingsType string, params *StandingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "standingsType", runtime.ParamLocationPath, standingsType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/standings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StandingsTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "standingsTypes", runtime.ParamLocationQuery, *params.StandingsTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeMLB != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeMLB", runtime.ParamLocationQuery, *params.IncludeMLB); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStandingsTypesRequest generates requests for StandingsTypes
func NewStandingsTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/standingsTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatFieldsRequest generates requests for StatFields
func NewStatFieldsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/statFields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatGroupsRequest generates requests for StatGroups
func NewStatGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/statGroups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatTypesRequest generates requests for StatTypes
func NewStatTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/statTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatcastPositionTypesRequest generates requests for StatcastPositionTypes
func NewStatcastPositionTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/statcastPositionTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStats2Request generates requests for Stats2
func NewStats2Request(server string, params *Stats2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stats", runtime.ParamLocationQuery, params.Stats); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personId", runtime.ParamLocationQuery, *params.PersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamIds", runtime.ParamLocationQuery, *params.TeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportIds", runtime.ParamLocationQuery, *params.SportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueListId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueListId", runtime.ParamLocationQuery, *params.LeagueListId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Metrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metrics", runtime.ParamLocationQuery, *params.Metrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamePk != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePk", runtime.ParamLocationQuery, *params.GamePk); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatterTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batterTeamId", runtime.ParamLocationQuery, *params.BatterTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitcherTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitcherTeamId", runtime.ParamLocationQuery, *params.PitcherTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batterId", runtime.ParamLocationQuery, *params.BatterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitcherId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitcherId", runtime.ParamLocationQuery, *params.PitcherId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SitCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sitCodes", runtime.ParamLocationQuery, *params.SitCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CombineSits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "combineSits", runtime.ParamLocationQuery, *params.CombineSits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpposingTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opposingTeamId", runtime.ParamLocationQuery, *params.OpposingTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortStat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortStat", runtime.ParamLocationQuery, *params.SortStat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerPool != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerPool", runtime.ParamLocationQuery, *params.PlayerPool); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Position != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "position", runtime.ParamLocationQuery, *params.Position); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DaysBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "daysBack", runtime.ParamLocationQuery, *params.DaysBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamesBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamesBack", runtime.ParamLocationQuery, *params.GamesBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeTradedPlayers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeTradedPlayers", runtime.ParamLocationQuery, *params.ExcludeTradedPlayers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOutsAboveAverageRequest generates requests for GetOutsAboveAverage
func NewGetOutsAboveAverageRequest(server string, params *GetOutsAboveAverageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stats/analytics/outsAboveAverage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePk", runtime.ParamLocationQuery, params.GamePk); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSprayChartRequest generates requests for GetSprayChart
func NewGetSprayChartRequest(server string, params *GetSprayChartParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stats/analytics/sprayChart")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePk", runtime.ParamLocationQuery, params.GamePk); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStolenBaseProbabilityRequest generates requests for GetStolenBaseProbability
func NewGetStolenBaseProbabilityRequest(server string, params *GetStolenBaseProbabilityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stats/analytics/stolenBaseProbability")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePk", runtime.ParamLocationQuery, params.GamePk); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Timecode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timecode", runtime.ParamLocationQuery, *params.Timecode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGroupedStatsRequest generates requests for GroupedStats
func NewGroupedStatsRequest(server string, params *GroupedStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stats/grouped")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stats", runtime.ParamLocationQuery, params.Stats); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personId", runtime.ParamLocationQuery, *params.PersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamIds", runtime.ParamLocationQuery, *params.TeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportIds", runtime.ParamLocationQuery, *params.SportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueListId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueListId", runtime.ParamLocationQuery, *params.LeagueListId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Metrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metrics", runtime.ParamLocationQuery, *params.Metrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamePk != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePk", runtime.ParamLocationQuery, *params.GamePk); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatterTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batterTeamId", runtime.ParamLocationQuery, *params.BatterTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitcherTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitcherTeamId", runtime.ParamLocationQuery, *params.PitcherTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batterId", runtime.ParamLocationQuery, *params.BatterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitcherId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitcherId", runtime.ParamLocationQuery, *params.PitcherId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SitCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sitCodes", runtime.ParamLocationQuery, *params.SitCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CombineSits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "combineSits", runtime.ParamLocationQuery, *params.CombineSits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpposingTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opposingTeamId", runtime.ParamLocationQuery, *params.OpposingTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortStat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortStat", runtime.ParamLocationQuery, *params.SortStat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerPool != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerPool", runtime.ParamLocationQuery, *params.PlayerPool); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Position != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "position", runtime.ParamLocationQuery, *params.Position); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DaysBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "daysBack", runtime.ParamLocationQuery, *params.DaysBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamesBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamesBack", runtime.ParamLocationQuery, *params.GamesBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeTradedPlayers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeTradedPlayers", runtime.ParamLocationQuery, *params.ExcludeTradedPlayers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statFields", runtime.ParamLocationQuery, *params.StatFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortField", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaders2Request generates requests for Leaders2
func NewLeaders2Request(server string, params *Leaders2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stats/leaders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeaderCategories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leaderCategories", runtime.ParamLocationQuery, *params.LeaderCategories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeaderGameTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leaderGameTypes", runtime.ParamLocationQuery, *params.LeaderGameTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statGroup", runtime.ParamLocationQuery, *params.StatGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportIds", runtime.ParamLocationQuery, *params.SportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stats != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stats", runtime.ParamLocationQuery, *params.Stats); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamIds", runtime.ParamLocationQuery, *params.TeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueListId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueListId", runtime.ParamLocationQuery, *params.LeagueListId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerPool != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerPool", runtime.ParamLocationQuery, *params.PlayerPool); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statType", runtime.ParamLocationQuery, *params.StatType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerActive", runtime.ParamLocationQuery, *params.PlayerActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Position != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "position", runtime.ParamLocationQuery, *params.Position); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SitCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sitCodes", runtime.ParamLocationQuery, *params.SitCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpposingTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opposingTeamId", runtime.ParamLocationQuery, *params.OpposingTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DaysBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "daysBack", runtime.ParamLocationQuery, *params.DaysBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GamesBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamesBack", runtime.ParamLocationQuery, *params.GamesBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupBy", runtime.ParamLocationQuery, *params.GroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetricStatsRequest generates requests for MetricStats
func NewMetricStatsRequest(server string, params *MetricStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stats/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personId", runtime.ParamLocationQuery, *params.PersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personIds", runtime.ParamLocationQuery, *params.PersonIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batterId", runtime.ParamLocationQuery, *params.BatterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitcherId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitcherId", runtime.ParamLocationQuery, *params.PitcherId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stats", runtime.ParamLocationQuery, params.Stats); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpposingTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opposingTeamId", runtime.ParamLocationQuery, *params.OpposingTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpposingPlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opposingPlayerId", runtime.ParamLocationQuery, *params.OpposingPlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Position != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "position", runtime.ParamLocationQuery, *params.Position); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventType", runtime.ParamLocationQuery, *params.EventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitchType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitchType", runtime.ParamLocationQuery, *params.PitchType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HitTrajectory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hitTrajectory", runtime.ParamLocationQuery, *params.HitTrajectory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatSide != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batSide", runtime.ParamLocationQuery, *params.BatSide); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitchHand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitchHand", runtime.ParamLocationQuery, *params.PitchHand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VenueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "venueId", runtime.ParamLocationQuery, *params.VenueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metrics", runtime.ParamLocationQuery, params.Metrics); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.GamePk != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePk", runtime.ParamLocationQuery, *params.GamePk); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinValue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minValue", runtime.ParamLocationQuery, *params.MinValue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxValue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxValue", runtime.ParamLocationQuery, *params.MaxValue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Percentile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentile", runtime.ParamLocationQuery, *params.Percentile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinOccurrences != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minOccurrences", runtime.ParamLocationQuery, *params.MinOccurrences); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatterTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batterTeamId", runtime.ParamLocationQuery, *params.BatterTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitcherTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitcherTeamId", runtime.ParamLocationQuery, *params.PitcherTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Debug != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "debug", runtime.ParamLocationQuery, *params.Debug); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBeastStatsRequest generates requests for BeastStats
func NewBeastStatsRequest(server string, params *BeastStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stats/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.GamePks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePks", runtime.ParamLocationQuery, *params.GamePks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playIds", runtime.ParamLocationQuery, *params.PlayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameTypes", runtime.ParamLocationQuery, *params.GameTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamIds", runtime.ParamLocationQuery, *params.TeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitcherTeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitcherTeamIds", runtime.ParamLocationQuery, *params.PitcherTeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatterTeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batterTeamIds", runtime.ParamLocationQuery, *params.BatterTeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportIds", runtime.ParamLocationQuery, *params.SportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitcherSportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitcherSportIds", runtime.ParamLocationQuery, *params.PitcherSportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatterSportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batterSportIds", runtime.ParamLocationQuery, *params.BatterSportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitcherLeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitcherLeagueIds", runtime.ParamLocationQuery, *params.PitcherLeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatterLeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batterLeagueIds", runtime.ParamLocationQuery, *params.BatterLeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DivisionIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "divisionIds", runtime.ParamLocationQuery, *params.DivisionIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitcherDivisionIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitcherDivisionIds", runtime.ParamLocationQuery, *params.PitcherDivisionIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatterDivisionIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batterDivisionIds", runtime.ParamLocationQuery, *params.BatterDivisionIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitchersOnTeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitchersOnTeamIds", runtime.ParamLocationQuery, *params.PitchersOnTeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BattersOnTeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "battersOnTeamIds", runtime.ParamLocationQuery, *params.BattersOnTeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerIds", runtime.ParamLocationQuery, *params.PlayerIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerPool != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerPool", runtime.ParamLocationQuery, *params.PlayerPool); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitcherIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitcherIds", runtime.ParamLocationQuery, *params.PitcherIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatterIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batterIds", runtime.ParamLocationQuery, *params.BatterIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CatcherIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "catcherIds", runtime.ParamLocationQuery, *params.CatcherIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstBasemanIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firstBasemanIds", runtime.ParamLocationQuery, *params.FirstBasemanIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecondBasemanIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secondBasemanIds", runtime.ParamLocationQuery, *params.SecondBasemanIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ThirdBasemanIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "thirdBasemanIds", runtime.ParamLocationQuery, *params.ThirdBasemanIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShortstopIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shortstopIds", runtime.ParamLocationQuery, *params.ShortstopIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeftFielderIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leftFielderIds", runtime.ParamLocationQuery, *params.LeftFielderIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CenterFielderIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "centerFielderIds", runtime.ParamLocationQuery, *params.CenterFielderIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RightFielderIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rightFielderIds", runtime.ParamLocationQuery, *params.RightFielderIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RunnerFirstIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnerFirstIds", runtime.ParamLocationQuery, *params.RunnerFirstIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RunnerSecondIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnerSecondIds", runtime.ParamLocationQuery, *params.RunnerSecondIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RunnerThirdIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnerThirdIds", runtime.ParamLocationQuery, *params.RunnerThirdIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VenueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "venueIds", runtime.ParamLocationQuery, *params.VenueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitchHand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitchHand", runtime.ParamLocationQuery, *params.PitchHand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatSide != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batSide", runtime.ParamLocationQuery, *params.BatSide); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitchTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitchTypes", runtime.ParamLocationQuery, *params.PitchTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitchCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitchCodes", runtime.ParamLocationQuery, *params.PitchCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventTypes", runtime.ParamLocationQuery, *params.EventTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Positions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "positions", runtime.ParamLocationQuery, *params.Positions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryPositions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primaryPositions", runtime.ParamLocationQuery, *params.PrimaryPositions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinPitchSpeed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minPitchSpeed", runtime.ParamLocationQuery, *params.MinPitchSpeed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxPitchSpeed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxPitchSpeed", runtime.ParamLocationQuery, *params.MaxPitchSpeed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSpinRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSpinRate", runtime.ParamLocationQuery, *params.MinSpinRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxSpinRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxSpinRate", runtime.ParamLocationQuery, *params.MaxSpinRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinExtension != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minExtension", runtime.ParamLocationQuery, *params.MinExtension); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxExtension != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxExtension", runtime.ParamLocationQuery, *params.MaxExtension); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinExitVelocityAgainst != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minExitVelocityAgainst", runtime.ParamLocationQuery, *params.MinExitVelocityAgainst); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxExitVelocityAgainst != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxExitVelocityAgainst", runtime.ParamLocationQuery, *params.MaxExitVelocityAgainst); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinLaunchAngleAgainst != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minLaunchAngleAgainst", runtime.ParamLocationQuery, *params.MinLaunchAngleAgainst); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxLaunchAngleAgainst != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxLaunchAngleAgainst", runtime.ParamLocationQuery, *params.MaxLaunchAngleAgainst); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinExitVelocity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minExitVelocity", runtime.ParamLocationQuery, *params.MinExitVelocity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxExitVelocity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxExitVelocity", runtime.ParamLocationQuery, *params.MaxExitVelocity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinLaunchAngle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minLaunchAngle", runtime.ParamLocationQuery, *params.MinLaunchAngle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxLaunchAngle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxLaunchAngle", runtime.ParamLocationQuery, *params.MaxLaunchAngle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinHomeRunDistance != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minHomeRunDistance", runtime.ParamLocationQuery, *params.MinHomeRunDistance); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHomeRunDistance != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHomeRunDistance", runtime.ParamLocationQuery, *params.MaxHomeRunDistance); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinHitDistance != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minHitDistance", runtime.ParamLocationQuery, *params.MinHitDistance); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHitDistance != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHitDistance", runtime.ParamLocationQuery, *params.MaxHitDistance); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinHangTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minHangTime", runtime.ParamLocationQuery, *params.MinHangTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHangTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHangTime", runtime.ParamLocationQuery, *params.MaxHangTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinHitProbability != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minHitProbability", runtime.ParamLocationQuery, *params.MinHitProbability); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHitProbability != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHitProbability", runtime.ParamLocationQuery, *params.MaxHitProbability); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCatchProbability != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCatchProbability", runtime.ParamLocationQuery, *params.MinCatchProbability); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxCatchProbability != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxCatchProbability", runtime.ParamLocationQuery, *params.MaxCatchProbability); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinAttackAngle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minAttackAngle", runtime.ParamLocationQuery, *params.MinAttackAngle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAttackAngle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAttackAngle", runtime.ParamLocationQuery, *params.MaxAttackAngle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinBatSpeed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minBatSpeed", runtime.ParamLocationQuery, *params.MinBatSpeed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxBatSpeed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxBatSpeed", runtime.ParamLocationQuery, *params.MaxBatSpeed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinHomeRunXBallparks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minHomeRunXBallparks", runtime.ParamLocationQuery, *params.MinHomeRunXBallparks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHomeRunXBallparks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHomeRunXBallparks", runtime.ParamLocationQuery, *params.MaxHomeRunXBallparks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsBarrel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isBarrel", runtime.ParamLocationQuery, *params.IsBarrel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HitTrajectories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hitTrajectories", runtime.ParamLocationQuery, *params.HitTrajectories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupBy", runtime.ParamLocationQuery, *params.GroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompareOver != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "compareOver", runtime.ParamLocationQuery, *params.CompareOver); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortStat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortStat", runtime.ParamLocationQuery, *params.SortStat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortModifier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortModifier", runtime.ParamLocationQuery, *params.SortModifier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Percentile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentile", runtime.ParamLocationQuery, *params.Percentile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinOccurrences != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minOccurrences", runtime.ParamLocationQuery, *params.MinOccurrences); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinPlateAppearances != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minPlateAppearances", runtime.ParamLocationQuery, *params.MinPlateAppearances); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinInnings != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minInnings", runtime.ParamLocationQuery, *params.MinInnings); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QualifierRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "qualifierRate", runtime.ParamLocationQuery, *params.QualifierRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SitCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sitCodes", runtime.ParamLocationQuery, *params.SitCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowTotals != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "showTotals", runtime.ParamLocationQuery, *params.ShowTotals); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeNullMetrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeNullMetrics", runtime.ParamLocationQuery, *params.IncludeNullMetrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statFields", runtime.ParamLocationQuery, *params.StatFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AtBatNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "atBatNumbers", runtime.ParamLocationQuery, *params.AtBatNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PitchNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pitchNumbers", runtime.ParamLocationQuery, *params.PitchNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Debug != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "debug", runtime.ParamLocationQuery, *params.Debug); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActiveStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activeStatus", runtime.ParamLocationQuery, *params.ActiveStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatSearchConfigRequest generates requests for StatSearchConfig
func NewStatSearchConfigRequest(server string, params *StatSearchConfigParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stats/search/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterLevel", runtime.ParamLocationQuery, *params.FilterLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatSearchGroupByTypesRequest generates requests for StatSearchGroupByTypes
func NewStatSearchGroupByTypesRequest(server string, params *StatSearchGroupByTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stats/search/groupByTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterLevel", runtime.ParamLocationQuery, *params.FilterLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatSearchParamsRequest generates requests for StatSearchParams
func NewStatSearchParamsRequest(server string, params *StatSearchParamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stats/search/params")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterLevel", runtime.ParamLocationQuery, *params.FilterLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatSearchStatsRequest generates requests for StatSearchStats
func NewStatSearchStatsRequest(server string, params *StatSearchStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stats/search/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterLevel", runtime.ParamLocationQuery, *params.FilterLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreaksRequest generates requests for GetStreaks
func NewGetStreaksRequest(server string, params *GetStreaksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/streaks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StreakOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streakOrg", runtime.ParamLocationQuery, *params.StreakOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreakStat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streakStat", runtime.ParamLocationQuery, *params.StreakStat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreakSpan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streakSpan", runtime.ParamLocationQuery, *params.StreakSpan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreakLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streakLevel", runtime.ParamLocationQuery, *params.StreakLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreakThreshold != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streakThreshold", runtime.ParamLocationQuery, *params.StreakThreshold); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Inverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inverse", runtime.ParamLocationQuery, *params.Inverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartersOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startersOnly", runtime.ParamLocationQuery, *params.StartersOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statGroup", runtime.ParamLocationQuery, *params.StatGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActiveStreak != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activeStreak", runtime.ParamLocationQuery, *params.ActiveStreak); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerId", runtime.ParamLocationQuery, *params.PlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreakTypesRequest generates requests for StreakTypes
func NewStreakTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/streaks/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsRequest generates requests for Teams
func NewTeamsRequest(server string, params *TeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DivisionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "divisionId", runtime.ParamLocationQuery, *params.DivisionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportIds", runtime.ParamLocationQuery, *params.SportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActiveStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activeStatus", runtime.ParamLocationQuery, *params.ActiveStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueListId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueListId", runtime.ParamLocationQuery, *params.LeagueListId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllStarStatuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allStarStatuses", runtime.ParamLocationQuery, *params.AllStarStatuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAffiliates1Request generates requests for Affiliates1
func NewAffiliates1Request(server string, params *Affiliates1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/affiliates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamIds", runtime.ParamLocationQuery, *params.TeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllTeams1Request generates requests for AllTeams1
func NewAllTeams1Request(server string, params *AllTeams1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamIds", runtime.ParamLocationQuery, *params.TeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartSeason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startSeason", runtime.ParamLocationQuery, *params.StartSeason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndSeason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endSeason", runtime.ParamLocationQuery, *params.EndSeason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStats1Request generates requests for Stats1
func NewStats1Request(server string, params *Stats1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stats != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stats", runtime.ParamLocationQuery, *params.Stats); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportIds", runtime.ParamLocationQuery, *params.SportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SortStat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortStat", runtime.ParamLocationQuery, *params.SortStat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DaysBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "daysBack", runtime.ParamLocationQuery, *params.DaysBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SitCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sitCodes", runtime.ParamLocationQuery, *params.SitCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CombineSits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "combineSits", runtime.ParamLocationQuery, *params.CombineSits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpposingTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opposingTeamId", runtime.ParamLocationQuery, *params.OpposingTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaders1Request generates requests for Leaders1
func NewLeaders1Request(server string, params *Leaders1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/stats/leaders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeaderCategories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leaderCategories", runtime.ParamLocationQuery, *params.LeaderCategories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameTypes", runtime.ParamLocationQuery, *params.GameTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stats != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stats", runtime.ParamLocationQuery, *params.Stats); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statType", runtime.ParamLocationQuery, *params.StatType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportIds", runtime.ParamLocationQuery, *params.SportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statGroup", runtime.ParamLocationQuery, *params.StatGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DaysBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "daysBack", runtime.ParamLocationQuery, *params.DaysBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SitCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sitCodes", runtime.ParamLocationQuery, *params.SitCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpposingTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opposingTeamId", runtime.ParamLocationQuery, *params.OpposingTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeams1Request generates requests for Teams1
func NewTeams1Request(server string, teamId int32, params *Teams1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DivisionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "divisionId", runtime.ParamLocationQuery, *params.DivisionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportIds", runtime.ParamLocationQuery, *params.SportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActiveStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activeStatus", runtime.ParamLocationQuery, *params.ActiveStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueListId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueListId", runtime.ParamLocationQuery, *params.LeagueListId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllStarStatuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allStarStatuses", runtime.ParamLocationQuery, *params.AllStarStatuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAffiliatesRequest generates requests for Affiliates
func NewAffiliatesRequest(server string, teamId int32, params *AffiliatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s/affiliates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamIds", runtime.ParamLocationQuery, *params.TeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlumniRequest generates requests for Alumni
func NewAlumniRequest(server string, teamId int32, params *AlumniParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s/alumni", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, params.Season); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAlumniRequest generates requests for UpdateAlumni
func NewUpdateAlumniRequest(server string, teamId int32, params *UpdateAlumniParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s/alumni", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, params.Season); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCoachesRequest generates requests for Coaches
func NewCoachesRequest(server string, teamId int32, params *CoachesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s/coaches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllTeamsRequest generates requests for AllTeams
func NewAllTeamsRequest(server string, teamId int32, params *AllTeamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s/history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamIds", runtime.ParamLocationQuery, *params.TeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartSeason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startSeason", runtime.ParamLocationQuery, *params.StartSeason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndSeason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endSeason", runtime.ParamLocationQuery, *params.EndSeason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeadersRequest generates requests for Leaders
func NewLeadersRequest(server string, teamId int32, params *LeadersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s/leaders", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeaderCategories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leaderCategories", runtime.ParamLocationQuery, *params.LeaderCategories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeaderGameTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leaderGameTypes", runtime.ParamLocationQuery, *params.LeaderGameTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerPool != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerPool", runtime.ParamLocationQuery, *params.PlayerPool); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersonnelRequest generates requests for Personnel
func NewPersonnelRequest(server string, teamId int32, params *PersonnelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s/personnel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRosterRequest generates requests for Roster
func NewRosterRequest(server string, teamId int32, params *RosterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s/roster", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RosterType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rosterType", runtime.ParamLocationQuery, *params.RosterType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRoster1Request generates requests for Roster1
func NewRoster1Request(server string, teamId int32, rosterType string, params *Roster1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "rosterType", runtime.ParamLocationPath, rosterType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s/roster/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatsRequest generates requests for Stats
func NewStatsRequest(server string, teamId int32, params *StatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s/stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stats != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stats", runtime.ParamLocationQuery, *params.Stats); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SortStat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortStat", runtime.ParamLocationQuery, *params.SortStat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupBy", runtime.ParamLocationQuery, *params.GroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpposingTeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opposingTeamId", runtime.ParamLocationQuery, *params.OpposingTeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpposingPlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "opposingPlayerId", runtime.ParamLocationQuery, *params.OpposingPlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SitCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sitCodes", runtime.ParamLocationQuery, *params.SitCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTrackingSoftwareVersionsRequest generates requests for TrackingSoftwareVersions
func NewTrackingSoftwareVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/trackingSoftwareVersions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTrackingSystemOwnersRequest generates requests for TrackingSystemOwners
func NewTrackingSystemOwnersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/trackingSystemOwners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTrackingVendorsRequest generates requests for TrackingVendors
func NewTrackingVendorsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/trackingVendors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTrackingVersionsRequest generates requests for TrackingVersions
func NewTrackingVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/trackingVersions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransactionTypesRequest generates requests for TransactionTypes
func NewTransactionTypesRequest(server string, params *TransactionTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/transactionTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransactionsRequest generates requests for Transactions
func NewTransactionsRequest(server string, params *TransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playerId", runtime.ParamLocationQuery, *params.PlayerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transactionIds", runtime.ParamLocationQuery, *params.TransactionIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transactionTypes", runtime.ParamLocationQuery, *params.TransactionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DivisionIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "divisionIds", runtime.ParamLocationQuery, *params.DivisionIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUniformsByGameRequest generates requests for UniformsByGame
func NewUniformsByGameRequest(server string, params *UniformsByGameParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/uniforms/game")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gamePks", runtime.ParamLocationQuery, params.GamePks); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUniformsByTeamRequest generates requests for UniformsByTeam
func NewUniformsByTeamRequest(server string, params *UniformsByTeamParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/uniforms/team")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamIds", runtime.ParamLocationQuery, params.TeamIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVenuesRequest generates requests for Venues
func NewVenuesRequest(server string, params *VenuesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/venues")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.VenueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "venueIds", runtime.ParamLocationQuery, *params.VenueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameTypes", runtime.ParamLocationQuery, *params.GameTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Active != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeEvents != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeEvents", runtime.ParamLocationQuery, *params.IncludeEvents); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportIds", runtime.ParamLocationQuery, *params.SportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVenues1Request generates requests for Venues1
func NewVenues1Request(server string, venueId int32, params *Venues1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "venueId", runtime.ParamLocationPath, venueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/venues/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.VenueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "venueIds", runtime.ParamLocationQuery, *params.VenueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueId", runtime.ParamLocationQuery, *params.LeagueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeagueIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leagueIds", runtime.ParamLocationQuery, *params.LeagueIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameType", runtime.ParamLocationQuery, *params.GameType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameTypes", runtime.ParamLocationQuery, *params.GameTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Seasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasons", runtime.ParamLocationQuery, *params.Seasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Active != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeEvents != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeEvents", runtime.ParamLocationQuery, *params.IncludeEvents); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportId", runtime.ParamLocationQuery, *params.SportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SportIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sportIds", runtime.ParamLocationQuery, *params.SportIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVideoResolutionTypesRequest generates requests for VideoResolutionTypes
func NewVideoResolutionTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/videoResolutionTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewViolationTypesRequest generates requests for ViolationTypes
func NewViolationTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/violationTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWeatherForecastRequest generates requests for WeatherForecast
func NewWeatherForecastRequest(server string, gamePk int32, roofType RoofType, params *WeatherForecastParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roofType", runtime.ParamLocationPath, roofType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/weather/game/%s/forecast/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWeatherDataBasedOnPlayRequest generates requests for WeatherDataBasedOnPlay
func NewWeatherDataBasedOnPlayRequest(server string, gamePk int32, playId string, params *WeatherDataBasedOnPlayParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gamePk", runtime.ParamLocationPath, gamePk)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "playId", runtime.ParamLocationPath, playId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/weather/game/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWeatherBasicRequest generates requests for WeatherBasic
func NewWeatherBasicRequest(server string, venueId int32, params *WeatherBasicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "venueId", runtime.ParamLocationPath, venueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/weather/venues/%s/basic", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWeatherFullRequest generates requests for WeatherFull
func NewWeatherFullRequest(server string, venueId int32, params *WeatherFullParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "venueId", runtime.ParamLocationPath, venueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/weather/venues/%s/full", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWeatherTrajectoryConfidencesRequest generates requests for WeatherTrajectoryConfidences
func NewWeatherTrajectoryConfidencesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/weatherTrajectoryConfidences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWindDirectionRequest generates requests for WindDirection
func NewWindDirectionRequest(server string, params *WindDirectionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/windDirection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// LiveGameV1WithResponse request
	LiveGameV1WithResponse(ctx context.Context, gamePk int32, params *LiveGameV1Params, reqEditors ...RequestEditorFn) (*LiveGameV1Response, error)

	// LiveGameDiffPatchV1WithResponse request
	LiveGameDiffPatchV1WithResponse(ctx context.Context, gamePk int32, params *LiveGameDiffPatchV1Params, reqEditors ...RequestEditorFn) (*LiveGameDiffPatchV1Response, error)

	// LiveTimestampv11WithResponse request
	LiveTimestampv11WithResponse(ctx context.Context, gamePk int32, reqEditors ...RequestEditorFn) (*LiveTimestampv11Response, error)

	// AchievementStatusesWithResponse request
	AchievementStatusesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AchievementStatusesResponse, error)

	// GameGuidsFromPostgresRangeByGameWithResponse request
	GameGuidsFromPostgresRangeByGameWithResponse(ctx context.Context, params *GameGuidsFromPostgresRangeByGameParams, reqEditors ...RequestEditorFn) (*GameGuidsFromPostgresRangeByGameResponse, error)

	// GameGuidsFromPostgresRangeWithResponse request
	GameGuidsFromPostgresRangeWithResponse(ctx context.Context, params *GameGuidsFromPostgresRangeParams, reqEditors ...RequestEditorFn) (*GameGuidsFromPostgresRangeResponse, error)

	// GetTeamAttendanceWithResponse request
	GetTeamAttendanceWithResponse(ctx context.Context, params *GetTeamAttendanceParams, reqEditors ...RequestEditorFn) (*GetTeamAttendanceResponse, error)

	// AwardsWithResponse request
	AwardsWithResponse(ctx context.Context, params *AwardsParams, reqEditors ...RequestEditorFn) (*AwardsResponse, error)

	// Awards1WithResponse request
	Awards1WithResponse(ctx context.Context, awardId string, params *Awards1Params, reqEditors ...RequestEditorFn) (*Awards1Response, error)

	// AwardRecipientsWithResponse request
	AwardRecipientsWithResponse(ctx context.Context, awardId string, params *AwardRecipientsParams, reqEditors ...RequestEditorFn) (*AwardRecipientsResponse, error)

	// BaseballStatsWithResponse request
	BaseballStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BaseballStatsResponse, error)

	// BatTrackingWithResponse request
	BatTrackingWithResponse(ctx context.Context, gamePk int32, playId string, params *BatTrackingParams, reqEditors ...RequestEditorFn) (*BatTrackingResponse, error)

	// GetBroadcastsWithResponse request
	GetBroadcastsWithResponse(ctx context.Context, params *GetBroadcastsParams, reqEditors ...RequestEditorFn) (*GetBroadcastsResponse, error)

	// BroadcastAvailabilityTypesWithResponse request
	BroadcastAvailabilityTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BroadcastAvailabilityTypesResponse, error)

	// GetAllBroadcastersWithResponse request
	GetAllBroadcastersWithResponse(ctx context.Context, params *GetAllBroadcastersParams, reqEditors ...RequestEditorFn) (*GetAllBroadcastersResponse, error)

	// CoachingVideoTypesWithResponse request
	CoachingVideoTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CoachingVideoTypesResponse, error)

	// ConferencesWithResponse request
	ConferencesWithResponse(ctx context.Context, params *ConferencesParams, reqEditors ...RequestEditorFn) (*ConferencesResponse, error)

	// Conferences1WithResponse request
	Conferences1WithResponse(ctx context.Context, conferenceId int32, params *Conferences1Params, reqEditors ...RequestEditorFn) (*Conferences1Response, error)

	// DivisionsWithResponse request
	DivisionsWithResponse(ctx context.Context, params *DivisionsParams, reqEditors ...RequestEditorFn) (*DivisionsResponse, error)

	// Divisions1WithResponse request
	Divisions1WithResponse(ctx context.Context, divisionId int32, params *Divisions1Params, reqEditors ...RequestEditorFn) (*Divisions1Response, error)

	// DraftPicksWithResponse request
	DraftPicksWithResponse(ctx context.Context, params *DraftPicksParams, reqEditors ...RequestEditorFn) (*DraftPicksResponse, error)

	// DraftProspectsWithResponse request
	DraftProspectsWithResponse(ctx context.Context, params *DraftProspectsParams, reqEditors ...RequestEditorFn) (*DraftProspectsResponse, error)

	// DraftProspects1WithResponse request
	DraftProspects1WithResponse(ctx context.Context, year int32, params *DraftProspects1Params, reqEditors ...RequestEditorFn) (*DraftProspects1Response, error)

	// DraftPicks1WithResponse request
	DraftPicks1WithResponse(ctx context.Context, year int32, params *DraftPicks1Params, reqEditors ...RequestEditorFn) (*DraftPicks1Response, error)

	// LatestDraftPicksWithResponse request
	LatestDraftPicksWithResponse(ctx context.Context, year int32, params *LatestDraftPicksParams, reqEditors ...RequestEditorFn) (*LatestDraftPicksResponse, error)

	// EventStatusWithResponse request
	EventStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EventStatusResponse, error)

	// EventTypesWithResponse request
	EventTypesWithResponse(ctx context.Context, params *EventTypesParams, reqEditors ...RequestEditorFn) (*EventTypesResponse, error)

	// FielderDetailTypesWithResponse request
	FielderDetailTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FielderDetailTypesResponse, error)

	// FreeGameTypesWithResponse request
	FreeGameTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FreeGameTypesResponse, error)

	// CurrentGameStats1WithResponse request
	CurrentGameStats1WithResponse(ctx context.Context, params *CurrentGameStats1Params, reqEditors ...RequestEditorFn) (*CurrentGameStats1Response, error)

	// GameLastPitchWithResponse request
	GameLastPitchWithResponse(ctx context.Context, params *GameLastPitchParams, reqEditors ...RequestEditorFn) (*GameLastPitchResponse, error)

	// GetGameContextMetricsWithResponse request
	GetGameContextMetricsWithResponse(ctx context.Context, gamePk int32, params *GetGameContextMetricsParams, reqEditors ...RequestEditorFn) (*GetGameContextMetricsResponse, error)

	// GameGuidsWithResponse request
	GameGuidsWithResponse(ctx context.Context, gamePk int32, params *GameGuidsParams, reqEditors ...RequestEditorFn) (*GameGuidsResponse, error)

	// GetWinProbabilityWithResponse request
	GetWinProbabilityWithResponse(ctx context.Context, gamePk int32, params *GetWinProbabilityParams, reqEditors ...RequestEditorFn) (*GetWinProbabilityResponse, error)

	// GetGameWithMetricsWithResponse request
	GetGameWithMetricsWithResponse(ctx context.Context, gamePk int32, params *GetGameWithMetricsParams, reqEditors ...RequestEditorFn) (*GetGameWithMetricsResponse, error)

	// ParsedJsonFormattedAnalyticsWithResponse request
	ParsedJsonFormattedAnalyticsWithResponse(ctx context.Context, gamePk int32, guid string, params *ParsedJsonFormattedAnalyticsParams, reqEditors ...RequestEditorFn) (*ParsedJsonFormattedAnalyticsResponse, error)

	// ContextMetricsWithResponse request
	ContextMetricsWithResponse(ctx context.Context, gamePk int32, guid string, params *ContextMetricsParams, reqEditors ...RequestEditorFn) (*ContextMetricsResponse, error)

	// ContextMetricsWithAveragesWithResponse request
	ContextMetricsWithAveragesWithResponse(ctx context.Context, gamePk int32, guid string, params *ContextMetricsWithAveragesParams, reqEditors ...RequestEditorFn) (*ContextMetricsWithAveragesResponse, error)

	// ContextMetricsWithAveragesPostWithResponse request
	ContextMetricsWithAveragesPostWithResponse(ctx context.Context, gamePk int32, guid string, params *ContextMetricsWithAveragesPostParams, reqEditors ...RequestEditorFn) (*ContextMetricsWithAveragesPostResponse, error)

	// HomeRunBallparksWithResponse request
	HomeRunBallparksWithResponse(ctx context.Context, gamePk int32, guid string, params *HomeRunBallparksParams, reqEditors ...RequestEditorFn) (*HomeRunBallparksResponse, error)

	// BiomechanicalWithResponse request
	BiomechanicalWithResponse(ctx context.Context, gamePk int32, playId string, positionId int32, params *BiomechanicalParams, reqEditors ...RequestEditorFn) (*BiomechanicalResponse, error)

	// SkeletalChunkedWithResponse request
	SkeletalChunkedWithResponse(ctx context.Context, gamePk int32, playId string, params *SkeletalChunkedParams, reqEditors ...RequestEditorFn) (*SkeletalChunkedResponse, error)

	// SkeletalDataFileNamesWithResponse request
	SkeletalDataFileNamesWithResponse(ctx context.Context, gamePk int32, playId string, params *SkeletalDataFileNamesParams, reqEditors ...RequestEditorFn) (*SkeletalDataFileNamesResponse, error)

	// BoxscoreWithResponse request
	BoxscoreWithResponse(ctx context.Context, gamePk int32, params *BoxscoreParams, reqEditors ...RequestEditorFn) (*BoxscoreResponse, error)

	// ContentWithResponse request
	ContentWithResponse(ctx context.Context, gamePk int32, params *ContentParams, reqEditors ...RequestEditorFn) (*ContentResponse, error)

	// ColorFeedWithResponse request
	ColorFeedWithResponse(ctx context.Context, gamePk int32, params *ColorFeedParams, reqEditors ...RequestEditorFn) (*ColorFeedResponse, error)

	// ColorTimestampsWithResponse request
	ColorTimestampsWithResponse(ctx context.Context, gamePk int32, reqEditors ...RequestEditorFn) (*ColorTimestampsResponse, error)

	// LinescoreWithResponse request
	LinescoreWithResponse(ctx context.Context, gamePk int32, params *LinescoreParams, reqEditors ...RequestEditorFn) (*LinescoreResponse, error)

	// PlayByPlayWithResponse request
	PlayByPlayWithResponse(ctx context.Context, gamePk int32, params *PlayByPlayParams, reqEditors ...RequestEditorFn) (*PlayByPlayResponse, error)

	// GamePaceWithResponse request
	GamePaceWithResponse(ctx context.Context, params *GamePaceParams, reqEditors ...RequestEditorFn) (*GamePaceResponse, error)

	// GameStatusWithResponse request
	GameStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GameStatusResponse, error)

	// UpdateGameStatusesWithResponse request
	UpdateGameStatusesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateGameStatusesResponse, error)

	// GameTypesWithResponse request
	GameTypesWithResponse(ctx context.Context, params *GameTypesParams, reqEditors ...RequestEditorFn) (*GameTypesResponse, error)

	// GamedayTypesWithResponse request
	GamedayTypesWithResponse(ctx context.Context, params *GamedayTypesParams, reqEditors ...RequestEditorFn) (*GamedayTypesResponse, error)

	// GroupByTypesWithResponse request
	GroupByTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GroupByTypesResponse, error)

	// HighLowStatsWithResponse request
	HighLowStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HighLowStatsResponse, error)

	// HighLowWithResponse request
	HighLowWithResponse(ctx context.Context, highLowType HighLowTypeEnum, params *HighLowParams, reqEditors ...RequestEditorFn) (*HighLowResponse, error)

	// HitTrajectoriesWithResponse request
	HitTrajectoriesWithResponse(ctx context.Context, params *HitTrajectoriesParams, reqEditors ...RequestEditorFn) (*HitTrajectoriesResponse, error)

	// HomeRunDerbyBracket1WithResponse request
	HomeRunDerbyBracket1WithResponse(ctx context.Context, params *HomeRunDerbyBracket1Params, reqEditors ...RequestEditorFn) (*HomeRunDerbyBracket1Response, error)

	// HomeRunDerbyBracket3WithResponse request
	HomeRunDerbyBracket3WithResponse(ctx context.Context, params *HomeRunDerbyBracket3Params, reqEditors ...RequestEditorFn) (*HomeRunDerbyBracket3Response, error)

	// HomeRunDerbyMixedMode1WithResponse request
	HomeRunDerbyMixedMode1WithResponse(ctx context.Context, params *HomeRunDerbyMixedMode1Params, reqEditors ...RequestEditorFn) (*HomeRunDerbyMixedMode1Response, error)

	// HomeRunDerbyPool1WithResponse request
	HomeRunDerbyPool1WithResponse(ctx context.Context, params *HomeRunDerbyPool1Params, reqEditors ...RequestEditorFn) (*HomeRunDerbyPool1Response, error)

	// HomeRunDerbyBracketWithResponse request
	HomeRunDerbyBracketWithResponse(ctx context.Context, gamePk int32, params *HomeRunDerbyBracketParams, reqEditors ...RequestEditorFn) (*HomeRunDerbyBracketResponse, error)

	// HomeRunDerbyBracket2WithResponse request
	HomeRunDerbyBracket2WithResponse(ctx context.Context, gamePk int32, params *HomeRunDerbyBracket2Params, reqEditors ...RequestEditorFn) (*HomeRunDerbyBracket2Response, error)

	// HomeRunDerbyMixedModeWithResponse request
	HomeRunDerbyMixedModeWithResponse(ctx context.Context, gamePk int32, params *HomeRunDerbyMixedModeParams, reqEditors ...RequestEditorFn) (*HomeRunDerbyMixedModeResponse, error)

	// HomeRunDerbyPoolWithResponse request
	HomeRunDerbyPoolWithResponse(ctx context.Context, gamePk int32, params *HomeRunDerbyPoolParams, reqEditors ...RequestEditorFn) (*HomeRunDerbyPoolResponse, error)

	// JobTypesWithResponse request
	JobTypesWithResponse(ctx context.Context, params *JobTypesParams, reqEditors ...RequestEditorFn) (*JobTypesResponse, error)

	// UpdateJobTypesWithResponse request
	UpdateJobTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateJobTypesResponse, error)

	// GetJobsByTypeWithResponse request
	GetJobsByTypeWithResponse(ctx context.Context, params *GetJobsByTypeParams, reqEditors ...RequestEditorFn) (*GetJobsByTypeResponse, error)

	// DatacastersWithResponse request
	DatacastersWithResponse(ctx context.Context, params *DatacastersParams, reqEditors ...RequestEditorFn) (*DatacastersResponse, error)

	// OfficialScorersWithResponse request
	OfficialScorersWithResponse(ctx context.Context, params *OfficialScorersParams, reqEditors ...RequestEditorFn) (*OfficialScorersResponse, error)

	// UmpiresWithResponse request
	UmpiresWithResponse(ctx context.Context, params *UmpiresParams, reqEditors ...RequestEditorFn) (*UmpiresResponse, error)

	// UmpireScheduleWithResponse request
	UmpireScheduleWithResponse(ctx context.Context, umpireId int32, params *UmpireScheduleParams, reqEditors ...RequestEditorFn) (*UmpireScheduleResponse, error)

	// LanguagesWithResponse request
	LanguagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LanguagesResponse, error)

	// LeagueWithResponse request
	LeagueWithResponse(ctx context.Context, params *LeagueParams, reqEditors ...RequestEditorFn) (*LeagueResponse, error)

	// AllStarBallotWithResponse request
	AllStarBallotWithResponse(ctx context.Context, params *AllStarBallotParams, reqEditors ...RequestEditorFn) (*AllStarBallotResponse, error)

	// League1WithResponse request
	League1WithResponse(ctx context.Context, leagueId int32, params *League1Params, reqEditors ...RequestEditorFn) (*League1Response, error)

	// AllStarBallot1WithResponse request
	AllStarBallot1WithResponse(ctx context.Context, leagueId int32, params *AllStarBallot1Params, reqEditors ...RequestEditorFn) (*AllStarBallot1Response, error)

	// AllStarFinalVoteWithResponse request
	AllStarFinalVoteWithResponse(ctx context.Context, leagueId int32, params *AllStarFinalVoteParams, reqEditors ...RequestEditorFn) (*AllStarFinalVoteResponse, error)

	// AllStarWriteInsWithResponse request
	AllStarWriteInsWithResponse(ctx context.Context, leagueId int32, params *AllStarWriteInsParams, reqEditors ...RequestEditorFn) (*AllStarWriteInsResponse, error)

	// LeagueLeaderTypesWithResponse request
	LeagueLeaderTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LeagueLeaderTypesResponse, error)

	// League2WithResponse request
	League2WithResponse(ctx context.Context, params *League2Params, reqEditors ...RequestEditorFn) (*League2Response, error)

	// AllStarBallot2WithResponse request
	AllStarBallot2WithResponse(ctx context.Context, params *AllStarBallot2Params, reqEditors ...RequestEditorFn) (*AllStarBallot2Response, error)

	// League3WithResponse request
	League3WithResponse(ctx context.Context, leagueId int32, params *League3Params, reqEditors ...RequestEditorFn) (*League3Response, error)

	// AllStarBallot3WithResponse request
	AllStarBallot3WithResponse(ctx context.Context, leagueId int32, params *AllStarBallot3Params, reqEditors ...RequestEditorFn) (*AllStarBallot3Response, error)

	// AllStarFinalVote1WithResponse request
	AllStarFinalVote1WithResponse(ctx context.Context, leagueId int32, params *AllStarFinalVote1Params, reqEditors ...RequestEditorFn) (*AllStarFinalVote1Response, error)

	// AllStarWriteIns1WithResponse request
	AllStarWriteIns1WithResponse(ctx context.Context, leagueId int32, params *AllStarWriteIns1Params, reqEditors ...RequestEditorFn) (*AllStarWriteIns1Response, error)

	// LogicalEventsWithResponse request
	LogicalEventsWithResponse(ctx context.Context, params *LogicalEventsParams, reqEditors ...RequestEditorFn) (*LogicalEventsResponse, error)

	// GetLookupValuesWithResponse request
	GetLookupValuesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLookupValuesResponse, error)

	// MediaStateTypesWithResponse request
	MediaStateTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MediaStateTypesResponse, error)

	// MetricsWithResponse request
	MetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetricsResponse, error)

	// MilestoneDurationsWithResponse request
	MilestoneDurationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MilestoneDurationsResponse, error)

	// MilestoneLookupsWithResponse request
	MilestoneLookupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MilestoneLookupsResponse, error)

	// MilestoneStatisticsWithResponse request
	MilestoneStatisticsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MilestoneStatisticsResponse, error)

	// MilestoneTypesWithResponse request
	MilestoneTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MilestoneTypesResponse, error)

	// MilestonesWithResponse request
	MilestonesWithResponse(ctx context.Context, params *MilestonesParams, reqEditors ...RequestEditorFn) (*MilestonesResponse, error)

	// MoundVisitTypesWithResponse request
	MoundVisitTypesWithResponse(ctx context.Context, params *MoundVisitTypesParams, reqEditors ...RequestEditorFn) (*MoundVisitTypesResponse, error)

	// Person1WithResponse request
	Person1WithResponse(ctx context.Context, params *Person1Params, reqEditors ...RequestEditorFn) (*Person1Response, error)

	// CurrentGameStatsWithResponse request
	CurrentGameStatsWithResponse(ctx context.Context, params *CurrentGameStatsParams, reqEditors ...RequestEditorFn) (*CurrentGameStatsResponse, error)

	// FreeAgentsWithResponse request
	FreeAgentsWithResponse(ctx context.Context, params *FreeAgentsParams, reqEditors ...RequestEditorFn) (*FreeAgentsResponse, error)

	// SearchWithResponse request
	SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error)

	// PersonWithResponse request
	PersonWithResponse(ctx context.Context, personId int32, params *PersonParams, reqEditors ...RequestEditorFn) (*PersonResponse, error)

	// AwardWithResponse request
	AwardWithResponse(ctx context.Context, personId int32, params *AwardParams, reqEditors ...RequestEditorFn) (*AwardResponse, error)

	// Stats3WithResponse request
	Stats3WithResponse(ctx context.Context, personId int32, params *Stats3Params, reqEditors ...RequestEditorFn) (*Stats3Response, error)

	// PlayerGameStatsWithResponse request
	PlayerGameStatsWithResponse(ctx context.Context, personId int32, gamePk int32, params *PlayerGameStatsParams, reqEditors ...RequestEditorFn) (*PlayerGameStatsResponse, error)

	// StatsMetricsWithResponse request
	StatsMetricsWithResponse(ctx context.Context, personId int32, params *StatsMetricsParams, reqEditors ...RequestEditorFn) (*StatsMetricsResponse, error)

	// PerformerTypesWithResponse request
	PerformerTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PerformerTypesResponse, error)

	// PitchCodesWithResponse request
	PitchCodesWithResponse(ctx context.Context, params *PitchCodesParams, reqEditors ...RequestEditorFn) (*PitchCodesResponse, error)

	// PitchTypesWithResponse request
	PitchTypesWithResponse(ctx context.Context, params *PitchTypesParams, reqEditors ...RequestEditorFn) (*PitchTypesResponse, error)

	// PlatformsWithResponse request
	PlatformsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PlatformsResponse, error)

	// PlayerStatusCodesWithResponse request
	PlayerStatusCodesWithResponse(ctx context.Context, params *PlayerStatusCodesParams, reqEditors ...RequestEditorFn) (*PlayerStatusCodesResponse, error)

	// PositionsWithResponse request
	PositionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PositionsResponse, error)

	// GetPropsWithResponse request
	GetPropsWithResponse(ctx context.Context, params *GetPropsParams, reqEditors ...RequestEditorFn) (*GetPropsResponse, error)

	// GetPropsAdjustWithResponse request
	GetPropsAdjustWithResponse(ctx context.Context, params *GetPropsAdjustParams, reqEditors ...RequestEditorFn) (*GetPropsAdjustResponse, error)

	// GetReviewInfoWithResponse request
	GetReviewInfoWithResponse(ctx context.Context, params *GetReviewInfoParams, reqEditors ...RequestEditorFn) (*GetReviewInfoResponse, error)

	// ReviewReasonsWithResponse request
	ReviewReasonsWithResponse(ctx context.Context, params *ReviewReasonsParams, reqEditors ...RequestEditorFn) (*ReviewReasonsResponse, error)

	// RoofTypesWithResponse request
	RoofTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RoofTypesResponse, error)

	// RosterTypesWithResponse request
	RosterTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RosterTypesResponse, error)

	// RuleSettingsWithResponse request
	RuleSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RuleSettingsResponse, error)

	// RunnerDetailTypesWithResponse request
	RunnerDetailTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RunnerDetailTypesResponse, error)

	// ScheduleWithResponse request
	ScheduleWithResponse(ctx context.Context, params *ScheduleParams, reqEditors ...RequestEditorFn) (*ScheduleResponse, error)

	// TieGamesWithResponse request
	TieGamesWithResponse(ctx context.Context, params *TieGamesParams, reqEditors ...RequestEditorFn) (*TieGamesResponse, error)

	// PostseasonScheduleWithResponse request
	PostseasonScheduleWithResponse(ctx context.Context, params *PostseasonScheduleParams, reqEditors ...RequestEditorFn) (*PostseasonScheduleResponse, error)

	// PostseasonScheduleSeriesWithResponse request
	PostseasonScheduleSeriesWithResponse(ctx context.Context, params *PostseasonScheduleSeriesParams, reqEditors ...RequestEditorFn) (*PostseasonScheduleSeriesResponse, error)

	// TuneInWithResponse request
	TuneInWithResponse(ctx context.Context, params *TuneInParams, reqEditors ...RequestEditorFn) (*TuneInResponse, error)

	// TrackingEventsScheduleWithResponse request
	TrackingEventsScheduleWithResponse(ctx context.Context, params *TrackingEventsScheduleParams, reqEditors ...RequestEditorFn) (*TrackingEventsScheduleResponse, error)

	// Schedule1WithResponse request
	Schedule1WithResponse(ctx context.Context, scheduleType string, params *Schedule1Params, reqEditors ...RequestEditorFn) (*Schedule1Response, error)

	// ScheduleEventTypesWithResponse request
	ScheduleEventTypesWithResponse(ctx context.Context, params *ScheduleEventTypesParams, reqEditors ...RequestEditorFn) (*ScheduleEventTypesResponse, error)

	// ScheduleTypesWithResponse request
	ScheduleTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScheduleTypesResponse, error)

	// SeasonsWithResponse request
	SeasonsWithResponse(ctx context.Context, params *SeasonsParams, reqEditors ...RequestEditorFn) (*SeasonsResponse, error)

	// AllSeasonsWithResponse request
	AllSeasonsWithResponse(ctx context.Context, params *AllSeasonsParams, reqEditors ...RequestEditorFn) (*AllSeasonsResponse, error)

	// Seasons1WithResponse request
	Seasons1WithResponse(ctx context.Context, seasonId string, params *Seasons1Params, reqEditors ...RequestEditorFn) (*Seasons1Response, error)

	// SitCodesWithResponse request
	SitCodesWithResponse(ctx context.Context, params *SitCodesParams, reqEditors ...RequestEditorFn) (*SitCodesResponse, error)

	// SkyWithResponse request
	SkyWithResponse(ctx context.Context, params *SkyParams, reqEditors ...RequestEditorFn) (*SkyResponse, error)

	// AggregateSortEnumWithResponse request
	AggregateSortEnumWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AggregateSortEnumResponse, error)

	// SportsWithResponse request
	SportsWithResponse(ctx context.Context, params *SportsParams, reqEditors ...RequestEditorFn) (*SportsResponse, error)

	// Sports1WithResponse request
	Sports1WithResponse(ctx context.Context, sportId int32, params *Sports1Params, reqEditors ...RequestEditorFn) (*Sports1Response, error)

	// AllSportBallotWithResponse request
	AllSportBallotWithResponse(ctx context.Context, sportId int32, params *AllSportBallotParams, reqEditors ...RequestEditorFn) (*AllSportBallotResponse, error)

	// SportPlayersWithResponse request
	SportPlayersWithResponse(ctx context.Context, sportId int32, params *SportPlayersParams, reqEditors ...RequestEditorFn) (*SportPlayersResponse, error)

	// Standings1WithResponse request
	Standings1WithResponse(ctx context.Context, params *Standings1Params, reqEditors ...RequestEditorFn) (*Standings1Response, error)

	// StandingsWithResponse request
	StandingsWithResponse(ctx context.Context, standingsType string, params *StandingsParams, reqEditors ...RequestEditorFn) (*StandingsResponse, error)

	// StandingsTypesWithResponse request
	StandingsTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StandingsTypesResponse, error)

	// StatFieldsWithResponse request
	StatFieldsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatFieldsResponse, error)

	// StatGroupsWithResponse request
	StatGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatGroupsResponse, error)

	// StatTypesWithResponse request
	StatTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatTypesResponse, error)

	// StatcastPositionTypesWithResponse request
	StatcastPositionTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatcastPositionTypesResponse, error)

	// Stats2WithResponse request
	Stats2WithResponse(ctx context.Context, params *Stats2Params, reqEditors ...RequestEditorFn) (*Stats2Response, error)

	// GetOutsAboveAverageWithResponse request
	GetOutsAboveAverageWithResponse(ctx context.Context, params *GetOutsAboveAverageParams, reqEditors ...RequestEditorFn) (*GetOutsAboveAverageResponse, error)

	// GetSprayChartWithResponse request
	GetSprayChartWithResponse(ctx context.Context, params *GetSprayChartParams, reqEditors ...RequestEditorFn) (*GetSprayChartResponse, error)

	// GetStolenBaseProbabilityWithResponse request
	GetStolenBaseProbabilityWithResponse(ctx context.Context, params *GetStolenBaseProbabilityParams, reqEditors ...RequestEditorFn) (*GetStolenBaseProbabilityResponse, error)

	// GroupedStatsWithResponse request
	GroupedStatsWithResponse(ctx context.Context, params *GroupedStatsParams, reqEditors ...RequestEditorFn) (*GroupedStatsResponse, error)

	// Leaders2WithResponse request
	Leaders2WithResponse(ctx context.Context, params *Leaders2Params, reqEditors ...RequestEditorFn) (*Leaders2Response, error)

	// MetricStatsWithResponse request
	MetricStatsWithResponse(ctx context.Context, params *MetricStatsParams, reqEditors ...RequestEditorFn) (*MetricStatsResponse, error)

	// BeastStatsWithResponse request
	BeastStatsWithResponse(ctx context.Context, params *BeastStatsParams, reqEditors ...RequestEditorFn) (*BeastStatsResponse, error)

	// StatSearchConfigWithResponse request
	StatSearchConfigWithResponse(ctx context.Context, params *StatSearchConfigParams, reqEditors ...RequestEditorFn) (*StatSearchConfigResponse, error)

	// StatSearchGroupByTypesWithResponse request
	StatSearchGroupByTypesWithResponse(ctx context.Context, params *StatSearchGroupByTypesParams, reqEditors ...RequestEditorFn) (*StatSearchGroupByTypesResponse, error)

	// StatSearchParamsWithResponse request
	StatSearchParamsWithResponse(ctx context.Context, params *StatSearchParamsParams, reqEditors ...RequestEditorFn) (*StatSearchParamsResponse, error)

	// StatSearchStatsWithResponse request
	StatSearchStatsWithResponse(ctx context.Context, params *StatSearchStatsParams, reqEditors ...RequestEditorFn) (*StatSearchStatsResponse, error)

	// GetStreaksWithResponse request
	GetStreaksWithResponse(ctx context.Context, params *GetStreaksParams, reqEditors ...RequestEditorFn) (*GetStreaksResponse, error)

	// StreakTypesWithResponse request
	StreakTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StreakTypesResponse, error)

	// TeamsWithResponse request
	TeamsWithResponse(ctx context.Context, params *TeamsParams, reqEditors ...RequestEditorFn) (*TeamsResponse, error)

	// Affiliates1WithResponse request
	Affiliates1WithResponse(ctx context.Context, params *Affiliates1Params, reqEditors ...RequestEditorFn) (*Affiliates1Response, error)

	// AllTeams1WithResponse request
	AllTeams1WithResponse(ctx context.Context, params *AllTeams1Params, reqEditors ...RequestEditorFn) (*AllTeams1Response, error)

	// Stats1WithResponse request
	Stats1WithResponse(ctx context.Context, params *Stats1Params, reqEditors ...RequestEditorFn) (*Stats1Response, error)

	// Leaders1WithResponse request
	Leaders1WithResponse(ctx context.Context, params *Leaders1Params, reqEditors ...RequestEditorFn) (*Leaders1Response, error)

	// Teams1WithResponse request
	Teams1WithResponse(ctx context.Context, teamId int32, params *Teams1Params, reqEditors ...RequestEditorFn) (*Teams1Response, error)

	// AffiliatesWithResponse request
	AffiliatesWithResponse(ctx context.Context, teamId int32, params *AffiliatesParams, reqEditors ...RequestEditorFn) (*AffiliatesResponse, error)

	// AlumniWithResponse request
	AlumniWithResponse(ctx context.Context, teamId int32, params *AlumniParams, reqEditors ...RequestEditorFn) (*AlumniResponse, error)

	// UpdateAlumniWithResponse request
	UpdateAlumniWithResponse(ctx context.Context, teamId int32, params *UpdateAlumniParams, reqEditors ...RequestEditorFn) (*UpdateAlumniResponse, error)

	// CoachesWithResponse request
	CoachesWithResponse(ctx context.Context, teamId int32, params *CoachesParams, reqEditors ...RequestEditorFn) (*CoachesResponse, error)

	// AllTeamsWithResponse request
	AllTeamsWithResponse(ctx context.Context, teamId int32, params *AllTeamsParams, reqEditors ...RequestEditorFn) (*AllTeamsResponse, error)

	// LeadersWithResponse request
	LeadersWithResponse(ctx context.Context, teamId int32, params *LeadersParams, reqEditors ...RequestEditorFn) (*LeadersResponse, error)

	// PersonnelWithResponse request
	PersonnelWithResponse(ctx context.Context, teamId int32, params *PersonnelParams, reqEditors ...RequestEditorFn) (*PersonnelResponse, error)

	// RosterWithResponse request
	RosterWithResponse(ctx context.Context, teamId int32, params *RosterParams, reqEditors ...RequestEditorFn) (*RosterResponse, error)

	// Roster1WithResponse request
	Roster1WithResponse(ctx context.Context, teamId int32, rosterType string, params *Roster1Params, reqEditors ...RequestEditorFn) (*Roster1Response, error)

	// StatsWithResponse request
	StatsWithResponse(ctx context.Context, teamId int32, params *StatsParams, reqEditors ...RequestEditorFn) (*StatsResponse, error)

	// TrackingSoftwareVersionsWithResponse request
	TrackingSoftwareVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TrackingSoftwareVersionsResponse, error)

	// TrackingSystemOwnersWithResponse request
	TrackingSystemOwnersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TrackingSystemOwnersResponse, error)

	// TrackingVendorsWithResponse request
	TrackingVendorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TrackingVendorsResponse, error)

	// TrackingVersionsWithResponse request
	TrackingVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TrackingVersionsResponse, error)

	// TransactionTypesWithResponse request
	TransactionTypesWithResponse(ctx context.Context, params *TransactionTypesParams, reqEditors ...RequestEditorFn) (*TransactionTypesResponse, error)

	// TransactionsWithResponse request
	TransactionsWithResponse(ctx context.Context, params *TransactionsParams, reqEditors ...RequestEditorFn) (*TransactionsResponse, error)

	// UniformsByGameWithResponse request
	UniformsByGameWithResponse(ctx context.Context, params *UniformsByGameParams, reqEditors ...RequestEditorFn) (*UniformsByGameResponse, error)

	// UniformsByTeamWithResponse request
	UniformsByTeamWithResponse(ctx context.Context, params *UniformsByTeamParams, reqEditors ...RequestEditorFn) (*UniformsByTeamResponse, error)

	// VenuesWithResponse request
	VenuesWithResponse(ctx context.Context, params *VenuesParams, reqEditors ...RequestEditorFn) (*VenuesResponse, error)

	// Venues1WithResponse request
	Venues1WithResponse(ctx context.Context, venueId int32, params *Venues1Params, reqEditors ...RequestEditorFn) (*Venues1Response, error)

	// VideoResolutionTypesWithResponse request
	VideoResolutionTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VideoResolutionTypesResponse, error)

	// ViolationTypesWithResponse request
	ViolationTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ViolationTypesResponse, error)

	// WeatherForecastWithResponse request
	WeatherForecastWithResponse(ctx context.Context, gamePk int32, roofType RoofType, params *WeatherForecastParams, reqEditors ...RequestEditorFn) (*WeatherForecastResponse, error)

	// WeatherDataBasedOnPlayWithResponse request
	WeatherDataBasedOnPlayWithResponse(ctx context.Context, gamePk int32, playId string, params *WeatherDataBasedOnPlayParams, reqEditors ...RequestEditorFn) (*WeatherDataBasedOnPlayResponse, error)

	// WeatherBasicWithResponse request
	WeatherBasicWithResponse(ctx context.Context, venueId int32, params *WeatherBasicParams, reqEditors ...RequestEditorFn) (*WeatherBasicResponse, error)

	// WeatherFullWithResponse request
	WeatherFullWithResponse(ctx context.Context, venueId int32, params *WeatherFullParams, reqEditors ...RequestEditorFn) (*WeatherFullResponse, error)

	// WeatherTrajectoryConfidencesWithResponse request
	WeatherTrajectoryConfidencesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WeatherTrajectoryConfidencesResponse, error)

	// WindDirectionWithResponse request
	WindDirectionWithResponse(ctx context.Context, params *WindDirectionParams, reqEditors ...RequestEditorFn) (*WindDirectionResponse, error)
}

type LiveGameV1Response struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *BaseballGameRestObject
}

// Status returns HTTPResponse.Status
func (r LiveGameV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LiveGameV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LiveGameDiffPatchV1Response struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *string
}

// Status returns HTTPResponse.Status
func (r LiveGameDiffPatchV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LiveGameDiffPatchV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LiveTimestampv11Response struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *string
}

// Status returns HTTPResponse.Status
func (r LiveTimestampv11Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LiveTimestampv11Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AchievementStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AchievementStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AchievementStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GameGuidsFromPostgresRangeByGameResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *AnalyticsGameMetadataWrapperRestObject
}

// Status returns HTTPResponse.Status
func (r GameGuidsFromPostgresRangeByGameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GameGuidsFromPostgresRangeByGameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GameGuidsFromPostgresRangeResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *AnalyticsPlayMetadataWrapperRestObject
}

// Status returns HTTPResponse.Status
func (r GameGuidsFromPostgresRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GameGuidsFromPostgresRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamAttendanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTeamAttendanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamAttendanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AwardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AwardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AwardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Awards1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Awards1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Awards1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AwardRecipientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AwardRecipientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AwardRecipientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BaseballStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BaseballStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BaseballStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BatTrackingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatTrackingRestObject
}

// Status returns HTTPResponse.Status
func (r BatTrackingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BatTrackingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBroadcastsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBroadcastsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBroadcastsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BroadcastAvailabilityTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BroadcastAvailabilityTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BroadcastAvailabilityTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllBroadcastersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAllBroadcastersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBroadcastersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CoachingVideoTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CoachingVideoTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CoachingVideoTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConferencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ConferencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConferencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Conferences1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Conferences1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Conferences1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DivisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DivisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DivisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Divisions1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Divisions1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Divisions1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DraftPicksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DraftPicksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DraftPicksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DraftProspectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DraftProspectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DraftProspectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DraftProspects1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DraftProspects1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DraftProspects1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DraftPicks1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DraftPicks1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DraftPicks1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LatestDraftPicksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LatestDraftPicksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LatestDraftPicksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EventStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventTypesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *string
}

// Status returns HTTPResponse.Status
func (r EventTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FielderDetailTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FielderDetailTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FielderDetailTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FreeGameTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FreeGameTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FreeGameTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CurrentGameStats1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CurrentGameStats1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CurrentGameStats1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GameLastPitchResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *[]AnalyticsPlayMetadataRestObject
}

// Status returns HTTPResponse.Status
func (r GameLastPitchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GameLastPitchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGameContextMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetGameContextMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGameContextMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GameGuidsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *[]AnalyticsPlayMetadataRestObject
}

// Status returns HTTPResponse.Status
func (r GameGuidsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GameGuidsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWinProbabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetWinProbabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWinProbabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGameWithMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetGameWithMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGameWithMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ParsedJsonFormattedAnalyticsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *AnalyticsRestObject
}

// Status returns HTTPResponse.Status
func (r ParsedJsonFormattedAnalyticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ParsedJsonFormattedAnalyticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContextMetricsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *[]CalculatedMetricRestObject
}

// Status returns HTTPResponse.Status
func (r ContextMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContextMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContextMetricsWithAveragesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *[]CalculatedMetricRestObject
}

// Status returns HTTPResponse.Status
func (r ContextMetricsWithAveragesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContextMetricsWithAveragesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContextMetricsWithAveragesPostResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *[]CalculatedMetricRestObject
}

// Status returns HTTPResponse.Status
func (r ContextMetricsWithAveragesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContextMetricsWithAveragesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HomeRunBallparksResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *VenuesRestObject
}

// Status returns HTTPResponse.Status
func (r HomeRunBallparksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HomeRunBallparksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BiomechanicalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SkeletalDataWrapperRestObject
}

// Status returns HTTPResponse.Status
func (r BiomechanicalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BiomechanicalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SkeletalChunkedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r SkeletalChunkedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SkeletalChunkedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SkeletalDataFileNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SkeletalFileData
}

// Status returns HTTPResponse.Status
func (r SkeletalDataFileNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SkeletalDataFileNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BoxscoreResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *BaseballBoxscoreRestObject
}

// Status returns HTTPResponse.Status
func (r BoxscoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BoxscoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContentResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *GameContentRestObject
}

// Status returns HTTPResponse.Status
func (r ContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ColorFeedResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *string
}

// Status returns HTTPResponse.Status
func (r ColorFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ColorFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ColorTimestampsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *[]string
}

// Status returns HTTPResponse.Status
func (r ColorTimestampsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ColorTimestampsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinescoreResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *BaseballLinescoreRestObject
}

// Status returns HTTPResponse.Status
func (r LinescoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinescoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlayByPlayResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *BaseballPlayByPlayRestObject
}

// Status returns HTTPResponse.Status
func (r PlayByPlayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlayByPlayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GamePaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GamePaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GamePaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GameStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GameStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GameStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGameStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateGameStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGameStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GameTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GameTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GameTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GamedayTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GamedayTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GamedayTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupByTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GroupByTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupByTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HighLowStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HighLowStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HighLowStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HighLowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HighLowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HighLowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HitTrajectoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HitTrajectoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HitTrajectoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HomeRunDerbyBracket1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HomeRunDerbyBracket1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HomeRunDerbyBracket1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HomeRunDerbyBracket3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HomeRunDerbyBracket3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HomeRunDerbyBracket3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HomeRunDerbyMixedMode1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HomeRunDerbyMixedMode1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HomeRunDerbyMixedMode1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HomeRunDerbyPool1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HomeRunDerbyPool1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HomeRunDerbyPool1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HomeRunDerbyBracketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HomeRunDerbyBracketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HomeRunDerbyBracketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HomeRunDerbyBracket2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HomeRunDerbyBracket2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HomeRunDerbyBracket2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HomeRunDerbyMixedModeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HomeRunDerbyMixedModeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HomeRunDerbyMixedModeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HomeRunDerbyPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HomeRunDerbyPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HomeRunDerbyPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JobTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r JobTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JobTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateJobTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateJobTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateJobTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobsByTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetJobsByTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobsByTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatacastersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DatacastersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatacastersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OfficialScorersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OfficialScorersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OfficialScorersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UmpiresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UmpiresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UmpiresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UmpireScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UmpireScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UmpireScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LanguagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeagueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LeagueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeagueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllStarBallotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AllStarBallotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllStarBallotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type League1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r League1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r League1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllStarBallot1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AllStarBallot1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllStarBallot1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllStarFinalVoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AllStarFinalVoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllStarFinalVoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllStarWriteInsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AllStarWriteInsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllStarWriteInsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeagueLeaderTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LeagueLeaderTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeagueLeaderTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type League2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r League2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r League2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllStarBallot2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AllStarBallot2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllStarBallot2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type League3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r League3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r League3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllStarBallot3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AllStarBallot3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllStarBallot3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllStarFinalVote1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AllStarFinalVote1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllStarFinalVote1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllStarWriteIns1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AllStarWriteIns1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllStarWriteIns1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogicalEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LogicalEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogicalEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLookupValuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLookupValuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLookupValuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MediaStateTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MediaStateTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MediaStateTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MilestoneDurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MilestoneDurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MilestoneDurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MilestoneLookupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MilestoneLookupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MilestoneLookupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MilestoneStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MilestoneStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MilestoneStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MilestoneTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MilestoneTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MilestoneTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MilestonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MilestonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MilestonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MoundVisitTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MoundVisitTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MoundVisitTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Person1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Person1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Person1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CurrentGameStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CurrentGameStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CurrentGameStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FreeAgentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FreeAgentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FreeAgentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Stats3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Stats3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Stats3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlayerGameStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PlayerGameStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlayerGameStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatsMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatsMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatsMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PerformerTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PerformerTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PerformerTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PitchCodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PitchCodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PitchCodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PitchTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PitchTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PitchTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlatformsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PlatformsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlatformsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlayerStatusCodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PlayerStatusCodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlayerStatusCodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PositionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PositionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PositionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPropsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPropsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPropsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPropsAdjustResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPropsAdjustResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPropsAdjustResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReviewInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetReviewInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReviewInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReviewReasonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReviewReasonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReviewReasonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RoofTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RoofTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RoofTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RosterTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RosterTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosterTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RuleSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RuleSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RuleSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunnerDetailTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunnerDetailTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunnerDetailTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TieGamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TieGamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TieGamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostseasonScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostseasonScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostseasonScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostseasonScheduleSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostseasonScheduleSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostseasonScheduleSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TuneInResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TuneInResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TuneInResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrackingEventsScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TrackingEventsScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrackingEventsScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Schedule1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Schedule1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Schedule1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScheduleEventTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ScheduleEventTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScheduleEventTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScheduleTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ScheduleTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScheduleTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SeasonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SeasonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SeasonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllSeasonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AllSeasonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllSeasonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Seasons1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Seasons1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Seasons1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SitCodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SitCodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SitCodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SkyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SkyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SkyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AggregateSortEnumResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AggregateSortEnumResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AggregateSortEnumResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Sports1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Sports1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Sports1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllSportBallotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AllSportBallotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllSportBallotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SportPlayersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SportPlayersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SportPlayersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Standings1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Standings1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Standings1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StandingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StandingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StandingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StandingsTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StandingsTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StandingsTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatcastPositionTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatcastPositionTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatcastPositionTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Stats2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Stats2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Stats2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutsAboveAverageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOutsAboveAverageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutsAboveAverageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSprayChartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSprayChartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSprayChartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStolenBaseProbabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStolenBaseProbabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStolenBaseProbabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupedStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GroupedStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupedStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Leaders2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Leaders2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Leaders2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MetricStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BeastStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BeastStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BeastStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatSearchConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatSearchConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatSearchConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatSearchGroupByTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatSearchGroupByTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatSearchGroupByTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatSearchParamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatSearchParamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatSearchParamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatSearchStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatSearchStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatSearchStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreaksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStreaksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreaksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreakTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreakTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreakTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Affiliates1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Affiliates1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Affiliates1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllTeams1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AllTeams1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllTeams1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Stats1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Stats1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Stats1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Leaders1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Leaders1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Leaders1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Teams1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Teams1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Teams1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AffiliatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AffiliatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AffiliatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlumniResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AlumniResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlumniResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAlumniResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateAlumniResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAlumniResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CoachesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CoachesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CoachesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AllTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeadersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LeadersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeadersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonnelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersonnelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonnelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RosterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RosterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Roster1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Roster1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Roster1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrackingSoftwareVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TrackingSoftwareVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrackingSoftwareVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrackingSystemOwnersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TrackingSystemOwnersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrackingSystemOwnersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrackingVendorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TrackingVendorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrackingVendorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrackingVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TrackingVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrackingVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransactionTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransactionTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransactionTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UniformsByGameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UniformsByGameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UniformsByGameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UniformsByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UniformsByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UniformsByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VenuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r VenuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VenuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Venues1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Venues1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Venues1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VideoResolutionTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r VideoResolutionTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VideoResolutionTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ViolationTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ViolationTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ViolationTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WeatherForecastResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *ForecastWeatherWrapperRestObject
}

// Status returns HTTPResponse.Status
func (r WeatherForecastResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WeatherForecastResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WeatherDataBasedOnPlayResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *PlayWeatherWrapperRestObject
}

// Status returns HTTPResponse.Status
func (r WeatherDataBasedOnPlayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WeatherDataBasedOnPlayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WeatherBasicResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *BasicWeatherWrapperRestObject
}

// Status returns HTTPResponse.Status
func (r WeatherBasicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WeatherBasicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WeatherFullResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *FullWeatherWrapperRestObject
}

// Status returns HTTPResponse.Status
func (r WeatherFullResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WeatherFullResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WeatherTrajectoryConfidencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WeatherTrajectoryConfidencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WeatherTrajectoryConfidencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WindDirectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WindDirectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WindDirectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// LiveGameV1WithResponse request returning *LiveGameV1Response
func (c *ClientWithResponses) LiveGameV1WithResponse(ctx context.Context, gamePk int32, params *LiveGameV1Params, reqEditors ...RequestEditorFn) (*LiveGameV1Response, error) {
	rsp, err := c.LiveGameV1(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLiveGameV1Response(rsp)
}

// LiveGameDiffPatchV1WithResponse request returning *LiveGameDiffPatchV1Response
func (c *ClientWithResponses) LiveGameDiffPatchV1WithResponse(ctx context.Context, gamePk int32, params *LiveGameDiffPatchV1Params, reqEditors ...RequestEditorFn) (*LiveGameDiffPatchV1Response, error) {
	rsp, err := c.LiveGameDiffPatchV1(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLiveGameDiffPatchV1Response(rsp)
}

// LiveTimestampv11WithResponse request returning *LiveTimestampv11Response
func (c *ClientWithResponses) LiveTimestampv11WithResponse(ctx context.Context, gamePk int32, reqEditors ...RequestEditorFn) (*LiveTimestampv11Response, error) {
	rsp, err := c.LiveTimestampv11(ctx, gamePk, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLiveTimestampv11Response(rsp)
}

// AchievementStatusesWithResponse request returning *AchievementStatusesResponse
func (c *ClientWithResponses) AchievementStatusesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AchievementStatusesResponse, error) {
	rsp, err := c.AchievementStatuses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAchievementStatusesResponse(rsp)
}

// GameGuidsFromPostgresRangeByGameWithResponse request returning *GameGuidsFromPostgresRangeByGameResponse
func (c *ClientWithResponses) GameGuidsFromPostgresRangeByGameWithResponse(ctx context.Context, params *GameGuidsFromPostgresRangeByGameParams, reqEditors ...RequestEditorFn) (*GameGuidsFromPostgresRangeByGameResponse, error) {
	rsp, err := c.GameGuidsFromPostgresRangeByGame(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGameGuidsFromPostgresRangeByGameResponse(rsp)
}

// GameGuidsFromPostgresRangeWithResponse request returning *GameGuidsFromPostgresRangeResponse
func (c *ClientWithResponses) GameGuidsFromPostgresRangeWithResponse(ctx context.Context, params *GameGuidsFromPostgresRangeParams, reqEditors ...RequestEditorFn) (*GameGuidsFromPostgresRangeResponse, error) {
	rsp, err := c.GameGuidsFromPostgresRange(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGameGuidsFromPostgresRangeResponse(rsp)
}

// GetTeamAttendanceWithResponse request returning *GetTeamAttendanceResponse
func (c *ClientWithResponses) GetTeamAttendanceWithResponse(ctx context.Context, params *GetTeamAttendanceParams, reqEditors ...RequestEditorFn) (*GetTeamAttendanceResponse, error) {
	rsp, err := c.GetTeamAttendance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamAttendanceResponse(rsp)
}

// AwardsWithResponse request returning *AwardsResponse
func (c *ClientWithResponses) AwardsWithResponse(ctx context.Context, params *AwardsParams, reqEditors ...RequestEditorFn) (*AwardsResponse, error) {
	rsp, err := c.Awards(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAwardsResponse(rsp)
}

// Awards1WithResponse request returning *Awards1Response
func (c *ClientWithResponses) Awards1WithResponse(ctx context.Context, awardId string, params *Awards1Params, reqEditors ...RequestEditorFn) (*Awards1Response, error) {
	rsp, err := c.Awards1(ctx, awardId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAwards1Response(rsp)
}

// AwardRecipientsWithResponse request returning *AwardRecipientsResponse
func (c *ClientWithResponses) AwardRecipientsWithResponse(ctx context.Context, awardId string, params *AwardRecipientsParams, reqEditors ...RequestEditorFn) (*AwardRecipientsResponse, error) {
	rsp, err := c.AwardRecipients(ctx, awardId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAwardRecipientsResponse(rsp)
}

// BaseballStatsWithResponse request returning *BaseballStatsResponse
func (c *ClientWithResponses) BaseballStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BaseballStatsResponse, error) {
	rsp, err := c.BaseballStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBaseballStatsResponse(rsp)
}

// BatTrackingWithResponse request returning *BatTrackingResponse
func (c *ClientWithResponses) BatTrackingWithResponse(ctx context.Context, gamePk int32, playId string, params *BatTrackingParams, reqEditors ...RequestEditorFn) (*BatTrackingResponse, error) {
	rsp, err := c.BatTracking(ctx, gamePk, playId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBatTrackingResponse(rsp)
}

// GetBroadcastsWithResponse request returning *GetBroadcastsResponse
func (c *ClientWithResponses) GetBroadcastsWithResponse(ctx context.Context, params *GetBroadcastsParams, reqEditors ...RequestEditorFn) (*GetBroadcastsResponse, error) {
	rsp, err := c.GetBroadcasts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBroadcastsResponse(rsp)
}

// BroadcastAvailabilityTypesWithResponse request returning *BroadcastAvailabilityTypesResponse
func (c *ClientWithResponses) BroadcastAvailabilityTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BroadcastAvailabilityTypesResponse, error) {
	rsp, err := c.BroadcastAvailabilityTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBroadcastAvailabilityTypesResponse(rsp)
}

// GetAllBroadcastersWithResponse request returning *GetAllBroadcastersResponse
func (c *ClientWithResponses) GetAllBroadcastersWithResponse(ctx context.Context, params *GetAllBroadcastersParams, reqEditors ...RequestEditorFn) (*GetAllBroadcastersResponse, error) {
	rsp, err := c.GetAllBroadcasters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBroadcastersResponse(rsp)
}

// CoachingVideoTypesWithResponse request returning *CoachingVideoTypesResponse
func (c *ClientWithResponses) CoachingVideoTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CoachingVideoTypesResponse, error) {
	rsp, err := c.CoachingVideoTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCoachingVideoTypesResponse(rsp)
}

// ConferencesWithResponse request returning *ConferencesResponse
func (c *ClientWithResponses) ConferencesWithResponse(ctx context.Context, params *ConferencesParams, reqEditors ...RequestEditorFn) (*ConferencesResponse, error) {
	rsp, err := c.Conferences(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConferencesResponse(rsp)
}

// Conferences1WithResponse request returning *Conferences1Response
func (c *ClientWithResponses) Conferences1WithResponse(ctx context.Context, conferenceId int32, params *Conferences1Params, reqEditors ...RequestEditorFn) (*Conferences1Response, error) {
	rsp, err := c.Conferences1(ctx, conferenceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConferences1Response(rsp)
}

// DivisionsWithResponse request returning *DivisionsResponse
func (c *ClientWithResponses) DivisionsWithResponse(ctx context.Context, params *DivisionsParams, reqEditors ...RequestEditorFn) (*DivisionsResponse, error) {
	rsp, err := c.Divisions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDivisionsResponse(rsp)
}

// Divisions1WithResponse request returning *Divisions1Response
func (c *ClientWithResponses) Divisions1WithResponse(ctx context.Context, divisionId int32, params *Divisions1Params, reqEditors ...RequestEditorFn) (*Divisions1Response, error) {
	rsp, err := c.Divisions1(ctx, divisionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDivisions1Response(rsp)
}

// DraftPicksWithResponse request returning *DraftPicksResponse
func (c *ClientWithResponses) DraftPicksWithResponse(ctx context.Context, params *DraftPicksParams, reqEditors ...RequestEditorFn) (*DraftPicksResponse, error) {
	rsp, err := c.DraftPicks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDraftPicksResponse(rsp)
}

// DraftProspectsWithResponse request returning *DraftProspectsResponse
func (c *ClientWithResponses) DraftProspectsWithResponse(ctx context.Context, params *DraftProspectsParams, reqEditors ...RequestEditorFn) (*DraftProspectsResponse, error) {
	rsp, err := c.DraftProspects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDraftProspectsResponse(rsp)
}

// DraftProspects1WithResponse request returning *DraftProspects1Response
func (c *ClientWithResponses) DraftProspects1WithResponse(ctx context.Context, year int32, params *DraftProspects1Params, reqEditors ...RequestEditorFn) (*DraftProspects1Response, error) {
	rsp, err := c.DraftProspects1(ctx, year, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDraftProspects1Response(rsp)
}

// DraftPicks1WithResponse request returning *DraftPicks1Response
func (c *ClientWithResponses) DraftPicks1WithResponse(ctx context.Context, year int32, params *DraftPicks1Params, reqEditors ...RequestEditorFn) (*DraftPicks1Response, error) {
	rsp, err := c.DraftPicks1(ctx, year, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDraftPicks1Response(rsp)
}

// LatestDraftPicksWithResponse request returning *LatestDraftPicksResponse
func (c *ClientWithResponses) LatestDraftPicksWithResponse(ctx context.Context, year int32, params *LatestDraftPicksParams, reqEditors ...RequestEditorFn) (*LatestDraftPicksResponse, error) {
	rsp, err := c.LatestDraftPicks(ctx, year, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLatestDraftPicksResponse(rsp)
}

// EventStatusWithResponse request returning *EventStatusResponse
func (c *ClientWithResponses) EventStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EventStatusResponse, error) {
	rsp, err := c.EventStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventStatusResponse(rsp)
}

// EventTypesWithResponse request returning *EventTypesResponse
func (c *ClientWithResponses) EventTypesWithResponse(ctx context.Context, params *EventTypesParams, reqEditors ...RequestEditorFn) (*EventTypesResponse, error) {
	rsp, err := c.EventTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventTypesResponse(rsp)
}

// FielderDetailTypesWithResponse request returning *FielderDetailTypesResponse
func (c *ClientWithResponses) FielderDetailTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FielderDetailTypesResponse, error) {
	rsp, err := c.FielderDetailTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFielderDetailTypesResponse(rsp)
}

// FreeGameTypesWithResponse request returning *FreeGameTypesResponse
func (c *ClientWithResponses) FreeGameTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FreeGameTypesResponse, error) {
	rsp, err := c.FreeGameTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFreeGameTypesResponse(rsp)
}

// CurrentGameStats1WithResponse request returning *CurrentGameStats1Response
func (c *ClientWithResponses) CurrentGameStats1WithResponse(ctx context.Context, params *CurrentGameStats1Params, reqEditors ...RequestEditorFn) (*CurrentGameStats1Response, error) {
	rsp, err := c.CurrentGameStats1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrentGameStats1Response(rsp)
}

// GameLastPitchWithResponse request returning *GameLastPitchResponse
func (c *ClientWithResponses) GameLastPitchWithResponse(ctx context.Context, params *GameLastPitchParams, reqEditors ...RequestEditorFn) (*GameLastPitchResponse, error) {
	rsp, err := c.GameLastPitch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGameLastPitchResponse(rsp)
}

// GetGameContextMetricsWithResponse request returning *GetGameContextMetricsResponse
func (c *ClientWithResponses) GetGameContextMetricsWithResponse(ctx context.Context, gamePk int32, params *GetGameContextMetricsParams, reqEditors ...RequestEditorFn) (*GetGameContextMetricsResponse, error) {
	rsp, err := c.GetGameContextMetrics(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGameContextMetricsResponse(rsp)
}

// GameGuidsWithResponse request returning *GameGuidsResponse
func (c *ClientWithResponses) GameGuidsWithResponse(ctx context.Context, gamePk int32, params *GameGuidsParams, reqEditors ...RequestEditorFn) (*GameGuidsResponse, error) {
	rsp, err := c.GameGuids(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGameGuidsResponse(rsp)
}

// GetWinProbabilityWithResponse request returning *GetWinProbabilityResponse
func (c *ClientWithResponses) GetWinProbabilityWithResponse(ctx context.Context, gamePk int32, params *GetWinProbabilityParams, reqEditors ...RequestEditorFn) (*GetWinProbabilityResponse, error) {
	rsp, err := c.GetWinProbability(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWinProbabilityResponse(rsp)
}

// GetGameWithMetricsWithResponse request returning *GetGameWithMetricsResponse
func (c *ClientWithResponses) GetGameWithMetricsWithResponse(ctx context.Context, gamePk int32, params *GetGameWithMetricsParams, reqEditors ...RequestEditorFn) (*GetGameWithMetricsResponse, error) {
	rsp, err := c.GetGameWithMetrics(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGameWithMetricsResponse(rsp)
}

// ParsedJsonFormattedAnalyticsWithResponse request returning *ParsedJsonFormattedAnalyticsResponse
func (c *ClientWithResponses) ParsedJsonFormattedAnalyticsWithResponse(ctx context.Context, gamePk int32, guid string, params *ParsedJsonFormattedAnalyticsParams, reqEditors ...RequestEditorFn) (*ParsedJsonFormattedAnalyticsResponse, error) {
	rsp, err := c.ParsedJsonFormattedAnalytics(ctx, gamePk, guid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseParsedJsonFormattedAnalyticsResponse(rsp)
}

// ContextMetricsWithResponse request returning *ContextMetricsResponse
func (c *ClientWithResponses) ContextMetricsWithResponse(ctx context.Context, gamePk int32, guid string, params *ContextMetricsParams, reqEditors ...RequestEditorFn) (*ContextMetricsResponse, error) {
	rsp, err := c.ContextMetrics(ctx, gamePk, guid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContextMetricsResponse(rsp)
}

// ContextMetricsWithAveragesWithResponse request returning *ContextMetricsWithAveragesResponse
func (c *ClientWithResponses) ContextMetricsWithAveragesWithResponse(ctx context.Context, gamePk int32, guid string, params *ContextMetricsWithAveragesParams, reqEditors ...RequestEditorFn) (*ContextMetricsWithAveragesResponse, error) {
	rsp, err := c.ContextMetricsWithAverages(ctx, gamePk, guid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContextMetricsWithAveragesResponse(rsp)
}

// ContextMetricsWithAveragesPostWithResponse request returning *ContextMetricsWithAveragesPostResponse
func (c *ClientWithResponses) ContextMetricsWithAveragesPostWithResponse(ctx context.Context, gamePk int32, guid string, params *ContextMetricsWithAveragesPostParams, reqEditors ...RequestEditorFn) (*ContextMetricsWithAveragesPostResponse, error) {
	rsp, err := c.ContextMetricsWithAveragesPost(ctx, gamePk, guid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContextMetricsWithAveragesPostResponse(rsp)
}

// HomeRunBallparksWithResponse request returning *HomeRunBallparksResponse
func (c *ClientWithResponses) HomeRunBallparksWithResponse(ctx context.Context, gamePk int32, guid string, params *HomeRunBallparksParams, reqEditors ...RequestEditorFn) (*HomeRunBallparksResponse, error) {
	rsp, err := c.HomeRunBallparks(ctx, gamePk, guid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHomeRunBallparksResponse(rsp)
}

// BiomechanicalWithResponse request returning *BiomechanicalResponse
func (c *ClientWithResponses) BiomechanicalWithResponse(ctx context.Context, gamePk int32, playId string, positionId int32, params *BiomechanicalParams, reqEditors ...RequestEditorFn) (*BiomechanicalResponse, error) {
	rsp, err := c.Biomechanical(ctx, gamePk, playId, positionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBiomechanicalResponse(rsp)
}

// SkeletalChunkedWithResponse request returning *SkeletalChunkedResponse
func (c *ClientWithResponses) SkeletalChunkedWithResponse(ctx context.Context, gamePk int32, playId string, params *SkeletalChunkedParams, reqEditors ...RequestEditorFn) (*SkeletalChunkedResponse, error) {
	rsp, err := c.SkeletalChunked(ctx, gamePk, playId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSkeletalChunkedResponse(rsp)
}

// SkeletalDataFileNamesWithResponse request returning *SkeletalDataFileNamesResponse
func (c *ClientWithResponses) SkeletalDataFileNamesWithResponse(ctx context.Context, gamePk int32, playId string, params *SkeletalDataFileNamesParams, reqEditors ...RequestEditorFn) (*SkeletalDataFileNamesResponse, error) {
	rsp, err := c.SkeletalDataFileNames(ctx, gamePk, playId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSkeletalDataFileNamesResponse(rsp)
}

// BoxscoreWithResponse request returning *BoxscoreResponse
func (c *ClientWithResponses) BoxscoreWithResponse(ctx context.Context, gamePk int32, params *BoxscoreParams, reqEditors ...RequestEditorFn) (*BoxscoreResponse, error) {
	rsp, err := c.Boxscore(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBoxscoreResponse(rsp)
}

// ContentWithResponse request returning *ContentResponse
func (c *ClientWithResponses) ContentWithResponse(ctx context.Context, gamePk int32, params *ContentParams, reqEditors ...RequestEditorFn) (*ContentResponse, error) {
	rsp, err := c.Content(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContentResponse(rsp)
}

// ColorFeedWithResponse request returning *ColorFeedResponse
func (c *ClientWithResponses) ColorFeedWithResponse(ctx context.Context, gamePk int32, params *ColorFeedParams, reqEditors ...RequestEditorFn) (*ColorFeedResponse, error) {
	rsp, err := c.ColorFeed(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseColorFeedResponse(rsp)
}

// ColorTimestampsWithResponse request returning *ColorTimestampsResponse
func (c *ClientWithResponses) ColorTimestampsWithResponse(ctx context.Context, gamePk int32, reqEditors ...RequestEditorFn) (*ColorTimestampsResponse, error) {
	rsp, err := c.ColorTimestamps(ctx, gamePk, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseColorTimestampsResponse(rsp)
}

// LinescoreWithResponse request returning *LinescoreResponse
func (c *ClientWithResponses) LinescoreWithResponse(ctx context.Context, gamePk int32, params *LinescoreParams, reqEditors ...RequestEditorFn) (*LinescoreResponse, error) {
	rsp, err := c.Linescore(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinescoreResponse(rsp)
}

// PlayByPlayWithResponse request returning *PlayByPlayResponse
func (c *ClientWithResponses) PlayByPlayWithResponse(ctx context.Context, gamePk int32, params *PlayByPlayParams, reqEditors ...RequestEditorFn) (*PlayByPlayResponse, error) {
	rsp, err := c.PlayByPlay(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlayByPlayResponse(rsp)
}

// GamePaceWithResponse request returning *GamePaceResponse
func (c *ClientWithResponses) GamePaceWithResponse(ctx context.Context, params *GamePaceParams, reqEditors ...RequestEditorFn) (*GamePaceResponse, error) {
	rsp, err := c.GamePace(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGamePaceResponse(rsp)
}

// GameStatusWithResponse request returning *GameStatusResponse
func (c *ClientWithResponses) GameStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GameStatusResponse, error) {
	rsp, err := c.GameStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGameStatusResponse(rsp)
}

// UpdateGameStatusesWithResponse request returning *UpdateGameStatusesResponse
func (c *ClientWithResponses) UpdateGameStatusesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateGameStatusesResponse, error) {
	rsp, err := c.UpdateGameStatuses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGameStatusesResponse(rsp)
}

// GameTypesWithResponse request returning *GameTypesResponse
func (c *ClientWithResponses) GameTypesWithResponse(ctx context.Context, params *GameTypesParams, reqEditors ...RequestEditorFn) (*GameTypesResponse, error) {
	rsp, err := c.GameTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGameTypesResponse(rsp)
}

// GamedayTypesWithResponse request returning *GamedayTypesResponse
func (c *ClientWithResponses) GamedayTypesWithResponse(ctx context.Context, params *GamedayTypesParams, reqEditors ...RequestEditorFn) (*GamedayTypesResponse, error) {
	rsp, err := c.GamedayTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGamedayTypesResponse(rsp)
}

// GroupByTypesWithResponse request returning *GroupByTypesResponse
func (c *ClientWithResponses) GroupByTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GroupByTypesResponse, error) {
	rsp, err := c.GroupByTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupByTypesResponse(rsp)
}

// HighLowStatsWithResponse request returning *HighLowStatsResponse
func (c *ClientWithResponses) HighLowStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HighLowStatsResponse, error) {
	rsp, err := c.HighLowStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHighLowStatsResponse(rsp)
}

// HighLowWithResponse request returning *HighLowResponse
func (c *ClientWithResponses) HighLowWithResponse(ctx context.Context, highLowType HighLowTypeEnum, params *HighLowParams, reqEditors ...RequestEditorFn) (*HighLowResponse, error) {
	rsp, err := c.HighLow(ctx, highLowType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHighLowResponse(rsp)
}

// HitTrajectoriesWithResponse request returning *HitTrajectoriesResponse
func (c *ClientWithResponses) HitTrajectoriesWithResponse(ctx context.Context, params *HitTrajectoriesParams, reqEditors ...RequestEditorFn) (*HitTrajectoriesResponse, error) {
	rsp, err := c.HitTrajectories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHitTrajectoriesResponse(rsp)
}

// HomeRunDerbyBracket1WithResponse request returning *HomeRunDerbyBracket1Response
func (c *ClientWithResponses) HomeRunDerbyBracket1WithResponse(ctx context.Context, params *HomeRunDerbyBracket1Params, reqEditors ...RequestEditorFn) (*HomeRunDerbyBracket1Response, error) {
	rsp, err := c.HomeRunDerbyBracket1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHomeRunDerbyBracket1Response(rsp)
}

// HomeRunDerbyBracket3WithResponse request returning *HomeRunDerbyBracket3Response
func (c *ClientWithResponses) HomeRunDerbyBracket3WithResponse(ctx context.Context, params *HomeRunDerbyBracket3Params, reqEditors ...RequestEditorFn) (*HomeRunDerbyBracket3Response, error) {
	rsp, err := c.HomeRunDerbyBracket3(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHomeRunDerbyBracket3Response(rsp)
}

// HomeRunDerbyMixedMode1WithResponse request returning *HomeRunDerbyMixedMode1Response
func (c *ClientWithResponses) HomeRunDerbyMixedMode1WithResponse(ctx context.Context, params *HomeRunDerbyMixedMode1Params, reqEditors ...RequestEditorFn) (*HomeRunDerbyMixedMode1Response, error) {
	rsp, err := c.HomeRunDerbyMixedMode1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHomeRunDerbyMixedMode1Response(rsp)
}

// HomeRunDerbyPool1WithResponse request returning *HomeRunDerbyPool1Response
func (c *ClientWithResponses) HomeRunDerbyPool1WithResponse(ctx context.Context, params *HomeRunDerbyPool1Params, reqEditors ...RequestEditorFn) (*HomeRunDerbyPool1Response, error) {
	rsp, err := c.HomeRunDerbyPool1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHomeRunDerbyPool1Response(rsp)
}

// HomeRunDerbyBracketWithResponse request returning *HomeRunDerbyBracketResponse
func (c *ClientWithResponses) HomeRunDerbyBracketWithResponse(ctx context.Context, gamePk int32, params *HomeRunDerbyBracketParams, reqEditors ...RequestEditorFn) (*HomeRunDerbyBracketResponse, error) {
	rsp, err := c.HomeRunDerbyBracket(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHomeRunDerbyBracketResponse(rsp)
}

// HomeRunDerbyBracket2WithResponse request returning *HomeRunDerbyBracket2Response
func (c *ClientWithResponses) HomeRunDerbyBracket2WithResponse(ctx context.Context, gamePk int32, params *HomeRunDerbyBracket2Params, reqEditors ...RequestEditorFn) (*HomeRunDerbyBracket2Response, error) {
	rsp, err := c.HomeRunDerbyBracket2(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHomeRunDerbyBracket2Response(rsp)
}

// HomeRunDerbyMixedModeWithResponse request returning *HomeRunDerbyMixedModeResponse
func (c *ClientWithResponses) HomeRunDerbyMixedModeWithResponse(ctx context.Context, gamePk int32, params *HomeRunDerbyMixedModeParams, reqEditors ...RequestEditorFn) (*HomeRunDerbyMixedModeResponse, error) {
	rsp, err := c.HomeRunDerbyMixedMode(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHomeRunDerbyMixedModeResponse(rsp)
}

// HomeRunDerbyPoolWithResponse request returning *HomeRunDerbyPoolResponse
func (c *ClientWithResponses) HomeRunDerbyPoolWithResponse(ctx context.Context, gamePk int32, params *HomeRunDerbyPoolParams, reqEditors ...RequestEditorFn) (*HomeRunDerbyPoolResponse, error) {
	rsp, err := c.HomeRunDerbyPool(ctx, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHomeRunDerbyPoolResponse(rsp)
}

// JobTypesWithResponse request returning *JobTypesResponse
func (c *ClientWithResponses) JobTypesWithResponse(ctx context.Context, params *JobTypesParams, reqEditors ...RequestEditorFn) (*JobTypesResponse, error) {
	rsp, err := c.JobTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJobTypesResponse(rsp)
}

// UpdateJobTypesWithResponse request returning *UpdateJobTypesResponse
func (c *ClientWithResponses) UpdateJobTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateJobTypesResponse, error) {
	rsp, err := c.UpdateJobTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobTypesResponse(rsp)
}

// GetJobsByTypeWithResponse request returning *GetJobsByTypeResponse
func (c *ClientWithResponses) GetJobsByTypeWithResponse(ctx context.Context, params *GetJobsByTypeParams, reqEditors ...RequestEditorFn) (*GetJobsByTypeResponse, error) {
	rsp, err := c.GetJobsByType(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobsByTypeResponse(rsp)
}

// DatacastersWithResponse request returning *DatacastersResponse
func (c *ClientWithResponses) DatacastersWithResponse(ctx context.Context, params *DatacastersParams, reqEditors ...RequestEditorFn) (*DatacastersResponse, error) {
	rsp, err := c.Datacasters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatacastersResponse(rsp)
}

// OfficialScorersWithResponse request returning *OfficialScorersResponse
func (c *ClientWithResponses) OfficialScorersWithResponse(ctx context.Context, params *OfficialScorersParams, reqEditors ...RequestEditorFn) (*OfficialScorersResponse, error) {
	rsp, err := c.OfficialScorers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOfficialScorersResponse(rsp)
}

// UmpiresWithResponse request returning *UmpiresResponse
func (c *ClientWithResponses) UmpiresWithResponse(ctx context.Context, params *UmpiresParams, reqEditors ...RequestEditorFn) (*UmpiresResponse, error) {
	rsp, err := c.Umpires(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUmpiresResponse(rsp)
}

// UmpireScheduleWithResponse request returning *UmpireScheduleResponse
func (c *ClientWithResponses) UmpireScheduleWithResponse(ctx context.Context, umpireId int32, params *UmpireScheduleParams, reqEditors ...RequestEditorFn) (*UmpireScheduleResponse, error) {
	rsp, err := c.UmpireSchedule(ctx, umpireId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUmpireScheduleResponse(rsp)
}

// LanguagesWithResponse request returning *LanguagesResponse
func (c *ClientWithResponses) LanguagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LanguagesResponse, error) {
	rsp, err := c.Languages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguagesResponse(rsp)
}

// LeagueWithResponse request returning *LeagueResponse
func (c *ClientWithResponses) LeagueWithResponse(ctx context.Context, params *LeagueParams, reqEditors ...RequestEditorFn) (*LeagueResponse, error) {
	rsp, err := c.League(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeagueResponse(rsp)
}

// AllStarBallotWithResponse request returning *AllStarBallotResponse
func (c *ClientWithResponses) AllStarBallotWithResponse(ctx context.Context, params *AllStarBallotParams, reqEditors ...RequestEditorFn) (*AllStarBallotResponse, error) {
	rsp, err := c.AllStarBallot(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllStarBallotResponse(rsp)
}

// League1WithResponse request returning *League1Response
func (c *ClientWithResponses) League1WithResponse(ctx context.Context, leagueId int32, params *League1Params, reqEditors ...RequestEditorFn) (*League1Response, error) {
	rsp, err := c.League1(ctx, leagueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeague1Response(rsp)
}

// AllStarBallot1WithResponse request returning *AllStarBallot1Response
func (c *ClientWithResponses) AllStarBallot1WithResponse(ctx context.Context, leagueId int32, params *AllStarBallot1Params, reqEditors ...RequestEditorFn) (*AllStarBallot1Response, error) {
	rsp, err := c.AllStarBallot1(ctx, leagueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllStarBallot1Response(rsp)
}

// AllStarFinalVoteWithResponse request returning *AllStarFinalVoteResponse
func (c *ClientWithResponses) AllStarFinalVoteWithResponse(ctx context.Context, leagueId int32, params *AllStarFinalVoteParams, reqEditors ...RequestEditorFn) (*AllStarFinalVoteResponse, error) {
	rsp, err := c.AllStarFinalVote(ctx, leagueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllStarFinalVoteResponse(rsp)
}

// AllStarWriteInsWithResponse request returning *AllStarWriteInsResponse
func (c *ClientWithResponses) AllStarWriteInsWithResponse(ctx context.Context, leagueId int32, params *AllStarWriteInsParams, reqEditors ...RequestEditorFn) (*AllStarWriteInsResponse, error) {
	rsp, err := c.AllStarWriteIns(ctx, leagueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllStarWriteInsResponse(rsp)
}

// LeagueLeaderTypesWithResponse request returning *LeagueLeaderTypesResponse
func (c *ClientWithResponses) LeagueLeaderTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LeagueLeaderTypesResponse, error) {
	rsp, err := c.LeagueLeaderTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeagueLeaderTypesResponse(rsp)
}

// League2WithResponse request returning *League2Response
func (c *ClientWithResponses) League2WithResponse(ctx context.Context, params *League2Params, reqEditors ...RequestEditorFn) (*League2Response, error) {
	rsp, err := c.League2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeague2Response(rsp)
}

// AllStarBallot2WithResponse request returning *AllStarBallot2Response
func (c *ClientWithResponses) AllStarBallot2WithResponse(ctx context.Context, params *AllStarBallot2Params, reqEditors ...RequestEditorFn) (*AllStarBallot2Response, error) {
	rsp, err := c.AllStarBallot2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllStarBallot2Response(rsp)
}

// League3WithResponse request returning *League3Response
func (c *ClientWithResponses) League3WithResponse(ctx context.Context, leagueId int32, params *League3Params, reqEditors ...RequestEditorFn) (*League3Response, error) {
	rsp, err := c.League3(ctx, leagueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeague3Response(rsp)
}

// AllStarBallot3WithResponse request returning *AllStarBallot3Response
func (c *ClientWithResponses) AllStarBallot3WithResponse(ctx context.Context, leagueId int32, params *AllStarBallot3Params, reqEditors ...RequestEditorFn) (*AllStarBallot3Response, error) {
	rsp, err := c.AllStarBallot3(ctx, leagueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllStarBallot3Response(rsp)
}

// AllStarFinalVote1WithResponse request returning *AllStarFinalVote1Response
func (c *ClientWithResponses) AllStarFinalVote1WithResponse(ctx context.Context, leagueId int32, params *AllStarFinalVote1Params, reqEditors ...RequestEditorFn) (*AllStarFinalVote1Response, error) {
	rsp, err := c.AllStarFinalVote1(ctx, leagueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllStarFinalVote1Response(rsp)
}

// AllStarWriteIns1WithResponse request returning *AllStarWriteIns1Response
func (c *ClientWithResponses) AllStarWriteIns1WithResponse(ctx context.Context, leagueId int32, params *AllStarWriteIns1Params, reqEditors ...RequestEditorFn) (*AllStarWriteIns1Response, error) {
	rsp, err := c.AllStarWriteIns1(ctx, leagueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllStarWriteIns1Response(rsp)
}

// LogicalEventsWithResponse request returning *LogicalEventsResponse
func (c *ClientWithResponses) LogicalEventsWithResponse(ctx context.Context, params *LogicalEventsParams, reqEditors ...RequestEditorFn) (*LogicalEventsResponse, error) {
	rsp, err := c.LogicalEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogicalEventsResponse(rsp)
}

// GetLookupValuesWithResponse request returning *GetLookupValuesResponse
func (c *ClientWithResponses) GetLookupValuesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLookupValuesResponse, error) {
	rsp, err := c.GetLookupValues(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLookupValuesResponse(rsp)
}

// MediaStateTypesWithResponse request returning *MediaStateTypesResponse
func (c *ClientWithResponses) MediaStateTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MediaStateTypesResponse, error) {
	rsp, err := c.MediaStateTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMediaStateTypesResponse(rsp)
}

// MetricsWithResponse request returning *MetricsResponse
func (c *ClientWithResponses) MetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetricsResponse, error) {
	rsp, err := c.Metrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricsResponse(rsp)
}

// MilestoneDurationsWithResponse request returning *MilestoneDurationsResponse
func (c *ClientWithResponses) MilestoneDurationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MilestoneDurationsResponse, error) {
	rsp, err := c.MilestoneDurations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMilestoneDurationsResponse(rsp)
}

// MilestoneLookupsWithResponse request returning *MilestoneLookupsResponse
func (c *ClientWithResponses) MilestoneLookupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MilestoneLookupsResponse, error) {
	rsp, err := c.MilestoneLookups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMilestoneLookupsResponse(rsp)
}

// MilestoneStatisticsWithResponse request returning *MilestoneStatisticsResponse
func (c *ClientWithResponses) MilestoneStatisticsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MilestoneStatisticsResponse, error) {
	rsp, err := c.MilestoneStatistics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMilestoneStatisticsResponse(rsp)
}

// MilestoneTypesWithResponse request returning *MilestoneTypesResponse
func (c *ClientWithResponses) MilestoneTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MilestoneTypesResponse, error) {
	rsp, err := c.MilestoneTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMilestoneTypesResponse(rsp)
}

// MilestonesWithResponse request returning *MilestonesResponse
func (c *ClientWithResponses) MilestonesWithResponse(ctx context.Context, params *MilestonesParams, reqEditors ...RequestEditorFn) (*MilestonesResponse, error) {
	rsp, err := c.Milestones(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMilestonesResponse(rsp)
}

// MoundVisitTypesWithResponse request returning *MoundVisitTypesResponse
func (c *ClientWithResponses) MoundVisitTypesWithResponse(ctx context.Context, params *MoundVisitTypesParams, reqEditors ...RequestEditorFn) (*MoundVisitTypesResponse, error) {
	rsp, err := c.MoundVisitTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoundVisitTypesResponse(rsp)
}

// Person1WithResponse request returning *Person1Response
func (c *ClientWithResponses) Person1WithResponse(ctx context.Context, params *Person1Params, reqEditors ...RequestEditorFn) (*Person1Response, error) {
	rsp, err := c.Person1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePerson1Response(rsp)
}

// CurrentGameStatsWithResponse request returning *CurrentGameStatsResponse
func (c *ClientWithResponses) CurrentGameStatsWithResponse(ctx context.Context, params *CurrentGameStatsParams, reqEditors ...RequestEditorFn) (*CurrentGameStatsResponse, error) {
	rsp, err := c.CurrentGameStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrentGameStatsResponse(rsp)
}

// FreeAgentsWithResponse request returning *FreeAgentsResponse
func (c *ClientWithResponses) FreeAgentsWithResponse(ctx context.Context, params *FreeAgentsParams, reqEditors ...RequestEditorFn) (*FreeAgentsResponse, error) {
	rsp, err := c.FreeAgents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFreeAgentsResponse(rsp)
}

// SearchWithResponse request returning *SearchResponse
func (c *ClientWithResponses) SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.Search(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResponse(rsp)
}

// PersonWithResponse request returning *PersonResponse
func (c *ClientWithResponses) PersonWithResponse(ctx context.Context, personId int32, params *PersonParams, reqEditors ...RequestEditorFn) (*PersonResponse, error) {
	rsp, err := c.Person(ctx, personId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonResponse(rsp)
}

// AwardWithResponse request returning *AwardResponse
func (c *ClientWithResponses) AwardWithResponse(ctx context.Context, personId int32, params *AwardParams, reqEditors ...RequestEditorFn) (*AwardResponse, error) {
	rsp, err := c.Award(ctx, personId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAwardResponse(rsp)
}

// Stats3WithResponse request returning *Stats3Response
func (c *ClientWithResponses) Stats3WithResponse(ctx context.Context, personId int32, params *Stats3Params, reqEditors ...RequestEditorFn) (*Stats3Response, error) {
	rsp, err := c.Stats3(ctx, personId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStats3Response(rsp)
}

// PlayerGameStatsWithResponse request returning *PlayerGameStatsResponse
func (c *ClientWithResponses) PlayerGameStatsWithResponse(ctx context.Context, personId int32, gamePk int32, params *PlayerGameStatsParams, reqEditors ...RequestEditorFn) (*PlayerGameStatsResponse, error) {
	rsp, err := c.PlayerGameStats(ctx, personId, gamePk, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlayerGameStatsResponse(rsp)
}

// StatsMetricsWithResponse request returning *StatsMetricsResponse
func (c *ClientWithResponses) StatsMetricsWithResponse(ctx context.Context, personId int32, params *StatsMetricsParams, reqEditors ...RequestEditorFn) (*StatsMetricsResponse, error) {
	rsp, err := c.StatsMetrics(ctx, personId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsMetricsResponse(rsp)
}

// PerformerTypesWithResponse request returning *PerformerTypesResponse
func (c *ClientWithResponses) PerformerTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PerformerTypesResponse, error) {
	rsp, err := c.PerformerTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePerformerTypesResponse(rsp)
}

// PitchCodesWithResponse request returning *PitchCodesResponse
func (c *ClientWithResponses) PitchCodesWithResponse(ctx context.Context, params *PitchCodesParams, reqEditors ...RequestEditorFn) (*PitchCodesResponse, error) {
	rsp, err := c.PitchCodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePitchCodesResponse(rsp)
}

// PitchTypesWithResponse request returning *PitchTypesResponse
func (c *ClientWithResponses) PitchTypesWithResponse(ctx context.Context, params *PitchTypesParams, reqEditors ...RequestEditorFn) (*PitchTypesResponse, error) {
	rsp, err := c.PitchTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePitchTypesResponse(rsp)
}

// PlatformsWithResponse request returning *PlatformsResponse
func (c *ClientWithResponses) PlatformsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PlatformsResponse, error) {
	rsp, err := c.Platforms(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlatformsResponse(rsp)
}

// PlayerStatusCodesWithResponse request returning *PlayerStatusCodesResponse
func (c *ClientWithResponses) PlayerStatusCodesWithResponse(ctx context.Context, params *PlayerStatusCodesParams, reqEditors ...RequestEditorFn) (*PlayerStatusCodesResponse, error) {
	rsp, err := c.PlayerStatusCodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlayerStatusCodesResponse(rsp)
}

// PositionsWithResponse request returning *PositionsResponse
func (c *ClientWithResponses) PositionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PositionsResponse, error) {
	rsp, err := c.Positions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePositionsResponse(rsp)
}

// GetPropsWithResponse request returning *GetPropsResponse
func (c *ClientWithResponses) GetPropsWithResponse(ctx context.Context, params *GetPropsParams, reqEditors ...RequestEditorFn) (*GetPropsResponse, error) {
	rsp, err := c.GetProps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPropsResponse(rsp)
}

// GetPropsAdjustWithResponse request returning *GetPropsAdjustResponse
func (c *ClientWithResponses) GetPropsAdjustWithResponse(ctx context.Context, params *GetPropsAdjustParams, reqEditors ...RequestEditorFn) (*GetPropsAdjustResponse, error) {
	rsp, err := c.GetPropsAdjust(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPropsAdjustResponse(rsp)
}

// GetReviewInfoWithResponse request returning *GetReviewInfoResponse
func (c *ClientWithResponses) GetReviewInfoWithResponse(ctx context.Context, params *GetReviewInfoParams, reqEditors ...RequestEditorFn) (*GetReviewInfoResponse, error) {
	rsp, err := c.GetReviewInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReviewInfoResponse(rsp)
}

// ReviewReasonsWithResponse request returning *ReviewReasonsResponse
func (c *ClientWithResponses) ReviewReasonsWithResponse(ctx context.Context, params *ReviewReasonsParams, reqEditors ...RequestEditorFn) (*ReviewReasonsResponse, error) {
	rsp, err := c.ReviewReasons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReviewReasonsResponse(rsp)
}

// RoofTypesWithResponse request returning *RoofTypesResponse
func (c *ClientWithResponses) RoofTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RoofTypesResponse, error) {
	rsp, err := c.RoofTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRoofTypesResponse(rsp)
}

// RosterTypesWithResponse request returning *RosterTypesResponse
func (c *ClientWithResponses) RosterTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RosterTypesResponse, error) {
	rsp, err := c.RosterTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRosterTypesResponse(rsp)
}

// RuleSettingsWithResponse request returning *RuleSettingsResponse
func (c *ClientWithResponses) RuleSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RuleSettingsResponse, error) {
	rsp, err := c.RuleSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRuleSettingsResponse(rsp)
}

// RunnerDetailTypesWithResponse request returning *RunnerDetailTypesResponse
func (c *ClientWithResponses) RunnerDetailTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RunnerDetailTypesResponse, error) {
	rsp, err := c.RunnerDetailTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunnerDetailTypesResponse(rsp)
}

// ScheduleWithResponse request returning *ScheduleResponse
func (c *ClientWithResponses) ScheduleWithResponse(ctx context.Context, params *ScheduleParams, reqEditors ...RequestEditorFn) (*ScheduleResponse, error) {
	rsp, err := c.Schedule(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScheduleResponse(rsp)
}

// TieGamesWithResponse request returning *TieGamesResponse
func (c *ClientWithResponses) TieGamesWithResponse(ctx context.Context, params *TieGamesParams, reqEditors ...RequestEditorFn) (*TieGamesResponse, error) {
	rsp, err := c.TieGames(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTieGamesResponse(rsp)
}

// PostseasonScheduleWithResponse request returning *PostseasonScheduleResponse
func (c *ClientWithResponses) PostseasonScheduleWithResponse(ctx context.Context, params *PostseasonScheduleParams, reqEditors ...RequestEditorFn) (*PostseasonScheduleResponse, error) {
	rsp, err := c.PostseasonSchedule(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostseasonScheduleResponse(rsp)
}

// PostseasonScheduleSeriesWithResponse request returning *PostseasonScheduleSeriesResponse
func (c *ClientWithResponses) PostseasonScheduleSeriesWithResponse(ctx context.Context, params *PostseasonScheduleSeriesParams, reqEditors ...RequestEditorFn) (*PostseasonScheduleSeriesResponse, error) {
	rsp, err := c.PostseasonScheduleSeries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostseasonScheduleSeriesResponse(rsp)
}

// TuneInWithResponse request returning *TuneInResponse
func (c *ClientWithResponses) TuneInWithResponse(ctx context.Context, params *TuneInParams, reqEditors ...RequestEditorFn) (*TuneInResponse, error) {
	rsp, err := c.TuneIn(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTuneInResponse(rsp)
}

// TrackingEventsScheduleWithResponse request returning *TrackingEventsScheduleResponse
func (c *ClientWithResponses) TrackingEventsScheduleWithResponse(ctx context.Context, params *TrackingEventsScheduleParams, reqEditors ...RequestEditorFn) (*TrackingEventsScheduleResponse, error) {
	rsp, err := c.TrackingEventsSchedule(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrackingEventsScheduleResponse(rsp)
}

// Schedule1WithResponse request returning *Schedule1Response
func (c *ClientWithResponses) Schedule1WithResponse(ctx context.Context, scheduleType string, params *Schedule1Params, reqEditors ...RequestEditorFn) (*Schedule1Response, error) {
	rsp, err := c.Schedule1(ctx, scheduleType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchedule1Response(rsp)
}

// ScheduleEventTypesWithResponse request returning *ScheduleEventTypesResponse
func (c *ClientWithResponses) ScheduleEventTypesWithResponse(ctx context.Context, params *ScheduleEventTypesParams, reqEditors ...RequestEditorFn) (*ScheduleEventTypesResponse, error) {
	rsp, err := c.ScheduleEventTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScheduleEventTypesResponse(rsp)
}

// ScheduleTypesWithResponse request returning *ScheduleTypesResponse
func (c *ClientWithResponses) ScheduleTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScheduleTypesResponse, error) {
	rsp, err := c.ScheduleTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScheduleTypesResponse(rsp)
}

// SeasonsWithResponse request returning *SeasonsResponse
func (c *ClientWithResponses) SeasonsWithResponse(ctx context.Context, params *SeasonsParams, reqEditors ...RequestEditorFn) (*SeasonsResponse, error) {
	rsp, err := c.Seasons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSeasonsResponse(rsp)
}

// AllSeasonsWithResponse request returning *AllSeasonsResponse
func (c *ClientWithResponses) AllSeasonsWithResponse(ctx context.Context, params *AllSeasonsParams, reqEditors ...RequestEditorFn) (*AllSeasonsResponse, error) {
	rsp, err := c.AllSeasons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllSeasonsResponse(rsp)
}

// Seasons1WithResponse request returning *Seasons1Response
func (c *ClientWithResponses) Seasons1WithResponse(ctx context.Context, seasonId string, params *Seasons1Params, reqEditors ...RequestEditorFn) (*Seasons1Response, error) {
	rsp, err := c.Seasons1(ctx, seasonId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSeasons1Response(rsp)
}

// SitCodesWithResponse request returning *SitCodesResponse
func (c *ClientWithResponses) SitCodesWithResponse(ctx context.Context, params *SitCodesParams, reqEditors ...RequestEditorFn) (*SitCodesResponse, error) {
	rsp, err := c.SitCodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSitCodesResponse(rsp)
}

// SkyWithResponse request returning *SkyResponse
func (c *ClientWithResponses) SkyWithResponse(ctx context.Context, params *SkyParams, reqEditors ...RequestEditorFn) (*SkyResponse, error) {
	rsp, err := c.Sky(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSkyResponse(rsp)
}

// AggregateSortEnumWithResponse request returning *AggregateSortEnumResponse
func (c *ClientWithResponses) AggregateSortEnumWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AggregateSortEnumResponse, error) {
	rsp, err := c.AggregateSortEnum(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAggregateSortEnumResponse(rsp)
}

// SportsWithResponse request returning *SportsResponse
func (c *ClientWithResponses) SportsWithResponse(ctx context.Context, params *SportsParams, reqEditors ...RequestEditorFn) (*SportsResponse, error) {
	rsp, err := c.Sports(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSportsResponse(rsp)
}

// Sports1WithResponse request returning *Sports1Response
func (c *ClientWithResponses) Sports1WithResponse(ctx context.Context, sportId int32, params *Sports1Params, reqEditors ...RequestEditorFn) (*Sports1Response, error) {
	rsp, err := c.Sports1(ctx, sportId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSports1Response(rsp)
}

// AllSportBallotWithResponse request returning *AllSportBallotResponse
func (c *ClientWithResponses) AllSportBallotWithResponse(ctx context.Context, sportId int32, params *AllSportBallotParams, reqEditors ...RequestEditorFn) (*AllSportBallotResponse, error) {
	rsp, err := c.AllSportBallot(ctx, sportId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllSportBallotResponse(rsp)
}

// SportPlayersWithResponse request returning *SportPlayersResponse
func (c *ClientWithResponses) SportPlayersWithResponse(ctx context.Context, sportId int32, params *SportPlayersParams, reqEditors ...RequestEditorFn) (*SportPlayersResponse, error) {
	rsp, err := c.SportPlayers(ctx, sportId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSportPlayersResponse(rsp)
}

// Standings1WithResponse request returning *Standings1Response
func (c *ClientWithResponses) Standings1WithResponse(ctx context.Context, params *Standings1Params, reqEditors ...RequestEditorFn) (*Standings1Response, error) {
	rsp, err := c.Standings1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStandings1Response(rsp)
}

// StandingsWithResponse request returning *StandingsResponse
func (c *ClientWithResponses) StandingsWithResponse(ctx context.Context, standingsType string, params *StandingsParams, reqEditors ...RequestEditorFn) (*StandingsResponse, error) {
	rsp, err := c.Standings(ctx, standingsType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStandingsResponse(rsp)
}

// StandingsTypesWithResponse request returning *StandingsTypesResponse
func (c *ClientWithResponses) StandingsTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StandingsTypesResponse, error) {
	rsp, err := c.StandingsTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStandingsTypesResponse(rsp)
}

// StatFieldsWithResponse request returning *StatFieldsResponse
func (c *ClientWithResponses) StatFieldsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatFieldsResponse, error) {
	rsp, err := c.StatFields(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatFieldsResponse(rsp)
}

// StatGroupsWithResponse request returning *StatGroupsResponse
func (c *ClientWithResponses) StatGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatGroupsResponse, error) {
	rsp, err := c.StatGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatGroupsResponse(rsp)
}

// StatTypesWithResponse request returning *StatTypesResponse
func (c *ClientWithResponses) StatTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatTypesResponse, error) {
	rsp, err := c.StatTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatTypesResponse(rsp)
}

// StatcastPositionTypesWithResponse request returning *StatcastPositionTypesResponse
func (c *ClientWithResponses) StatcastPositionTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatcastPositionTypesResponse, error) {
	rsp, err := c.StatcastPositionTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatcastPositionTypesResponse(rsp)
}

// Stats2WithResponse request returning *Stats2Response
func (c *ClientWithResponses) Stats2WithResponse(ctx context.Context, params *Stats2Params, reqEditors ...RequestEditorFn) (*Stats2Response, error) {
	rsp, err := c.Stats2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStats2Response(rsp)
}

// GetOutsAboveAverageWithResponse request returning *GetOutsAboveAverageResponse
func (c *ClientWithResponses) GetOutsAboveAverageWithResponse(ctx context.Context, params *GetOutsAboveAverageParams, reqEditors ...RequestEditorFn) (*GetOutsAboveAverageResponse, error) {
	rsp, err := c.GetOutsAboveAverage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutsAboveAverageResponse(rsp)
}

// GetSprayChartWithResponse request returning *GetSprayChartResponse
func (c *ClientWithResponses) GetSprayChartWithResponse(ctx context.Context, params *GetSprayChartParams, reqEditors ...RequestEditorFn) (*GetSprayChartResponse, error) {
	rsp, err := c.GetSprayChart(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSprayChartResponse(rsp)
}

// GetStolenBaseProbabilityWithResponse request returning *GetStolenBaseProbabilityResponse
func (c *ClientWithResponses) GetStolenBaseProbabilityWithResponse(ctx context.Context, params *GetStolenBaseProbabilityParams, reqEditors ...RequestEditorFn) (*GetStolenBaseProbabilityResponse, error) {
	rsp, err := c.GetStolenBaseProbability(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStolenBaseProbabilityResponse(rsp)
}

// GroupedStatsWithResponse request returning *GroupedStatsResponse
func (c *ClientWithResponses) GroupedStatsWithResponse(ctx context.Context, params *GroupedStatsParams, reqEditors ...RequestEditorFn) (*GroupedStatsResponse, error) {
	rsp, err := c.GroupedStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupedStatsResponse(rsp)
}

// Leaders2WithResponse request returning *Leaders2Response
func (c *ClientWithResponses) Leaders2WithResponse(ctx context.Context, params *Leaders2Params, reqEditors ...RequestEditorFn) (*Leaders2Response, error) {
	rsp, err := c.Leaders2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaders2Response(rsp)
}

// MetricStatsWithResponse request returning *MetricStatsResponse
func (c *ClientWithResponses) MetricStatsWithResponse(ctx context.Context, params *MetricStatsParams, reqEditors ...RequestEditorFn) (*MetricStatsResponse, error) {
	rsp, err := c.MetricStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricStatsResponse(rsp)
}

// BeastStatsWithResponse request returning *BeastStatsResponse
func (c *ClientWithResponses) BeastStatsWithResponse(ctx context.Context, params *BeastStatsParams, reqEditors ...RequestEditorFn) (*BeastStatsResponse, error) {
	rsp, err := c.BeastStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBeastStatsResponse(rsp)
}

// StatSearchConfigWithResponse request returning *StatSearchConfigResponse
func (c *ClientWithResponses) StatSearchConfigWithResponse(ctx context.Context, params *StatSearchConfigParams, reqEditors ...RequestEditorFn) (*StatSearchConfigResponse, error) {
	rsp, err := c.StatSearchConfig(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatSearchConfigResponse(rsp)
}

// StatSearchGroupByTypesWithResponse request returning *StatSearchGroupByTypesResponse
func (c *ClientWithResponses) StatSearchGroupByTypesWithResponse(ctx context.Context, params *StatSearchGroupByTypesParams, reqEditors ...RequestEditorFn) (*StatSearchGroupByTypesResponse, error) {
	rsp, err := c.StatSearchGroupByTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatSearchGroupByTypesResponse(rsp)
}

// StatSearchParamsWithResponse request returning *StatSearchParamsResponse
func (c *ClientWithResponses) StatSearchParamsWithResponse(ctx context.Context, params *StatSearchParamsParams, reqEditors ...RequestEditorFn) (*StatSearchParamsResponse, error) {
	rsp, err := c.StatSearchParams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatSearchParamsResponse(rsp)
}

// StatSearchStatsWithResponse request returning *StatSearchStatsResponse
func (c *ClientWithResponses) StatSearchStatsWithResponse(ctx context.Context, params *StatSearchStatsParams, reqEditors ...RequestEditorFn) (*StatSearchStatsResponse, error) {
	rsp, err := c.StatSearchStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatSearchStatsResponse(rsp)
}

// GetStreaksWithResponse request returning *GetStreaksResponse
func (c *ClientWithResponses) GetStreaksWithResponse(ctx context.Context, params *GetStreaksParams, reqEditors ...RequestEditorFn) (*GetStreaksResponse, error) {
	rsp, err := c.GetStreaks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreaksResponse(rsp)
}

// StreakTypesWithResponse request returning *StreakTypesResponse
func (c *ClientWithResponses) StreakTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StreakTypesResponse, error) {
	rsp, err := c.StreakTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreakTypesResponse(rsp)
}

// TeamsWithResponse request returning *TeamsResponse
func (c *ClientWithResponses) TeamsWithResponse(ctx context.Context, params *TeamsParams, reqEditors ...RequestEditorFn) (*TeamsResponse, error) {
	rsp, err := c.Teams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsResponse(rsp)
}

// Affiliates1WithResponse request returning *Affiliates1Response
func (c *ClientWithResponses) Affiliates1WithResponse(ctx context.Context, params *Affiliates1Params, reqEditors ...RequestEditorFn) (*Affiliates1Response, error) {
	rsp, err := c.Affiliates1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAffiliates1Response(rsp)
}

// AllTeams1WithResponse request returning *AllTeams1Response
func (c *ClientWithResponses) AllTeams1WithResponse(ctx context.Context, params *AllTeams1Params, reqEditors ...RequestEditorFn) (*AllTeams1Response, error) {
	rsp, err := c.AllTeams1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllTeams1Response(rsp)
}

// Stats1WithResponse request returning *Stats1Response
func (c *ClientWithResponses) Stats1WithResponse(ctx context.Context, params *Stats1Params, reqEditors ...RequestEditorFn) (*Stats1Response, error) {
	rsp, err := c.Stats1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStats1Response(rsp)
}

// Leaders1WithResponse request returning *Leaders1Response
func (c *ClientWithResponses) Leaders1WithResponse(ctx context.Context, params *Leaders1Params, reqEditors ...RequestEditorFn) (*Leaders1Response, error) {
	rsp, err := c.Leaders1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaders1Response(rsp)
}

// Teams1WithResponse request returning *Teams1Response
func (c *ClientWithResponses) Teams1WithResponse(ctx context.Context, teamId int32, params *Teams1Params, reqEditors ...RequestEditorFn) (*Teams1Response, error) {
	rsp, err := c.Teams1(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeams1Response(rsp)
}

// AffiliatesWithResponse request returning *AffiliatesResponse
func (c *ClientWithResponses) AffiliatesWithResponse(ctx context.Context, teamId int32, params *AffiliatesParams, reqEditors ...RequestEditorFn) (*AffiliatesResponse, error) {
	rsp, err := c.Affiliates(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAffiliatesResponse(rsp)
}

// AlumniWithResponse request returning *AlumniResponse
func (c *ClientWithResponses) AlumniWithResponse(ctx context.Context, teamId int32, params *AlumniParams, reqEditors ...RequestEditorFn) (*AlumniResponse, error) {
	rsp, err := c.Alumni(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlumniResponse(rsp)
}

// UpdateAlumniWithResponse request returning *UpdateAlumniResponse
func (c *ClientWithResponses) UpdateAlumniWithResponse(ctx context.Context, teamId int32, params *UpdateAlumniParams, reqEditors ...RequestEditorFn) (*UpdateAlumniResponse, error) {
	rsp, err := c.UpdateAlumni(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAlumniResponse(rsp)
}

// CoachesWithResponse request returning *CoachesResponse
func (c *ClientWithResponses) CoachesWithResponse(ctx context.Context, teamId int32, params *CoachesParams, reqEditors ...RequestEditorFn) (*CoachesResponse, error) {
	rsp, err := c.Coaches(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCoachesResponse(rsp)
}

// AllTeamsWithResponse request returning *AllTeamsResponse
func (c *ClientWithResponses) AllTeamsWithResponse(ctx context.Context, teamId int32, params *AllTeamsParams, reqEditors ...RequestEditorFn) (*AllTeamsResponse, error) {
	rsp, err := c.AllTeams(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllTeamsResponse(rsp)
}

// LeadersWithResponse request returning *LeadersResponse
func (c *ClientWithResponses) LeadersWithResponse(ctx context.Context, teamId int32, params *LeadersParams, reqEditors ...RequestEditorFn) (*LeadersResponse, error) {
	rsp, err := c.Leaders(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeadersResponse(rsp)
}

// PersonnelWithResponse request returning *PersonnelResponse
func (c *ClientWithResponses) PersonnelWithResponse(ctx context.Context, teamId int32, params *PersonnelParams, reqEditors ...RequestEditorFn) (*PersonnelResponse, error) {
	rsp, err := c.Personnel(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonnelResponse(rsp)
}

// RosterWithResponse request returning *RosterResponse
func (c *ClientWithResponses) RosterWithResponse(ctx context.Context, teamId int32, params *RosterParams, reqEditors ...RequestEditorFn) (*RosterResponse, error) {
	rsp, err := c.Roster(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRosterResponse(rsp)
}

// Roster1WithResponse request returning *Roster1Response
func (c *ClientWithResponses) Roster1WithResponse(ctx context.Context, teamId int32, rosterType string, params *Roster1Params, reqEditors ...RequestEditorFn) (*Roster1Response, error) {
	rsp, err := c.Roster1(ctx, teamId, rosterType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRoster1Response(rsp)
}

// StatsWithResponse request returning *StatsResponse
func (c *ClientWithResponses) StatsWithResponse(ctx context.Context, teamId int32, params *StatsParams, reqEditors ...RequestEditorFn) (*StatsResponse, error) {
	rsp, err := c.Stats(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsResponse(rsp)
}

// TrackingSoftwareVersionsWithResponse request returning *TrackingSoftwareVersionsResponse
func (c *ClientWithResponses) TrackingSoftwareVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TrackingSoftwareVersionsResponse, error) {
	rsp, err := c.TrackingSoftwareVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrackingSoftwareVersionsResponse(rsp)
}

// TrackingSystemOwnersWithResponse request returning *TrackingSystemOwnersResponse
func (c *ClientWithResponses) TrackingSystemOwnersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TrackingSystemOwnersResponse, error) {
	rsp, err := c.TrackingSystemOwners(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrackingSystemOwnersResponse(rsp)
}

// TrackingVendorsWithResponse request returning *TrackingVendorsResponse
func (c *ClientWithResponses) TrackingVendorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TrackingVendorsResponse, error) {
	rsp, err := c.TrackingVendors(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrackingVendorsResponse(rsp)
}

// TrackingVersionsWithResponse request returning *TrackingVersionsResponse
func (c *ClientWithResponses) TrackingVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TrackingVersionsResponse, error) {
	rsp, err := c.TrackingVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrackingVersionsResponse(rsp)
}

// TransactionTypesWithResponse request returning *TransactionTypesResponse
func (c *ClientWithResponses) TransactionTypesWithResponse(ctx context.Context, params *TransactionTypesParams, reqEditors ...RequestEditorFn) (*TransactionTypesResponse, error) {
	rsp, err := c.TransactionTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransactionTypesResponse(rsp)
}

// TransactionsWithResponse request returning *TransactionsResponse
func (c *ClientWithResponses) TransactionsWithResponse(ctx context.Context, params *TransactionsParams, reqEditors ...RequestEditorFn) (*TransactionsResponse, error) {
	rsp, err := c.Transactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransactionsResponse(rsp)
}

// UniformsByGameWithResponse request returning *UniformsByGameResponse
func (c *ClientWithResponses) UniformsByGameWithResponse(ctx context.Context, params *UniformsByGameParams, reqEditors ...RequestEditorFn) (*UniformsByGameResponse, error) {
	rsp, err := c.UniformsByGame(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUniformsByGameResponse(rsp)
}

// UniformsByTeamWithResponse request returning *UniformsByTeamResponse
func (c *ClientWithResponses) UniformsByTeamWithResponse(ctx context.Context, params *UniformsByTeamParams, reqEditors ...RequestEditorFn) (*UniformsByTeamResponse, error) {
	rsp, err := c.UniformsByTeam(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUniformsByTeamResponse(rsp)
}

// VenuesWithResponse request returning *VenuesResponse
func (c *ClientWithResponses) VenuesWithResponse(ctx context.Context, params *VenuesParams, reqEditors ...RequestEditorFn) (*VenuesResponse, error) {
	rsp, err := c.Venues(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVenuesResponse(rsp)
}

// Venues1WithResponse request returning *Venues1Response
func (c *ClientWithResponses) Venues1WithResponse(ctx context.Context, venueId int32, params *Venues1Params, reqEditors ...RequestEditorFn) (*Venues1Response, error) {
	rsp, err := c.Venues1(ctx, venueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVenues1Response(rsp)
}

// VideoResolutionTypesWithResponse request returning *VideoResolutionTypesResponse
func (c *ClientWithResponses) VideoResolutionTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VideoResolutionTypesResponse, error) {
	rsp, err := c.VideoResolutionTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVideoResolutionTypesResponse(rsp)
}

// ViolationTypesWithResponse request returning *ViolationTypesResponse
func (c *ClientWithResponses) ViolationTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ViolationTypesResponse, error) {
	rsp, err := c.ViolationTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseViolationTypesResponse(rsp)
}

// WeatherForecastWithResponse request returning *WeatherForecastResponse
func (c *ClientWithResponses) WeatherForecastWithResponse(ctx context.Context, gamePk int32, roofType RoofType, params *WeatherForecastParams, reqEditors ...RequestEditorFn) (*WeatherForecastResponse, error) {
	rsp, err := c.WeatherForecast(ctx, gamePk, roofType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWeatherForecastResponse(rsp)
}

// WeatherDataBasedOnPlayWithResponse request returning *WeatherDataBasedOnPlayResponse
func (c *ClientWithResponses) WeatherDataBasedOnPlayWithResponse(ctx context.Context, gamePk int32, playId string, params *WeatherDataBasedOnPlayParams, reqEditors ...RequestEditorFn) (*WeatherDataBasedOnPlayResponse, error) {
	rsp, err := c.WeatherDataBasedOnPlay(ctx, gamePk, playId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWeatherDataBasedOnPlayResponse(rsp)
}

// WeatherBasicWithResponse request returning *WeatherBasicResponse
func (c *ClientWithResponses) WeatherBasicWithResponse(ctx context.Context, venueId int32, params *WeatherBasicParams, reqEditors ...RequestEditorFn) (*WeatherBasicResponse, error) {
	rsp, err := c.WeatherBasic(ctx, venueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWeatherBasicResponse(rsp)
}

// WeatherFullWithResponse request returning *WeatherFullResponse
func (c *ClientWithResponses) WeatherFullWithResponse(ctx context.Context, venueId int32, params *WeatherFullParams, reqEditors ...RequestEditorFn) (*WeatherFullResponse, error) {
	rsp, err := c.WeatherFull(ctx, venueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWeatherFullResponse(rsp)
}

// WeatherTrajectoryConfidencesWithResponse request returning *WeatherTrajectoryConfidencesResponse
func (c *ClientWithResponses) WeatherTrajectoryConfidencesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WeatherTrajectoryConfidencesResponse, error) {
	rsp, err := c.WeatherTrajectoryConfidences(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWeatherTrajectoryConfidencesResponse(rsp)
}

// WindDirectionWithResponse request returning *WindDirectionResponse
func (c *ClientWithResponses) WindDirectionWithResponse(ctx context.Context, params *WindDirectionParams, reqEditors ...RequestEditorFn) (*WindDirectionResponse, error) {
	rsp, err := c.WindDirection(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWindDirectionResponse(rsp)
}

// ParseLiveGameV1Response parses an HTTP response from a LiveGameV1WithResponse call
func ParseLiveGameV1Response(rsp *http.Response) (*LiveGameV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LiveGameV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseballGameRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseLiveGameDiffPatchV1Response parses an HTTP response from a LiveGameDiffPatchV1WithResponse call
func ParseLiveGameDiffPatchV1Response(rsp *http.Response) (*LiveGameDiffPatchV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LiveGameDiffPatchV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseLiveTimestampv11Response parses an HTTP response from a LiveTimestampv11WithResponse call
func ParseLiveTimestampv11Response(rsp *http.Response) (*LiveTimestampv11Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LiveTimestampv11Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseAchievementStatusesResponse parses an HTTP response from a AchievementStatusesWithResponse call
func ParseAchievementStatusesResponse(rsp *http.Response) (*AchievementStatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AchievementStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGameGuidsFromPostgresRangeByGameResponse parses an HTTP response from a GameGuidsFromPostgresRangeByGameWithResponse call
func ParseGameGuidsFromPostgresRangeByGameResponse(rsp *http.Response) (*GameGuidsFromPostgresRangeByGameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GameGuidsFromPostgresRangeByGameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnalyticsGameMetadataWrapperRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseGameGuidsFromPostgresRangeResponse parses an HTTP response from a GameGuidsFromPostgresRangeWithResponse call
func ParseGameGuidsFromPostgresRangeResponse(rsp *http.Response) (*GameGuidsFromPostgresRangeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GameGuidsFromPostgresRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnalyticsPlayMetadataWrapperRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseGetTeamAttendanceResponse parses an HTTP response from a GetTeamAttendanceWithResponse call
func ParseGetTeamAttendanceResponse(rsp *http.Response) (*GetTeamAttendanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamAttendanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAwardsResponse parses an HTTP response from a AwardsWithResponse call
func ParseAwardsResponse(rsp *http.Response) (*AwardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AwardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAwards1Response parses an HTTP response from a Awards1WithResponse call
func ParseAwards1Response(rsp *http.Response) (*Awards1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Awards1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAwardRecipientsResponse parses an HTTP response from a AwardRecipientsWithResponse call
func ParseAwardRecipientsResponse(rsp *http.Response) (*AwardRecipientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AwardRecipientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBaseballStatsResponse parses an HTTP response from a BaseballStatsWithResponse call
func ParseBaseballStatsResponse(rsp *http.Response) (*BaseballStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BaseballStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBatTrackingResponse parses an HTTP response from a BatTrackingWithResponse call
func ParseBatTrackingResponse(rsp *http.Response) (*BatTrackingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BatTrackingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatTrackingRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBroadcastsResponse parses an HTTP response from a GetBroadcastsWithResponse call
func ParseGetBroadcastsResponse(rsp *http.Response) (*GetBroadcastsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBroadcastsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBroadcastAvailabilityTypesResponse parses an HTTP response from a BroadcastAvailabilityTypesWithResponse call
func ParseBroadcastAvailabilityTypesResponse(rsp *http.Response) (*BroadcastAvailabilityTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BroadcastAvailabilityTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAllBroadcastersResponse parses an HTTP response from a GetAllBroadcastersWithResponse call
func ParseGetAllBroadcastersResponse(rsp *http.Response) (*GetAllBroadcastersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBroadcastersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCoachingVideoTypesResponse parses an HTTP response from a CoachingVideoTypesWithResponse call
func ParseCoachingVideoTypesResponse(rsp *http.Response) (*CoachingVideoTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CoachingVideoTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseConferencesResponse parses an HTTP response from a ConferencesWithResponse call
func ParseConferencesResponse(rsp *http.Response) (*ConferencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConferencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseConferences1Response parses an HTTP response from a Conferences1WithResponse call
func ParseConferences1Response(rsp *http.Response) (*Conferences1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Conferences1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDivisionsResponse parses an HTTP response from a DivisionsWithResponse call
func ParseDivisionsResponse(rsp *http.Response) (*DivisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DivisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDivisions1Response parses an HTTP response from a Divisions1WithResponse call
func ParseDivisions1Response(rsp *http.Response) (*Divisions1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Divisions1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDraftPicksResponse parses an HTTP response from a DraftPicksWithResponse call
func ParseDraftPicksResponse(rsp *http.Response) (*DraftPicksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DraftPicksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDraftProspectsResponse parses an HTTP response from a DraftProspectsWithResponse call
func ParseDraftProspectsResponse(rsp *http.Response) (*DraftProspectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DraftProspectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDraftProspects1Response parses an HTTP response from a DraftProspects1WithResponse call
func ParseDraftProspects1Response(rsp *http.Response) (*DraftProspects1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DraftProspects1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDraftPicks1Response parses an HTTP response from a DraftPicks1WithResponse call
func ParseDraftPicks1Response(rsp *http.Response) (*DraftPicks1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DraftPicks1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLatestDraftPicksResponse parses an HTTP response from a LatestDraftPicksWithResponse call
func ParseLatestDraftPicksResponse(rsp *http.Response) (*LatestDraftPicksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LatestDraftPicksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEventStatusResponse parses an HTTP response from a EventStatusWithResponse call
func ParseEventStatusResponse(rsp *http.Response) (*EventStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEventTypesResponse parses an HTTP response from a EventTypesWithResponse call
func ParseEventTypesResponse(rsp *http.Response) (*EventTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseFielderDetailTypesResponse parses an HTTP response from a FielderDetailTypesWithResponse call
func ParseFielderDetailTypesResponse(rsp *http.Response) (*FielderDetailTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FielderDetailTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFreeGameTypesResponse parses an HTTP response from a FreeGameTypesWithResponse call
func ParseFreeGameTypesResponse(rsp *http.Response) (*FreeGameTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FreeGameTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCurrentGameStats1Response parses an HTTP response from a CurrentGameStats1WithResponse call
func ParseCurrentGameStats1Response(rsp *http.Response) (*CurrentGameStats1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CurrentGameStats1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGameLastPitchResponse parses an HTTP response from a GameLastPitchWithResponse call
func ParseGameLastPitchResponse(rsp *http.Response) (*GameLastPitchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GameLastPitchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AnalyticsPlayMetadataRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseGetGameContextMetricsResponse parses an HTTP response from a GetGameContextMetricsWithResponse call
func ParseGetGameContextMetricsResponse(rsp *http.Response) (*GetGameContextMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGameContextMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGameGuidsResponse parses an HTTP response from a GameGuidsWithResponse call
func ParseGameGuidsResponse(rsp *http.Response) (*GameGuidsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GameGuidsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AnalyticsPlayMetadataRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseGetWinProbabilityResponse parses an HTTP response from a GetWinProbabilityWithResponse call
func ParseGetWinProbabilityResponse(rsp *http.Response) (*GetWinProbabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWinProbabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGameWithMetricsResponse parses an HTTP response from a GetGameWithMetricsWithResponse call
func ParseGetGameWithMetricsResponse(rsp *http.Response) (*GetGameWithMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGameWithMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseParsedJsonFormattedAnalyticsResponse parses an HTTP response from a ParsedJsonFormattedAnalyticsWithResponse call
func ParseParsedJsonFormattedAnalyticsResponse(rsp *http.Response) (*ParsedJsonFormattedAnalyticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ParsedJsonFormattedAnalyticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnalyticsRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseContextMetricsResponse parses an HTTP response from a ContextMetricsWithResponse call
func ParseContextMetricsResponse(rsp *http.Response) (*ContextMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContextMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CalculatedMetricRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseContextMetricsWithAveragesResponse parses an HTTP response from a ContextMetricsWithAveragesWithResponse call
func ParseContextMetricsWithAveragesResponse(rsp *http.Response) (*ContextMetricsWithAveragesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContextMetricsWithAveragesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CalculatedMetricRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseContextMetricsWithAveragesPostResponse parses an HTTP response from a ContextMetricsWithAveragesPostWithResponse call
func ParseContextMetricsWithAveragesPostResponse(rsp *http.Response) (*ContextMetricsWithAveragesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContextMetricsWithAveragesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CalculatedMetricRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseHomeRunBallparksResponse parses an HTTP response from a HomeRunBallparksWithResponse call
func ParseHomeRunBallparksResponse(rsp *http.Response) (*HomeRunBallparksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HomeRunBallparksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VenuesRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseBiomechanicalResponse parses an HTTP response from a BiomechanicalWithResponse call
func ParseBiomechanicalResponse(rsp *http.Response) (*BiomechanicalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BiomechanicalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SkeletalDataWrapperRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSkeletalChunkedResponse parses an HTTP response from a SkeletalChunkedWithResponse call
func ParseSkeletalChunkedResponse(rsp *http.Response) (*SkeletalChunkedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SkeletalChunkedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSkeletalDataFileNamesResponse parses an HTTP response from a SkeletalDataFileNamesWithResponse call
func ParseSkeletalDataFileNamesResponse(rsp *http.Response) (*SkeletalDataFileNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SkeletalDataFileNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SkeletalFileData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBoxscoreResponse parses an HTTP response from a BoxscoreWithResponse call
func ParseBoxscoreResponse(rsp *http.Response) (*BoxscoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BoxscoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseballBoxscoreRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseContentResponse parses an HTTP response from a ContentWithResponse call
func ParseContentResponse(rsp *http.Response) (*ContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GameContentRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseColorFeedResponse parses an HTTP response from a ColorFeedWithResponse call
func ParseColorFeedResponse(rsp *http.Response) (*ColorFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ColorFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseColorTimestampsResponse parses an HTTP response from a ColorTimestampsWithResponse call
func ParseColorTimestampsResponse(rsp *http.Response) (*ColorTimestampsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ColorTimestampsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseLinescoreResponse parses an HTTP response from a LinescoreWithResponse call
func ParseLinescoreResponse(rsp *http.Response) (*LinescoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinescoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseballLinescoreRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParsePlayByPlayResponse parses an HTTP response from a PlayByPlayWithResponse call
func ParsePlayByPlayResponse(rsp *http.Response) (*PlayByPlayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlayByPlayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseballPlayByPlayRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseGamePaceResponse parses an HTTP response from a GamePaceWithResponse call
func ParseGamePaceResponse(rsp *http.Response) (*GamePaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GamePaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGameStatusResponse parses an HTTP response from a GameStatusWithResponse call
func ParseGameStatusResponse(rsp *http.Response) (*GameStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GameStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateGameStatusesResponse parses an HTTP response from a UpdateGameStatusesWithResponse call
func ParseUpdateGameStatusesResponse(rsp *http.Response) (*UpdateGameStatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGameStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGameTypesResponse parses an HTTP response from a GameTypesWithResponse call
func ParseGameTypesResponse(rsp *http.Response) (*GameTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GameTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGamedayTypesResponse parses an HTTP response from a GamedayTypesWithResponse call
func ParseGamedayTypesResponse(rsp *http.Response) (*GamedayTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GamedayTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGroupByTypesResponse parses an HTTP response from a GroupByTypesWithResponse call
func ParseGroupByTypesResponse(rsp *http.Response) (*GroupByTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupByTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHighLowStatsResponse parses an HTTP response from a HighLowStatsWithResponse call
func ParseHighLowStatsResponse(rsp *http.Response) (*HighLowStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HighLowStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHighLowResponse parses an HTTP response from a HighLowWithResponse call
func ParseHighLowResponse(rsp *http.Response) (*HighLowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HighLowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHitTrajectoriesResponse parses an HTTP response from a HitTrajectoriesWithResponse call
func ParseHitTrajectoriesResponse(rsp *http.Response) (*HitTrajectoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HitTrajectoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHomeRunDerbyBracket1Response parses an HTTP response from a HomeRunDerbyBracket1WithResponse call
func ParseHomeRunDerbyBracket1Response(rsp *http.Response) (*HomeRunDerbyBracket1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HomeRunDerbyBracket1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHomeRunDerbyBracket3Response parses an HTTP response from a HomeRunDerbyBracket3WithResponse call
func ParseHomeRunDerbyBracket3Response(rsp *http.Response) (*HomeRunDerbyBracket3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HomeRunDerbyBracket3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHomeRunDerbyMixedMode1Response parses an HTTP response from a HomeRunDerbyMixedMode1WithResponse call
func ParseHomeRunDerbyMixedMode1Response(rsp *http.Response) (*HomeRunDerbyMixedMode1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HomeRunDerbyMixedMode1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHomeRunDerbyPool1Response parses an HTTP response from a HomeRunDerbyPool1WithResponse call
func ParseHomeRunDerbyPool1Response(rsp *http.Response) (*HomeRunDerbyPool1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HomeRunDerbyPool1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHomeRunDerbyBracketResponse parses an HTTP response from a HomeRunDerbyBracketWithResponse call
func ParseHomeRunDerbyBracketResponse(rsp *http.Response) (*HomeRunDerbyBracketResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HomeRunDerbyBracketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHomeRunDerbyBracket2Response parses an HTTP response from a HomeRunDerbyBracket2WithResponse call
func ParseHomeRunDerbyBracket2Response(rsp *http.Response) (*HomeRunDerbyBracket2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HomeRunDerbyBracket2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHomeRunDerbyMixedModeResponse parses an HTTP response from a HomeRunDerbyMixedModeWithResponse call
func ParseHomeRunDerbyMixedModeResponse(rsp *http.Response) (*HomeRunDerbyMixedModeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HomeRunDerbyMixedModeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHomeRunDerbyPoolResponse parses an HTTP response from a HomeRunDerbyPoolWithResponse call
func ParseHomeRunDerbyPoolResponse(rsp *http.Response) (*HomeRunDerbyPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HomeRunDerbyPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseJobTypesResponse parses an HTTP response from a JobTypesWithResponse call
func ParseJobTypesResponse(rsp *http.Response) (*JobTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JobTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateJobTypesResponse parses an HTTP response from a UpdateJobTypesWithResponse call
func ParseUpdateJobTypesResponse(rsp *http.Response) (*UpdateJobTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateJobTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetJobsByTypeResponse parses an HTTP response from a GetJobsByTypeWithResponse call
func ParseGetJobsByTypeResponse(rsp *http.Response) (*GetJobsByTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobsByTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDatacastersResponse parses an HTTP response from a DatacastersWithResponse call
func ParseDatacastersResponse(rsp *http.Response) (*DatacastersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatacastersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOfficialScorersResponse parses an HTTP response from a OfficialScorersWithResponse call
func ParseOfficialScorersResponse(rsp *http.Response) (*OfficialScorersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OfficialScorersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUmpiresResponse parses an HTTP response from a UmpiresWithResponse call
func ParseUmpiresResponse(rsp *http.Response) (*UmpiresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UmpiresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUmpireScheduleResponse parses an HTTP response from a UmpireScheduleWithResponse call
func ParseUmpireScheduleResponse(rsp *http.Response) (*UmpireScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UmpireScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLanguagesResponse parses an HTTP response from a LanguagesWithResponse call
func ParseLanguagesResponse(rsp *http.Response) (*LanguagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLeagueResponse parses an HTTP response from a LeagueWithResponse call
func ParseLeagueResponse(rsp *http.Response) (*LeagueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeagueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAllStarBallotResponse parses an HTTP response from a AllStarBallotWithResponse call
func ParseAllStarBallotResponse(rsp *http.Response) (*AllStarBallotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllStarBallotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLeague1Response parses an HTTP response from a League1WithResponse call
func ParseLeague1Response(rsp *http.Response) (*League1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &League1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAllStarBallot1Response parses an HTTP response from a AllStarBallot1WithResponse call
func ParseAllStarBallot1Response(rsp *http.Response) (*AllStarBallot1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllStarBallot1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAllStarFinalVoteResponse parses an HTTP response from a AllStarFinalVoteWithResponse call
func ParseAllStarFinalVoteResponse(rsp *http.Response) (*AllStarFinalVoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllStarFinalVoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAllStarWriteInsResponse parses an HTTP response from a AllStarWriteInsWithResponse call
func ParseAllStarWriteInsResponse(rsp *http.Response) (*AllStarWriteInsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllStarWriteInsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLeagueLeaderTypesResponse parses an HTTP response from a LeagueLeaderTypesWithResponse call
func ParseLeagueLeaderTypesResponse(rsp *http.Response) (*LeagueLeaderTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeagueLeaderTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLeague2Response parses an HTTP response from a League2WithResponse call
func ParseLeague2Response(rsp *http.Response) (*League2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &League2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAllStarBallot2Response parses an HTTP response from a AllStarBallot2WithResponse call
func ParseAllStarBallot2Response(rsp *http.Response) (*AllStarBallot2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllStarBallot2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLeague3Response parses an HTTP response from a League3WithResponse call
func ParseLeague3Response(rsp *http.Response) (*League3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &League3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAllStarBallot3Response parses an HTTP response from a AllStarBallot3WithResponse call
func ParseAllStarBallot3Response(rsp *http.Response) (*AllStarBallot3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllStarBallot3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAllStarFinalVote1Response parses an HTTP response from a AllStarFinalVote1WithResponse call
func ParseAllStarFinalVote1Response(rsp *http.Response) (*AllStarFinalVote1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllStarFinalVote1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAllStarWriteIns1Response parses an HTTP response from a AllStarWriteIns1WithResponse call
func ParseAllStarWriteIns1Response(rsp *http.Response) (*AllStarWriteIns1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllStarWriteIns1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLogicalEventsResponse parses an HTTP response from a LogicalEventsWithResponse call
func ParseLogicalEventsResponse(rsp *http.Response) (*LogicalEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogicalEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLookupValuesResponse parses an HTTP response from a GetLookupValuesWithResponse call
func ParseGetLookupValuesResponse(rsp *http.Response) (*GetLookupValuesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLookupValuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMediaStateTypesResponse parses an HTTP response from a MediaStateTypesWithResponse call
func ParseMediaStateTypesResponse(rsp *http.Response) (*MediaStateTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MediaStateTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMetricsResponse parses an HTTP response from a MetricsWithResponse call
func ParseMetricsResponse(rsp *http.Response) (*MetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMilestoneDurationsResponse parses an HTTP response from a MilestoneDurationsWithResponse call
func ParseMilestoneDurationsResponse(rsp *http.Response) (*MilestoneDurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MilestoneDurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMilestoneLookupsResponse parses an HTTP response from a MilestoneLookupsWithResponse call
func ParseMilestoneLookupsResponse(rsp *http.Response) (*MilestoneLookupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MilestoneLookupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMilestoneStatisticsResponse parses an HTTP response from a MilestoneStatisticsWithResponse call
func ParseMilestoneStatisticsResponse(rsp *http.Response) (*MilestoneStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MilestoneStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMilestoneTypesResponse parses an HTTP response from a MilestoneTypesWithResponse call
func ParseMilestoneTypesResponse(rsp *http.Response) (*MilestoneTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MilestoneTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMilestonesResponse parses an HTTP response from a MilestonesWithResponse call
func ParseMilestonesResponse(rsp *http.Response) (*MilestonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MilestonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMoundVisitTypesResponse parses an HTTP response from a MoundVisitTypesWithResponse call
func ParseMoundVisitTypesResponse(rsp *http.Response) (*MoundVisitTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MoundVisitTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePerson1Response parses an HTTP response from a Person1WithResponse call
func ParsePerson1Response(rsp *http.Response) (*Person1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Person1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCurrentGameStatsResponse parses an HTTP response from a CurrentGameStatsWithResponse call
func ParseCurrentGameStatsResponse(rsp *http.Response) (*CurrentGameStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CurrentGameStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFreeAgentsResponse parses an HTTP response from a FreeAgentsWithResponse call
func ParseFreeAgentsResponse(rsp *http.Response) (*FreeAgentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FreeAgentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchResponse parses an HTTP response from a SearchWithResponse call
func ParseSearchResponse(rsp *http.Response) (*SearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersonResponse parses an HTTP response from a PersonWithResponse call
func ParsePersonResponse(rsp *http.Response) (*PersonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAwardResponse parses an HTTP response from a AwardWithResponse call
func ParseAwardResponse(rsp *http.Response) (*AwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStats3Response parses an HTTP response from a Stats3WithResponse call
func ParseStats3Response(rsp *http.Response) (*Stats3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Stats3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePlayerGameStatsResponse parses an HTTP response from a PlayerGameStatsWithResponse call
func ParsePlayerGameStatsResponse(rsp *http.Response) (*PlayerGameStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlayerGameStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatsMetricsResponse parses an HTTP response from a StatsMetricsWithResponse call
func ParseStatsMetricsResponse(rsp *http.Response) (*StatsMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatsMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePerformerTypesResponse parses an HTTP response from a PerformerTypesWithResponse call
func ParsePerformerTypesResponse(rsp *http.Response) (*PerformerTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PerformerTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePitchCodesResponse parses an HTTP response from a PitchCodesWithResponse call
func ParsePitchCodesResponse(rsp *http.Response) (*PitchCodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PitchCodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePitchTypesResponse parses an HTTP response from a PitchTypesWithResponse call
func ParsePitchTypesResponse(rsp *http.Response) (*PitchTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PitchTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePlatformsResponse parses an HTTP response from a PlatformsWithResponse call
func ParsePlatformsResponse(rsp *http.Response) (*PlatformsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlatformsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePlayerStatusCodesResponse parses an HTTP response from a PlayerStatusCodesWithResponse call
func ParsePlayerStatusCodesResponse(rsp *http.Response) (*PlayerStatusCodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlayerStatusCodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePositionsResponse parses an HTTP response from a PositionsWithResponse call
func ParsePositionsResponse(rsp *http.Response) (*PositionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PositionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPropsResponse parses an HTTP response from a GetPropsWithResponse call
func ParseGetPropsResponse(rsp *http.Response) (*GetPropsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPropsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPropsAdjustResponse parses an HTTP response from a GetPropsAdjustWithResponse call
func ParseGetPropsAdjustResponse(rsp *http.Response) (*GetPropsAdjustResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPropsAdjustResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReviewInfoResponse parses an HTTP response from a GetReviewInfoWithResponse call
func ParseGetReviewInfoResponse(rsp *http.Response) (*GetReviewInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReviewInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReviewReasonsResponse parses an HTTP response from a ReviewReasonsWithResponse call
func ParseReviewReasonsResponse(rsp *http.Response) (*ReviewReasonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReviewReasonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRoofTypesResponse parses an HTTP response from a RoofTypesWithResponse call
func ParseRoofTypesResponse(rsp *http.Response) (*RoofTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RoofTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRosterTypesResponse parses an HTTP response from a RosterTypesWithResponse call
func ParseRosterTypesResponse(rsp *http.Response) (*RosterTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RosterTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRuleSettingsResponse parses an HTTP response from a RuleSettingsWithResponse call
func ParseRuleSettingsResponse(rsp *http.Response) (*RuleSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RuleSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunnerDetailTypesResponse parses an HTTP response from a RunnerDetailTypesWithResponse call
func ParseRunnerDetailTypesResponse(rsp *http.Response) (*RunnerDetailTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunnerDetailTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseScheduleResponse parses an HTTP response from a ScheduleWithResponse call
func ParseScheduleResponse(rsp *http.Response) (*ScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTieGamesResponse parses an HTTP response from a TieGamesWithResponse call
func ParseTieGamesResponse(rsp *http.Response) (*TieGamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TieGamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostseasonScheduleResponse parses an HTTP response from a PostseasonScheduleWithResponse call
func ParsePostseasonScheduleResponse(rsp *http.Response) (*PostseasonScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostseasonScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostseasonScheduleSeriesResponse parses an HTTP response from a PostseasonScheduleSeriesWithResponse call
func ParsePostseasonScheduleSeriesResponse(rsp *http.Response) (*PostseasonScheduleSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostseasonScheduleSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTuneInResponse parses an HTTP response from a TuneInWithResponse call
func ParseTuneInResponse(rsp *http.Response) (*TuneInResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TuneInResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTrackingEventsScheduleResponse parses an HTTP response from a TrackingEventsScheduleWithResponse call
func ParseTrackingEventsScheduleResponse(rsp *http.Response) (*TrackingEventsScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrackingEventsScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSchedule1Response parses an HTTP response from a Schedule1WithResponse call
func ParseSchedule1Response(rsp *http.Response) (*Schedule1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Schedule1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseScheduleEventTypesResponse parses an HTTP response from a ScheduleEventTypesWithResponse call
func ParseScheduleEventTypesResponse(rsp *http.Response) (*ScheduleEventTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScheduleEventTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseScheduleTypesResponse parses an HTTP response from a ScheduleTypesWithResponse call
func ParseScheduleTypesResponse(rsp *http.Response) (*ScheduleTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScheduleTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSeasonsResponse parses an HTTP response from a SeasonsWithResponse call
func ParseSeasonsResponse(rsp *http.Response) (*SeasonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SeasonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAllSeasonsResponse parses an HTTP response from a AllSeasonsWithResponse call
func ParseAllSeasonsResponse(rsp *http.Response) (*AllSeasonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllSeasonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSeasons1Response parses an HTTP response from a Seasons1WithResponse call
func ParseSeasons1Response(rsp *http.Response) (*Seasons1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Seasons1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSitCodesResponse parses an HTTP response from a SitCodesWithResponse call
func ParseSitCodesResponse(rsp *http.Response) (*SitCodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SitCodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSkyResponse parses an HTTP response from a SkyWithResponse call
func ParseSkyResponse(rsp *http.Response) (*SkyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SkyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAggregateSortEnumResponse parses an HTTP response from a AggregateSortEnumWithResponse call
func ParseAggregateSortEnumResponse(rsp *http.Response) (*AggregateSortEnumResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AggregateSortEnumResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSportsResponse parses an HTTP response from a SportsWithResponse call
func ParseSportsResponse(rsp *http.Response) (*SportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSports1Response parses an HTTP response from a Sports1WithResponse call
func ParseSports1Response(rsp *http.Response) (*Sports1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Sports1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAllSportBallotResponse parses an HTTP response from a AllSportBallotWithResponse call
func ParseAllSportBallotResponse(rsp *http.Response) (*AllSportBallotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllSportBallotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSportPlayersResponse parses an HTTP response from a SportPlayersWithResponse call
func ParseSportPlayersResponse(rsp *http.Response) (*SportPlayersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SportPlayersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStandings1Response parses an HTTP response from a Standings1WithResponse call
func ParseStandings1Response(rsp *http.Response) (*Standings1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Standings1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStandingsResponse parses an HTTP response from a StandingsWithResponse call
func ParseStandingsResponse(rsp *http.Response) (*StandingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StandingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStandingsTypesResponse parses an HTTP response from a StandingsTypesWithResponse call
func ParseStandingsTypesResponse(rsp *http.Response) (*StandingsTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StandingsTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatFieldsResponse parses an HTTP response from a StatFieldsWithResponse call
func ParseStatFieldsResponse(rsp *http.Response) (*StatFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatGroupsResponse parses an HTTP response from a StatGroupsWithResponse call
func ParseStatGroupsResponse(rsp *http.Response) (*StatGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatTypesResponse parses an HTTP response from a StatTypesWithResponse call
func ParseStatTypesResponse(rsp *http.Response) (*StatTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatcastPositionTypesResponse parses an HTTP response from a StatcastPositionTypesWithResponse call
func ParseStatcastPositionTypesResponse(rsp *http.Response) (*StatcastPositionTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatcastPositionTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStats2Response parses an HTTP response from a Stats2WithResponse call
func ParseStats2Response(rsp *http.Response) (*Stats2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Stats2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOutsAboveAverageResponse parses an HTTP response from a GetOutsAboveAverageWithResponse call
func ParseGetOutsAboveAverageResponse(rsp *http.Response) (*GetOutsAboveAverageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutsAboveAverageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSprayChartResponse parses an HTTP response from a GetSprayChartWithResponse call
func ParseGetSprayChartResponse(rsp *http.Response) (*GetSprayChartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSprayChartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStolenBaseProbabilityResponse parses an HTTP response from a GetStolenBaseProbabilityWithResponse call
func ParseGetStolenBaseProbabilityResponse(rsp *http.Response) (*GetStolenBaseProbabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStolenBaseProbabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGroupedStatsResponse parses an HTTP response from a GroupedStatsWithResponse call
func ParseGroupedStatsResponse(rsp *http.Response) (*GroupedStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupedStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLeaders2Response parses an HTTP response from a Leaders2WithResponse call
func ParseLeaders2Response(rsp *http.Response) (*Leaders2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Leaders2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMetricStatsResponse parses an HTTP response from a MetricStatsWithResponse call
func ParseMetricStatsResponse(rsp *http.Response) (*MetricStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBeastStatsResponse parses an HTTP response from a BeastStatsWithResponse call
func ParseBeastStatsResponse(rsp *http.Response) (*BeastStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BeastStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatSearchConfigResponse parses an HTTP response from a StatSearchConfigWithResponse call
func ParseStatSearchConfigResponse(rsp *http.Response) (*StatSearchConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatSearchConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatSearchGroupByTypesResponse parses an HTTP response from a StatSearchGroupByTypesWithResponse call
func ParseStatSearchGroupByTypesResponse(rsp *http.Response) (*StatSearchGroupByTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatSearchGroupByTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatSearchParamsResponse parses an HTTP response from a StatSearchParamsWithResponse call
func ParseStatSearchParamsResponse(rsp *http.Response) (*StatSearchParamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatSearchParamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatSearchStatsResponse parses an HTTP response from a StatSearchStatsWithResponse call
func ParseStatSearchStatsResponse(rsp *http.Response) (*StatSearchStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatSearchStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStreaksResponse parses an HTTP response from a GetStreaksWithResponse call
func ParseGetStreaksResponse(rsp *http.Response) (*GetStreaksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreaksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStreakTypesResponse parses an HTTP response from a StreakTypesWithResponse call
func ParseStreakTypesResponse(rsp *http.Response) (*StreakTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreakTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamsResponse parses an HTTP response from a TeamsWithResponse call
func ParseTeamsResponse(rsp *http.Response) (*TeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAffiliates1Response parses an HTTP response from a Affiliates1WithResponse call
func ParseAffiliates1Response(rsp *http.Response) (*Affiliates1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Affiliates1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAllTeams1Response parses an HTTP response from a AllTeams1WithResponse call
func ParseAllTeams1Response(rsp *http.Response) (*AllTeams1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllTeams1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStats1Response parses an HTTP response from a Stats1WithResponse call
func ParseStats1Response(rsp *http.Response) (*Stats1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Stats1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLeaders1Response parses an HTTP response from a Leaders1WithResponse call
func ParseLeaders1Response(rsp *http.Response) (*Leaders1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Leaders1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeams1Response parses an HTTP response from a Teams1WithResponse call
func ParseTeams1Response(rsp *http.Response) (*Teams1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Teams1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAffiliatesResponse parses an HTTP response from a AffiliatesWithResponse call
func ParseAffiliatesResponse(rsp *http.Response) (*AffiliatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AffiliatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAlumniResponse parses an HTTP response from a AlumniWithResponse call
func ParseAlumniResponse(rsp *http.Response) (*AlumniResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlumniResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateAlumniResponse parses an HTTP response from a UpdateAlumniWithResponse call
func ParseUpdateAlumniResponse(rsp *http.Response) (*UpdateAlumniResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAlumniResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCoachesResponse parses an HTTP response from a CoachesWithResponse call
func ParseCoachesResponse(rsp *http.Response) (*CoachesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CoachesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAllTeamsResponse parses an HTTP response from a AllTeamsWithResponse call
func ParseAllTeamsResponse(rsp *http.Response) (*AllTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLeadersResponse parses an HTTP response from a LeadersWithResponse call
func ParseLeadersResponse(rsp *http.Response) (*LeadersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeadersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersonnelResponse parses an HTTP response from a PersonnelWithResponse call
func ParsePersonnelResponse(rsp *http.Response) (*PersonnelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonnelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRosterResponse parses an HTTP response from a RosterWithResponse call
func ParseRosterResponse(rsp *http.Response) (*RosterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RosterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRoster1Response parses an HTTP response from a Roster1WithResponse call
func ParseRoster1Response(rsp *http.Response) (*Roster1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Roster1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatsResponse parses an HTTP response from a StatsWithResponse call
func ParseStatsResponse(rsp *http.Response) (*StatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTrackingSoftwareVersionsResponse parses an HTTP response from a TrackingSoftwareVersionsWithResponse call
func ParseTrackingSoftwareVersionsResponse(rsp *http.Response) (*TrackingSoftwareVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrackingSoftwareVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTrackingSystemOwnersResponse parses an HTTP response from a TrackingSystemOwnersWithResponse call
func ParseTrackingSystemOwnersResponse(rsp *http.Response) (*TrackingSystemOwnersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrackingSystemOwnersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTrackingVendorsResponse parses an HTTP response from a TrackingVendorsWithResponse call
func ParseTrackingVendorsResponse(rsp *http.Response) (*TrackingVendorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrackingVendorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTrackingVersionsResponse parses an HTTP response from a TrackingVersionsWithResponse call
func ParseTrackingVersionsResponse(rsp *http.Response) (*TrackingVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrackingVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransactionTypesResponse parses an HTTP response from a TransactionTypesWithResponse call
func ParseTransactionTypesResponse(rsp *http.Response) (*TransactionTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransactionTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransactionsResponse parses an HTTP response from a TransactionsWithResponse call
func ParseTransactionsResponse(rsp *http.Response) (*TransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUniformsByGameResponse parses an HTTP response from a UniformsByGameWithResponse call
func ParseUniformsByGameResponse(rsp *http.Response) (*UniformsByGameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UniformsByGameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUniformsByTeamResponse parses an HTTP response from a UniformsByTeamWithResponse call
func ParseUniformsByTeamResponse(rsp *http.Response) (*UniformsByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UniformsByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseVenuesResponse parses an HTTP response from a VenuesWithResponse call
func ParseVenuesResponse(rsp *http.Response) (*VenuesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VenuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseVenues1Response parses an HTTP response from a Venues1WithResponse call
func ParseVenues1Response(rsp *http.Response) (*Venues1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Venues1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseVideoResolutionTypesResponse parses an HTTP response from a VideoResolutionTypesWithResponse call
func ParseVideoResolutionTypesResponse(rsp *http.Response) (*VideoResolutionTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VideoResolutionTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseViolationTypesResponse parses an HTTP response from a ViolationTypesWithResponse call
func ParseViolationTypesResponse(rsp *http.Response) (*ViolationTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ViolationTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWeatherForecastResponse parses an HTTP response from a WeatherForecastWithResponse call
func ParseWeatherForecastResponse(rsp *http.Response) (*WeatherForecastResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WeatherForecastResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ForecastWeatherWrapperRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseWeatherDataBasedOnPlayResponse parses an HTTP response from a WeatherDataBasedOnPlayWithResponse call
func ParseWeatherDataBasedOnPlayResponse(rsp *http.Response) (*WeatherDataBasedOnPlayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WeatherDataBasedOnPlayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlayWeatherWrapperRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseWeatherBasicResponse parses an HTTP response from a WeatherBasicWithResponse call
func ParseWeatherBasicResponse(rsp *http.Response) (*WeatherBasicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WeatherBasicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BasicWeatherWrapperRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseWeatherFullResponse parses an HTTP response from a WeatherFullWithResponse call
func ParseWeatherFullResponse(rsp *http.Response) (*WeatherFullResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WeatherFullResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FullWeatherWrapperRestObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseWeatherTrajectoryConfidencesResponse parses an HTTP response from a WeatherTrajectoryConfidencesWithResponse call
func ParseWeatherTrajectoryConfidencesResponse(rsp *http.Response) (*WeatherTrajectoryConfidencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WeatherTrajectoryConfidencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWindDirectionResponse parses an HTTP response from a WindDirectionWithResponse call
func ParseWindDirectionResponse(rsp *http.Response) (*WindDirectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WindDirectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get live game status.
	// (GET /api/v1.1/game/{game_pk}/feed/live)
	LiveGameV1(ctx echo.Context, gamePk int32, params LiveGameV1Params) error
	// Get live game status diffPatch.
	// (GET /api/v1.1/game/{game_pk}/feed/live/diffPatch)
	LiveGameDiffPatchV1(ctx echo.Context, gamePk int32, params LiveGameDiffPatchV1Params) error
	// Retrieve all of the play timestamps for a game.
	// (GET /api/v1.1/game/{game_pk}/feed/live/timestamps)
	LiveTimestampv11(ctx echo.Context, gamePk int32) error
	// View available achievementStatus options
	// (GET /api/v1/achievementStatuses)
	AchievementStatuses(ctx echo.Context) error
	// Get all games by updated date.
	// (GET /api/v1/analytics/game)
	GameGuidsFromPostgresRangeByGame(ctx echo.Context, params GameGuidsFromPostgresRangeByGameParams) error
	// Get the GUIDs (plays) for a specific game.
	// (GET /api/v1/analytics/guids)
	GameGuidsFromPostgresRange(ctx echo.Context, params GameGuidsFromPostgresRangeParams) error
	// Get team attendance
	// (GET /api/v1/attendance)
	GetTeamAttendance(ctx echo.Context, params GetTeamAttendanceParams) error
	// View awards info
	// (GET /api/v1/awards)
	Awards(ctx echo.Context, params AwardsParams) error
	// View awards info
	// (GET /api/v1/awards/{awardId})
	Awards1(ctx echo.Context, awardId string, params Awards1Params) error
	// View recipients of an award
	// (GET /api/v1/awards/{awardId}/recipients)
	AwardRecipients(ctx echo.Context, awardId string, params AwardRecipientsParams) error
	// List all baseball stats
	// (GET /api/v1/baseballStats)
	BaseballStats(ctx echo.Context) error
	// View Bat Tracking Data by playId and gameId
	// (GET /api/v1/batTracking/game/{gamePk}/{playId})
	BatTracking(ctx echo.Context, gamePk int32, playId string, params BatTrackingParams) error
	// Get Broadcasters
	// (GET /api/v1/broadcast)
	GetBroadcasts(ctx echo.Context, params GetBroadcastsParams) error
	// View broadcast availability options
	// (GET /api/v1/broadcastAvailability)
	BroadcastAvailabilityTypes(ctx echo.Context) error
	// Get All Active Broadcasters
	// (GET /api/v1/broadcasters)
	GetAllBroadcasters(ctx echo.Context, params GetAllBroadcastersParams) error
	// List all coaching video types
	// (GET /api/v1/coachingVideoTypes)
	CoachingVideoTypes(ctx echo.Context) error
	// View conference info
	// (GET /api/v1/conferences)
	Conferences(ctx echo.Context, params ConferencesParams) error
	// View conference info
	// (GET /api/v1/conferences/{conferenceId})
	Conferences1(ctx echo.Context, conferenceId int32, params Conferences1Params) error
	// Get division information
	// (GET /api/v1/divisions)
	Divisions(ctx echo.Context, params DivisionsParams) error
	// Get division information
	// (GET /api/v1/divisions/{divisionId})
	Divisions1(ctx echo.Context, divisionId int32, params Divisions1Params) error
	// View MLB Drafted Players
	// (GET /api/v1/draft)
	DraftPicks(ctx echo.Context, params DraftPicksParams) error
	// View MLB Draft Prospects
	// (GET /api/v1/draft/prospects)
	DraftProspects(ctx echo.Context, params DraftProspectsParams) error
	// View MLB Draft Prospects
	// (GET /api/v1/draft/prospects/{year})
	DraftProspects1(ctx echo.Context, year int32, params DraftProspects1Params) error
	// View MLB Drafted Players
	// (GET /api/v1/draft/{year})
	DraftPicks1(ctx echo.Context, year int32, params DraftPicks1Params) error
	// Get the last drafted player and the next 5 teams up to pick
	// (GET /api/v1/draft/{year}/latest)
	LatestDraftPicks(ctx echo.Context, year int32, params LatestDraftPicksParams) error
	// List all possible event status types
	// (GET /api/v1/eventStatus)
	EventStatus(ctx echo.Context) error
	// List all event types
	// (GET /api/v1/eventTypes)
	EventTypes(ctx echo.Context, params EventTypesParams) error
	// List fielder detail types
	// (GET /api/v1/fielderDetailTypes)
	FielderDetailTypes(ctx echo.Context) error
	// View free game types
	// (GET /api/v1/freeGameTypes)
	FreeGameTypes(ctx echo.Context) error
	// View a game change log
	// (GET /api/v1/game/changes)
	CurrentGameStats1(ctx echo.Context, params CurrentGameStats1Params) error
	// Get the last pitch for a list of games
	// (GET /api/v1/game/lastPitch)
	GameLastPitch(ctx echo.Context, params GameLastPitchParams) error
	// Get the context metrics for this game based on its current state
	// (GET /api/v1/game/{gamePk}/contextMetrics)
	GetGameContextMetrics(ctx echo.Context, gamePk int32, params GetGameContextMetricsParams) error
	// Get the GUIDs (plays) for a specific game.
	// (GET /api/v1/game/{gamePk}/guids)
	GameGuids(ctx echo.Context, gamePk int32, params GameGuidsParams) error
	// Get the win probability for this game
	// (GET /api/v1/game/{gamePk}/winProbability)
	GetWinProbability(ctx echo.Context, gamePk int32, params GetWinProbabilityParams) error
	// Get game info with metrics
	// (GET /api/v1/game/{gamePk}/withMetrics)
	GetGameWithMetrics(ctx echo.Context, gamePk int32, params GetGameWithMetricsParams) error
	// Get Statcast data for a specific play.
	// (GET /api/v1/game/{gamePk}/{guid}/analytics)
	ParsedJsonFormattedAnalytics(ctx echo.Context, gamePk int32, guid string, params ParsedJsonFormattedAnalyticsParams) error
	// Get context metrics for a specific gamePk.
	// (GET /api/v1/game/{gamePk}/{guid}/contextMetrics)
	ContextMetrics(ctx echo.Context, gamePk int32, guid string, params ContextMetricsParams) error
	// Get a json file containing raw coordinate data and refined calculated metrics.
	// (GET /api/v1/game/{gamePk}/{guid}/contextMetricsAverages)
	ContextMetricsWithAverages(ctx echo.Context, gamePk int32, guid string, params ContextMetricsWithAveragesParams) error
	// Get a json file containing raw coordinate data and refined calculated metrics.
	// (POST /api/v1/game/{gamePk}/{guid}/contextMetricsAverages)
	ContextMetricsWithAveragesPost(ctx echo.Context, gamePk int32, guid string, params ContextMetricsWithAveragesPostParams) error
	// Get if the play is a home run is each park for a specific play.
	// (GET /api/v1/game/{gamePk}/{guid}/homeRunBallparks)
	HomeRunBallparks(ctx echo.Context, gamePk int32, guid string, params HomeRunBallparksParams) error
	// View Biomechanical data by playId and gameId filtered by player positionId
	// (GET /api/v1/game/{gamePk}/{playId}/analytics/biomechanics/{positionId})
	Biomechanical(ctx echo.Context, gamePk int32, playId string, positionId int32, params BiomechanicalParams) error
	// View Skeletal Data by playId and gameId chunked
	// (GET /api/v1/game/{gamePk}/{playId}/analytics/skeletalData/chunked)
	SkeletalChunked(ctx echo.Context, gamePk int32, playId string, params SkeletalChunkedParams) error
	// View Skeletal Data by playId and gameId files
	// (GET /api/v1/game/{gamePk}/{playId}/analytics/skeletalData/files)
	SkeletalDataFileNames(ctx echo.Context, gamePk int32, playId string, params SkeletalDataFileNamesParams) error
	// Get game boxscore.
	// (GET /api/v1/game/{game_pk}/boxscore)
	Boxscore(ctx echo.Context, gamePk int32, params BoxscoreParams) error
	// Retrieve all content for a game.
	// (GET /api/v1/game/{game_pk}/content)
	Content(ctx echo.Context, gamePk int32, params ContentParams) error
	// Get game color feed.
	// (GET /api/v1/game/{game_pk}/feed/color)
	ColorFeed(ctx echo.Context, gamePk int32, params ColorFeedParams) error
	// Retrieve all of the color timestamps for a game.
	// (GET /api/v1/game/{game_pk}/feed/color/timestamps)
	ColorTimestamps(ctx echo.Context, gamePk int32) error
	// Get game linescore
	// (GET /api/v1/game/{game_pk}/linescore)
	Linescore(ctx echo.Context, gamePk int32, params LinescoreParams) error
	// Get game play By Play
	// (GET /api/v1/game/{game_pk}/playByPlay)
	PlayByPlay(ctx echo.Context, gamePk int32, params PlayByPlayParams) error
	// View time of game info
	// (GET /api/v1/gamePace)
	GamePace(ctx echo.Context, params GamePaceParams) error
	// List all status types
	// (GET /api/v1/gameStatus)
	GameStatus(ctx echo.Context) error
	// Clear all status types
	// (POST /api/v1/gameStatus)
	UpdateGameStatuses(ctx echo.Context) error
	// List all game types
	// (GET /api/v1/gameTypes)
	GameTypes(ctx echo.Context, params GameTypesParams) error
	// List all gameday types
	// (GET /api/v1/gamedayTypes)
	GamedayTypes(ctx echo.Context, params GamedayTypesParams) error
	// List groupBy types
	// (GET /api/v1/groupByTypes)
	GroupByTypes(ctx echo.Context) error
	// View high/low stat types
	// (GET /api/v1/highLow/types)
	HighLowStats(ctx echo.Context) error
	// View high/low stats by player or team
	// (GET /api/v1/highLow/{highLowType})
	HighLow(ctx echo.Context, highLowType HighLowTypeEnum, params HighLowParams) error
	// List all hit trajectories
	// (GET /api/v1/hitTrajectories)
	HitTrajectories(ctx echo.Context, params HitTrajectoriesParams) error
	// View a home run derby object
	// (GET /api/v1/homeRunDerby)
	HomeRunDerbyBracket1(ctx echo.Context, params HomeRunDerbyBracket1Params) error
	// View a home run derby object
	// (GET /api/v1/homeRunDerby/bracket)
	HomeRunDerbyBracket3(ctx echo.Context, params HomeRunDerbyBracket3Params) error
	// View home run derby mixed mode (Bracket/Pool combo)
	// (GET /api/v1/homeRunDerby/mixed)
	HomeRunDerbyMixedMode1(ctx echo.Context, params HomeRunDerbyMixedMode1Params) error
	// View home run derby pool
	// (GET /api/v1/homeRunDerby/pool)
	HomeRunDerbyPool1(ctx echo.Context, params HomeRunDerbyPool1Params) error
	// View a home run derby object
	// (GET /api/v1/homeRunDerby/{gamePk})
	HomeRunDerbyBracket(ctx echo.Context, gamePk int32, params HomeRunDerbyBracketParams) error
	// View a home run derby object
	// (GET /api/v1/homeRunDerby/{gamePk}/bracket)
	HomeRunDerbyBracket2(ctx echo.Context, gamePk int32, params HomeRunDerbyBracket2Params) error
	// View home run derby mixed mode (Bracket/Pool combo)
	// (GET /api/v1/homeRunDerby/{gamePk}/mixed)
	HomeRunDerbyMixedMode(ctx echo.Context, gamePk int32, params HomeRunDerbyMixedModeParams) error
	// View home run derby pool
	// (GET /api/v1/homeRunDerby/{gamePk}/pool)
	HomeRunDerbyPool(ctx echo.Context, gamePk int32, params HomeRunDerbyPoolParams) error
	// List all job types
	// (GET /api/v1/jobTypes)
	JobTypes(ctx echo.Context, params JobTypesParams) error

	// (POST /api/v1/jobTypes)
	UpdateJobTypes(ctx echo.Context) error
	// Get jobs by type
	// (GET /api/v1/jobs)
	GetJobsByType(ctx echo.Context, params GetJobsByTypeParams) error
	// Get datacaster jobs
	// (GET /api/v1/jobs/datacasters)
	Datacasters(ctx echo.Context, params DatacastersParams) error
	// Get official scorers
	// (GET /api/v1/jobs/officialScorers)
	OfficialScorers(ctx echo.Context, params OfficialScorersParams) error
	// Get umpires
	// (GET /api/v1/jobs/umpires)
	Umpires(ctx echo.Context, params UmpiresParams) error
	// Get umpires and associated game for umpireId
	// (GET /api/v1/jobs/umpires/games/{umpireId})
	UmpireSchedule(ctx echo.Context, umpireId int32, params UmpireScheduleParams) error
	// List all support languages
	// (GET /api/v1/languages)
	Languages(ctx echo.Context) error
	// View league info
	// (GET /api/v1/league)
	League(ctx echo.Context, params LeagueParams) error
	// View al star ballot info
	// (GET /api/v1/league/allStarBallot)
	AllStarBallot(ctx echo.Context, params AllStarBallotParams) error
	// View league info
	// (GET /api/v1/league/{leagueId})
	League1(ctx echo.Context, leagueId int32, params League1Params) error
	// View al star ballot info
	// (GET /api/v1/league/{leagueId}/allStarBallot)
	AllStarBallot1(ctx echo.Context, leagueId int32, params AllStarBallot1Params) error
	// View all star final vote info
	// (GET /api/v1/league/{leagueId}/allStarFinalVote)
	AllStarFinalVote(ctx echo.Context, leagueId int32, params AllStarFinalVoteParams) error
	// View all star write ins info
	// (GET /api/v1/league/{leagueId}/allStarWriteIns)
	AllStarWriteIns(ctx echo.Context, leagueId int32, params AllStarWriteInsParams) error
	// List all possible player league leader types
	// (GET /api/v1/leagueLeaderTypes)
	LeagueLeaderTypes(ctx echo.Context) error
	// View league info
	// (GET /api/v1/leagues)
	League2(ctx echo.Context, params League2Params) error
	// View al star ballot info
	// (GET /api/v1/leagues/allStarBallot)
	AllStarBallot2(ctx echo.Context, params AllStarBallot2Params) error
	// View league info
	// (GET /api/v1/leagues/{leagueId})
	League3(ctx echo.Context, leagueId int32, params League3Params) error
	// View al star ballot info
	// (GET /api/v1/leagues/{leagueId}/allStarBallot)
	AllStarBallot3(ctx echo.Context, leagueId int32, params AllStarBallot3Params) error
	// View all star final vote info
	// (GET /api/v1/leagues/{leagueId}/allStarFinalVote)
	AllStarFinalVote1(ctx echo.Context, leagueId int32, params AllStarFinalVote1Params) error
	// View all star write ins info
	// (GET /api/v1/leagues/{leagueId}/allStarWriteIns)
	AllStarWriteIns1(ctx echo.Context, leagueId int32, params AllStarWriteIns1Params) error
	// List all logical event types
	// (GET /api/v1/logicalEvents)
	LogicalEvents(ctx echo.Context, params LogicalEventsParams) error
	// View all lookup values
	// (GET /api/v1/lookup/values/all)
	GetLookupValues(ctx echo.Context) error
	// View media state options
	// (GET /api/v1/mediaState)
	MediaStateTypes(ctx echo.Context) error
	// List all possible metrics
	// (GET /api/v1/metrics)
	Metrics(ctx echo.Context) error
	// View available milestoneDurations options
	// (GET /api/v1/milestoneDurations)
	MilestoneDurations(ctx echo.Context) error
	// View available milestoneLookup options
	// (GET /api/v1/milestoneLookups)
	MilestoneLookups(ctx echo.Context) error
	// View available milestone statistics options
	// (GET /api/v1/milestoneStatistics)
	MilestoneStatistics(ctx echo.Context) error
	// View available milestoneType options
	// (GET /api/v1/milestoneTypes)
	MilestoneTypes(ctx echo.Context) error
	// View pending and achieved milestones.
	// (GET /api/v1/milestones)
	Milestones(ctx echo.Context, params MilestonesParams) error
	// List all mound visit types
	// (GET /api/v1/moundVisitTypes)
	MoundVisitTypes(ctx echo.Context, params MoundVisitTypesParams) error
	// View a player
	// (GET /api/v1/people)
	Person1(ctx echo.Context, params Person1Params) error
	// View a player's change log
	// (GET /api/v1/people/changes)
	CurrentGameStats(ctx echo.Context, params CurrentGameStatsParams) error
	// Get free agents
	// (GET /api/v1/people/freeAgents)
	FreeAgents(ctx echo.Context, params FreeAgentsParams) error
	// Search for a player by name
	// (GET /api/v1/people/search)
	Search(ctx echo.Context, params SearchParams) error
	// View a player
	// (GET /api/v1/people/{personId})
	Person(ctx echo.Context, personId int32, params PersonParams) error
	// View a player's awards
	// (GET /api/v1/people/{personId}/awards)
	Award(ctx echo.Context, personId int32, params AwardParams) error
	// View a players stats
	// (GET /api/v1/people/{personId}/stats)
	Stats3(ctx echo.Context, personId int32, params Stats3Params) error
	// View a player's game stats
	// (GET /api/v1/people/{personId}/stats/game/{gamePk})
	PlayerGameStats(ctx echo.Context, personId int32, gamePk int32, params PlayerGameStatsParams) error
	// View a player's stat metrics
	// (GET /api/v1/people/{personId}/stats/metrics)
	StatsMetrics(ctx echo.Context, personId int32, params StatsMetricsParams) error
	// List all possible performer types
	// (GET /api/v1/performerTypes)
	PerformerTypes(ctx echo.Context) error
	// List all pitch codes
	// (GET /api/v1/pitchCodes)
	PitchCodes(ctx echo.Context, params PitchCodesParams) error
	// List all pitch classification types
	// (GET /api/v1/pitchTypes)
	PitchTypes(ctx echo.Context, params PitchTypesParams) error
	// List all possible platforms
	// (GET /api/v1/platforms)
	Platforms(ctx echo.Context) error
	// List all player status codes
	// (GET /api/v1/playerStatusCodes)
	PlayerStatusCodes(ctx echo.Context, params PlayerStatusCodesParams) error
	// List all possible positions
	// (GET /api/v1/positions)
	Positions(ctx echo.Context) error
	// Get play-level predictions based on input scenarios
	// (GET /api/v1/props/play/predictions)
	GetProps(ctx echo.Context, params GetPropsParams) error
	// Get play-level predictions based on input scenarios
	// (GET /api/v1/props/play/predictions/adjust)
	GetPropsAdjust(ctx echo.Context, params GetPropsAdjustParams) error
	// Get review info
	// (GET /api/v1/review)
	GetReviewInfo(ctx echo.Context, params GetReviewInfoParams) error
	// List all replay review reasons
	// (GET /api/v1/reviewReasons)
	ReviewReasons(ctx echo.Context, params ReviewReasonsParams) error
	// List all roof types
	// (GET /api/v1/roofTypes)
	RoofTypes(ctx echo.Context) error
	// List all possible roster types
	// (GET /api/v1/rosterTypes)
	RosterTypes(ctx echo.Context) error
	// List all ruleSettings
	// (GET /api/v1/ruleSettings)
	RuleSettings(ctx echo.Context) error
	// List runner detail types
	// (GET /api/v1/runnerDetailTypes)
	RunnerDetailTypes(ctx echo.Context) error
	// View schedule info based on scheduleType.
	// (GET /api/v1/schedule)
	Schedule(ctx echo.Context, params ScheduleParams) error
	// Get tied game schedules
	// (GET /api/v1/schedule/games/tied)
	TieGames(ctx echo.Context, params TieGamesParams) error
	// Get postseason schedule
	// (GET /api/v1/schedule/postseason)
	PostseasonSchedule(ctx echo.Context, params PostseasonScheduleParams) error
	// Get postseason series schedules
	// (GET /api/v1/schedule/postseason/series)
	PostseasonScheduleSeries(ctx echo.Context, params PostseasonScheduleSeriesParams) error
	// Get postseason TuneIn schedules
	// (GET /api/v1/schedule/postseason/tuneIn)
	TuneIn(ctx echo.Context, params TuneInParams) error
	// Get tracking event schedules
	// (GET /api/v1/schedule/trackingEvents)
	TrackingEventsSchedule(ctx echo.Context, params TrackingEventsScheduleParams) error
	// View schedule info based on scheduleType.
	// (GET /api/v1/schedule/{scheduleType})
	Schedule1(ctx echo.Context, scheduleType string, params Schedule1Params) error
	// List all schedule event types
	// (GET /api/v1/scheduleEventTypes)
	ScheduleEventTypes(ctx echo.Context, params ScheduleEventTypesParams) error
	// List all possible schedule types
	// (GET /api/v1/scheduleTypes)
	ScheduleTypes(ctx echo.Context) error
	// View season info
	// (GET /api/v1/seasons)
	Seasons(ctx echo.Context, params SeasonsParams) error
	// View all seasons
	// (GET /api/v1/seasons/all)
	AllSeasons(ctx echo.Context, params AllSeasonsParams) error
	// View season info
	// (GET /api/v1/seasons/{seasonId})
	Seasons1(ctx echo.Context, seasonId string, params Seasons1Params) error
	// List all situation codes
	// (GET /api/v1/situationCodes)
	SitCodes(ctx echo.Context, params SitCodesParams) error
	// List all sky options
	// (GET /api/v1/sky)
	Sky(ctx echo.Context, params SkyParams) error
	// List all stat fields
	// (GET /api/v1/sortModifiers)
	AggregateSortEnum(ctx echo.Context) error
	// Get sports information
	// (GET /api/v1/sports)
	Sports(ctx echo.Context, params SportsParams) error
	// Get sports information
	// (GET /api/v1/sports/{sportId})
	Sports1(ctx echo.Context, sportId int32, params Sports1Params) error
	// Get ALL MLB ballot for sport
	// (GET /api/v1/sports/{sportId}/allSportBallot)
	AllSportBallot(ctx echo.Context, sportId int32, params AllSportBallotParams) error
	// Get all players for a sport level
	// (GET /api/v1/sports/{sportId}/players)
	SportPlayers(ctx echo.Context, sportId int32, params SportPlayersParams) error
	// View standings for a league
	// (GET /api/v1/standings)
	Standings1(ctx echo.Context, params Standings1Params) error
	// View standings for a league
	// (GET /api/v1/standings/{standingsType})
	Standings(ctx echo.Context, standingsType string, params StandingsParams) error
	// List all standings types
	// (GET /api/v1/standingsTypes)
	StandingsTypes(ctx echo.Context) error
	// List all stat fields
	// (GET /api/v1/statFields)
	StatFields(ctx echo.Context) error
	// List all stat groups
	// (GET /api/v1/statGroups)
	StatGroups(ctx echo.Context) error
	// List all stat types
	// (GET /api/v1/statTypes)
	StatTypes(ctx echo.Context) error
	// List all statcast position types
	// (GET /api/v1/statcastPositionTypes)
	StatcastPositionTypes(ctx echo.Context) error
	// View stats
	// (GET /api/v1/stats)
	Stats2(ctx echo.Context, params Stats2Params) error
	// Get outs above average for the current batter
	// (GET /api/v1/stats/analytics/outsAboveAverage)
	GetOutsAboveAverage(ctx echo.Context, params GetOutsAboveAverageParams) error
	// Get the spray chart info for the current batter
	// (GET /api/v1/stats/analytics/sprayChart)
	GetSprayChart(ctx echo.Context, params GetSprayChartParams) error
	// Get the probability of a hit for the given hit data
	// (GET /api/v1/stats/analytics/stolenBaseProbability)
	GetStolenBaseProbability(ctx echo.Context, params GetStolenBaseProbabilityParams) error
	// View grouped stats
	// (GET /api/v1/stats/grouped)
	GroupedStats(ctx echo.Context, params GroupedStatsParams) error
	// Get leaders for a statistic
	// (GET /api/v1/stats/leaders)
	Leaders2(ctx echo.Context, params Leaders2Params) error
	// View metric stats
	// (GET /api/v1/stats/metrics)
	MetricStats(ctx echo.Context, params MetricStatsParams) error
	// View stats from search
	// (GET /api/v1/stats/search)
	BeastStats(ctx echo.Context, params BeastStatsParams) error
	// Stats Search Config Endpoint
	// (GET /api/v1/stats/search/config)
	StatSearchConfig(ctx echo.Context, params StatSearchConfigParams) error
	// List groupBy types
	// (GET /api/v1/stats/search/groupByTypes)
	StatSearchGroupByTypes(ctx echo.Context, params StatSearchGroupByTypesParams) error
	// List stat search parameters
	// (GET /api/v1/stats/search/params)
	StatSearchParams(ctx echo.Context, params StatSearchParamsParams) error
	// List stat search stats
	// (GET /api/v1/stats/search/stats)
	StatSearchStats(ctx echo.Context, params StatSearchStatsParams) error
	// View streaks
	// (GET /api/v1/streaks)
	GetStreaks(ctx echo.Context, params GetStreaksParams) error
	// View streaks parameter options
	// (GET /api/v1/streaks/types)
	StreakTypes(ctx echo.Context) error
	// View info for all teams
	// (GET /api/v1/teams)
	Teams(ctx echo.Context, params TeamsParams) error
	// View team and affiliate teams
	// (GET /api/v1/teams/affiliates)
	Affiliates1(ctx echo.Context, params Affiliates1Params) error
	// View historical records for a list of teams
	// (GET /api/v1/teams/history)
	AllTeams1(ctx echo.Context, params AllTeams1Params) error
	// View a teams stats
	// (GET /api/v1/teams/stats)
	Stats1(ctx echo.Context, params Stats1Params) error
	// View leaders for team stats
	// (GET /api/v1/teams/stats/leaders)
	Leaders1(ctx echo.Context, params Leaders1Params) error
	// View info for all teams
	// (GET /api/v1/teams/{teamId})
	Teams1(ctx echo.Context, teamId int32, params Teams1Params) error
	// View team and affiliate teams
	// (GET /api/v1/teams/{teamId}/affiliates)
	Affiliates(ctx echo.Context, teamId int32, params AffiliatesParams) error
	// View all team alumni
	// (GET /api/v1/teams/{teamId}/alumni)
	Alumni(ctx echo.Context, teamId int32, params AlumniParams) error

	// (POST /api/v1/teams/{teamId}/alumni)
	UpdateAlumni(ctx echo.Context, teamId int32, params UpdateAlumniParams) error
	// View all coaches for a team
	// (GET /api/v1/teams/{teamId}/coaches)
	Coaches(ctx echo.Context, teamId int32, params CoachesParams) error
	// View historical records for a list of teams
	// (GET /api/v1/teams/{teamId}/history)
	AllTeams(ctx echo.Context, teamId int32, params AllTeamsParams) error
	// View team stat leaders
	// (GET /api/v1/teams/{teamId}/leaders)
	Leaders(ctx echo.Context, teamId int32, params LeadersParams) error
	// View all coaches for a team
	// (GET /api/v1/teams/{teamId}/personnel)
	Personnel(ctx echo.Context, teamId int32, params PersonnelParams) error
	// View a teams roster
	// (GET /api/v1/teams/{teamId}/roster)
	Roster(ctx echo.Context, teamId int32, params RosterParams) error
	// View a teams roster
	// (GET /api/v1/teams/{teamId}/roster/{rosterType})
	Roster1(ctx echo.Context, teamId int32, rosterType string, params Roster1Params) error
	// View a teams stats
	// (GET /api/v1/teams/{teamId}/stats)
	Stats(ctx echo.Context, teamId int32, params StatsParams) error
	// List the tracking software versions and notes
	// (GET /api/v1/trackingSoftwareVersions)
	TrackingSoftwareVersions(ctx echo.Context) error
	// List all tracking system owners
	// (GET /api/v1/trackingSystemOwners)
	TrackingSystemOwners(ctx echo.Context) error
	// List all tracking vendors
	// (GET /api/v1/trackingVendors)
	TrackingVendors(ctx echo.Context) error
	// List all tracking versions
	// (GET /api/v1/trackingVersions)
	TrackingVersions(ctx echo.Context) error
	// List all transaction types
	// (GET /api/v1/transactionTypes)
	TransactionTypes(ctx echo.Context, params TransactionTypesParams) error
	// View transaction info
	// (GET /api/v1/transactions)
	Transactions(ctx echo.Context, params TransactionsParams) error
	// View Game Uniform info
	// (GET /api/v1/uniforms/game)
	UniformsByGame(ctx echo.Context, params UniformsByGameParams) error
	// View Team Uniform info
	// (GET /api/v1/uniforms/team)
	UniformsByTeam(ctx echo.Context, params UniformsByTeamParams) error
	// View venue info
	// (GET /api/v1/venues)
	Venues(ctx echo.Context, params VenuesParams) error
	// View venue info
	// (GET /api/v1/venues/{venueId})
	Venues1(ctx echo.Context, venueId int32, params Venues1Params) error
	// View video resolution options
	// (GET /api/v1/videoResolutionTypes)
	VideoResolutionTypes(ctx echo.Context) error
	// View available violationType options
	// (GET /api/v1/violationTypes)
	ViolationTypes(ctx echo.Context) error
	// Get the weather forecast for a game.
	// (GET /api/v1/weather/game/{gamePk}/forecast/{roofType})
	WeatherForecast(ctx echo.Context, gamePk int32, roofType RoofType, params WeatherForecastParams) error
	// Get the raw field weather data.
	// (GET /api/v1/weather/game/{gamePk}/{playId})
	WeatherDataBasedOnPlay(ctx echo.Context, gamePk int32, playId string, params WeatherDataBasedOnPlayParams) error
	// Get basic weather for a venue.
	// (GET /api/v1/weather/venues/{venueId}/basic)
	WeatherBasic(ctx echo.Context, venueId int32, params WeatherBasicParams) error
	// Get full weather for a venue.
	// (GET /api/v1/weather/venues/{venueId}/full)
	WeatherFull(ctx echo.Context, venueId int32, params WeatherFullParams) error
	// List all weather trajectories
	// (GET /api/v1/weatherTrajectoryConfidences)
	WeatherTrajectoryConfidences(ctx echo.Context) error
	// List all wind direction options
	// (GET /api/v1/windDirection)
	WindDirection(ctx echo.Context, params WindDirectionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// LiveGameV1 converts echo context to params.
func (w *ServerInterfaceWrapper) LiveGameV1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "game_pk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "game_pk", ctx.Param("game_pk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_pk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LiveGameV1Params
	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "inclusiveTimecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "inclusiveTimecode", ctx.QueryParams(), &params.InclusiveTimecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter inclusiveTimecode: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LiveGameV1(ctx, gamePk, params)
	return err
}

// LiveGameDiffPatchV1 converts echo context to params.
func (w *ServerInterfaceWrapper) LiveGameDiffPatchV1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "game_pk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "game_pk", ctx.Param("game_pk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_pk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LiveGameDiffPatchV1Params
	// ------------- Optional query parameter "startTimecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "startTimecode", ctx.QueryParams(), &params.StartTimecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startTimecode: %s", err))
	}

	// ------------- Optional query parameter "endTimecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "endTimecode", ctx.QueryParams(), &params.EndTimecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endTimecode: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LiveGameDiffPatchV1(ctx, gamePk, params)
	return err
}

// LiveTimestampv11 converts echo context to params.
func (w *ServerInterfaceWrapper) LiveTimestampv11(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "game_pk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "game_pk", ctx.Param("game_pk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_pk: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LiveTimestampv11(ctx, gamePk)
	return err
}

// AchievementStatuses converts echo context to params.
func (w *ServerInterfaceWrapper) AchievementStatuses(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AchievementStatuses(ctx)
	return err
}

// GameGuidsFromPostgresRangeByGame converts echo context to params.
func (w *ServerInterfaceWrapper) GameGuidsFromPostgresRangeByGame(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GameGuidsFromPostgresRangeByGameParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "gameModeId" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameModeId", ctx.QueryParams(), &params.GameModeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameModeId: %s", err))
	}

	// ------------- Optional query parameter "isPitch" -------------

	err = runtime.BindQueryParameter("form", true, false, "isPitch", ctx.QueryParams(), &params.IsPitch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isPitch: %s", err))
	}

	// ------------- Optional query parameter "isHit" -------------

	err = runtime.BindQueryParameter("form", true, false, "isHit", ctx.QueryParams(), &params.IsHit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHit: %s", err))
	}

	// ------------- Optional query parameter "isPickoff" -------------

	err = runtime.BindQueryParameter("form", true, false, "isPickoff", ctx.QueryParams(), &params.IsPickoff)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isPickoff: %s", err))
	}

	// ------------- Optional query parameter "isNonStatcast" -------------

	err = runtime.BindQueryParameter("form", true, false, "isNonStatcast", ctx.QueryParams(), &params.IsNonStatcast)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isNonStatcast: %s", err))
	}

	// ------------- Optional query parameter "gamedayType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamedayType", ctx.QueryParams(), &params.GamedayType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamedayType: %s", err))
	}

	// ------------- Optional query parameter "hasUpdates" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasUpdates", ctx.QueryParams(), &params.HasUpdates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hasUpdates: %s", err))
	}

	// ------------- Optional query parameter "lastPlayTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastPlayTime", ctx.QueryParams(), &params.LastPlayTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastPlayTime: %s", err))
	}

	// ------------- Optional query parameter "lastVideoUpdatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastVideoUpdatedTime", ctx.QueryParams(), &params.LastVideoUpdatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastVideoUpdatedTime: %s", err))
	}

	// ------------- Optional query parameter "lastUpdatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastUpdatedTime", ctx.QueryParams(), &params.LastUpdatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastUpdatedTime: %s", err))
	}

	// ------------- Optional query parameter "lastMetricsUpdatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastMetricsUpdatedTime", ctx.QueryParams(), &params.LastMetricsUpdatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastMetricsUpdatedTime: %s", err))
	}

	// ------------- Optional query parameter "lastAuditUpdatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastAuditUpdatedTime", ctx.QueryParams(), &params.LastAuditUpdatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastAuditUpdatedTime: %s", err))
	}

	// ------------- Optional query parameter "gameDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameDate", ctx.QueryParams(), &params.GameDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameDate: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "trackingSystemOwner" -------------

	err = runtime.BindQueryParameter("form", true, false, "trackingSystemOwner", ctx.QueryParams(), &params.TrackingSystemOwner)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter trackingSystemOwner: %s", err))
	}

	// ------------- Optional query parameter "sortBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortBy", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortBy: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "scheduleEventTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduleEventTypes", ctx.QueryParams(), &params.ScheduleEventTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduleEventTypes: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GameGuidsFromPostgresRangeByGame(ctx, params)
	return err
}

// GameGuidsFromPostgresRange converts echo context to params.
func (w *ServerInterfaceWrapper) GameGuidsFromPostgresRange(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GameGuidsFromPostgresRangeParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "gameModeId" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameModeId", ctx.QueryParams(), &params.GameModeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameModeId: %s", err))
	}

	// ------------- Optional query parameter "isPitch" -------------

	err = runtime.BindQueryParameter("form", true, false, "isPitch", ctx.QueryParams(), &params.IsPitch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isPitch: %s", err))
	}

	// ------------- Optional query parameter "isHit" -------------

	err = runtime.BindQueryParameter("form", true, false, "isHit", ctx.QueryParams(), &params.IsHit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHit: %s", err))
	}

	// ------------- Optional query parameter "isPickoff" -------------

	err = runtime.BindQueryParameter("form", true, false, "isPickoff", ctx.QueryParams(), &params.IsPickoff)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isPickoff: %s", err))
	}

	// ------------- Optional query parameter "isNonStatcast" -------------

	err = runtime.BindQueryParameter("form", true, false, "isNonStatcast", ctx.QueryParams(), &params.IsNonStatcast)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isNonStatcast: %s", err))
	}

	// ------------- Optional query parameter "gamedayType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamedayType", ctx.QueryParams(), &params.GamedayType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamedayType: %s", err))
	}

	// ------------- Optional query parameter "hasUpdates" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasUpdates", ctx.QueryParams(), &params.HasUpdates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hasUpdates: %s", err))
	}

	// ------------- Optional query parameter "lastPlayTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastPlayTime", ctx.QueryParams(), &params.LastPlayTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastPlayTime: %s", err))
	}

	// ------------- Optional query parameter "lastUpdatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastUpdatedTime", ctx.QueryParams(), &params.LastUpdatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastUpdatedTime: %s", err))
	}

	// ------------- Optional query parameter "lastMetricsUpdatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastMetricsUpdatedTime", ctx.QueryParams(), &params.LastMetricsUpdatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastMetricsUpdatedTime: %s", err))
	}

	// ------------- Optional query parameter "lastAuditUpdatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastAuditUpdatedTime", ctx.QueryParams(), &params.LastAuditUpdatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastAuditUpdatedTime: %s", err))
	}

	// ------------- Optional query parameter "lastVideoUpdatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastVideoUpdatedTime", ctx.QueryParams(), &params.LastVideoUpdatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastVideoUpdatedTime: %s", err))
	}

	// ------------- Optional query parameter "gameDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameDate", ctx.QueryParams(), &params.GameDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameDate: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "trackingSystemOwner" -------------

	err = runtime.BindQueryParameter("form", true, false, "trackingSystemOwner", ctx.QueryParams(), &params.TrackingSystemOwner)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter trackingSystemOwner: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "sortBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortBy", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortBy: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GameGuidsFromPostgresRange(ctx, params)
	return err
}

// GetTeamAttendance converts echo context to params.
func (w *ServerInterfaceWrapper) GetTeamAttendance(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTeamAttendanceParams
	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "leagueListId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueListId", ctx.QueryParams(), &params.LeagueListId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueListId: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTeamAttendance(ctx, params)
	return err
}

// Awards converts echo context to params.
func (w *ServerInterfaceWrapper) Awards(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AwardsParams
	// ------------- Optional query parameter "orgId" -------------

	err = runtime.BindQueryParameter("form", true, false, "orgId", ctx.QueryParams(), &params.OrgId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orgId: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Awards(ctx, params)
	return err
}

// Awards1 converts echo context to params.
func (w *ServerInterfaceWrapper) Awards1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "awardId" -------------
	var awardId string

	err = runtime.BindStyledParameterWithOptions("simple", "awardId", ctx.Param("awardId"), &awardId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter awardId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params Awards1Params
	// ------------- Optional query parameter "orgId" -------------

	err = runtime.BindQueryParameter("form", true, false, "orgId", ctx.QueryParams(), &params.OrgId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orgId: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Awards1(ctx, awardId, params)
	return err
}

// AwardRecipients converts echo context to params.
func (w *ServerInterfaceWrapper) AwardRecipients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "awardId" -------------
	var awardId string

	err = runtime.BindStyledParameterWithOptions("simple", "awardId", ctx.Param("awardId"), &awardId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter awardId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AwardRecipientsParams
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AwardRecipients(ctx, awardId, params)
	return err
}

// BaseballStats converts echo context to params.
func (w *ServerInterfaceWrapper) BaseballStats(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BaseballStats(ctx)
	return err
}

// BatTracking converts echo context to params.
func (w *ServerInterfaceWrapper) BatTracking(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Path parameter "playId" -------------
	var playId string

	err = runtime.BindStyledParameterWithOptions("simple", "playId", ctx.Param("playId"), &playId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BatTrackingParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BatTracking(ctx, gamePk, playId, params)
	return err
}

// GetBroadcasts converts echo context to params.
func (w *ServerInterfaceWrapper) GetBroadcasts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBroadcastsParams
	// ------------- Required query parameter "broadcasterIds" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcasterIds", ctx.QueryParams(), &params.BroadcasterIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcasterIds: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBroadcasts(ctx, params)
	return err
}

// BroadcastAvailabilityTypes converts echo context to params.
func (w *ServerInterfaceWrapper) BroadcastAvailabilityTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BroadcastAvailabilityTypes(ctx)
	return err
}

// GetAllBroadcasters converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllBroadcasters(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllBroadcastersParams
	// ------------- Optional query parameter "activeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "activeStatus", ctx.QueryParams(), &params.ActiveStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter activeStatus: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllBroadcasters(ctx, params)
	return err
}

// CoachingVideoTypes converts echo context to params.
func (w *ServerInterfaceWrapper) CoachingVideoTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CoachingVideoTypes(ctx)
	return err
}

// Conferences converts echo context to params.
func (w *ServerInterfaceWrapper) Conferences(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ConferencesParams
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "includeInactive" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeInactive", ctx.QueryParams(), &params.IncludeInactive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeInactive: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Conferences(ctx, params)
	return err
}

// Conferences1 converts echo context to params.
func (w *ServerInterfaceWrapper) Conferences1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "conferenceId" -------------
	var conferenceId int32

	err = runtime.BindStyledParameterWithOptions("simple", "conferenceId", ctx.Param("conferenceId"), &conferenceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter conferenceId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params Conferences1Params
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "includeInactive" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeInactive", ctx.QueryParams(), &params.IncludeInactive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeInactive: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Conferences1(ctx, conferenceId, params)
	return err
}

// Divisions converts echo context to params.
func (w *ServerInterfaceWrapper) Divisions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DivisionsParams
	// ------------- Optional query parameter "includeInactive" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeInactive", ctx.QueryParams(), &params.IncludeInactive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeInactive: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Divisions(ctx, params)
	return err
}

// Divisions1 converts echo context to params.
func (w *ServerInterfaceWrapper) Divisions1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "divisionId" -------------
	var divisionId int32

	err = runtime.BindStyledParameterWithOptions("simple", "divisionId", ctx.Param("divisionId"), &divisionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter divisionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params Divisions1Params
	// ------------- Optional query parameter "includeInactive" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeInactive", ctx.QueryParams(), &params.IncludeInactive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeInactive: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Divisions1(ctx, divisionId, params)
	return err
}

// DraftPicks converts echo context to params.
func (w *ServerInterfaceWrapper) DraftPicks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DraftPicksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "sortBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortBy", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortBy: %s", err))
	}

	// ------------- Optional query parameter "drafted" -------------

	err = runtime.BindQueryParameter("form", true, false, "drafted", ctx.QueryParams(), &params.Drafted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter drafted: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "school" -------------

	err = runtime.BindQueryParameter("form", true, false, "school", ctx.QueryParams(), &params.School)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter school: %s", err))
	}

	// ------------- Optional query parameter "position" -------------

	err = runtime.BindQueryParameter("form", true, false, "position", ctx.QueryParams(), &params.Position)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter position: %s", err))
	}

	// ------------- Optional query parameter "team" -------------

	err = runtime.BindQueryParameter("form", true, false, "team", ctx.QueryParams(), &params.Team)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter team: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// ------------- Optional query parameter "country" -------------

	err = runtime.BindQueryParameter("form", true, false, "country", ctx.QueryParams(), &params.Country)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter country: %s", err))
	}

	// ------------- Optional query parameter "playerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerId", ctx.QueryParams(), &params.PlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerId: %s", err))
	}

	// ------------- Optional query parameter "bisPlayerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "bisPlayerId", ctx.QueryParams(), &params.BisPlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bisPlayerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DraftPicks(ctx, params)
	return err
}

// DraftProspects converts echo context to params.
func (w *ServerInterfaceWrapper) DraftProspects(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DraftProspectsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "sortBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortBy", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortBy: %s", err))
	}

	// ------------- Optional query parameter "drafted" -------------

	err = runtime.BindQueryParameter("form", true, false, "drafted", ctx.QueryParams(), &params.Drafted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter drafted: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "school" -------------

	err = runtime.BindQueryParameter("form", true, false, "school", ctx.QueryParams(), &params.School)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter school: %s", err))
	}

	// ------------- Optional query parameter "position" -------------

	err = runtime.BindQueryParameter("form", true, false, "position", ctx.QueryParams(), &params.Position)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter position: %s", err))
	}

	// ------------- Optional query parameter "team" -------------

	err = runtime.BindQueryParameter("form", true, false, "team", ctx.QueryParams(), &params.Team)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter team: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// ------------- Optional query parameter "country" -------------

	err = runtime.BindQueryParameter("form", true, false, "country", ctx.QueryParams(), &params.Country)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter country: %s", err))
	}

	// ------------- Optional query parameter "playerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerId", ctx.QueryParams(), &params.PlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerId: %s", err))
	}

	// ------------- Optional query parameter "bisPlayerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "bisPlayerId", ctx.QueryParams(), &params.BisPlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bisPlayerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DraftProspects(ctx, params)
	return err
}

// DraftProspects1 converts echo context to params.
func (w *ServerInterfaceWrapper) DraftProspects1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "year" -------------
	var year int32

	err = runtime.BindStyledParameterWithOptions("simple", "year", ctx.Param("year"), &year, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter year: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DraftProspects1Params
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "sortBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortBy", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortBy: %s", err))
	}

	// ------------- Optional query parameter "drafted" -------------

	err = runtime.BindQueryParameter("form", true, false, "drafted", ctx.QueryParams(), &params.Drafted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter drafted: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "school" -------------

	err = runtime.BindQueryParameter("form", true, false, "school", ctx.QueryParams(), &params.School)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter school: %s", err))
	}

	// ------------- Optional query parameter "position" -------------

	err = runtime.BindQueryParameter("form", true, false, "position", ctx.QueryParams(), &params.Position)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter position: %s", err))
	}

	// ------------- Optional query parameter "team" -------------

	err = runtime.BindQueryParameter("form", true, false, "team", ctx.QueryParams(), &params.Team)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter team: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// ------------- Optional query parameter "country" -------------

	err = runtime.BindQueryParameter("form", true, false, "country", ctx.QueryParams(), &params.Country)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter country: %s", err))
	}

	// ------------- Optional query parameter "playerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerId", ctx.QueryParams(), &params.PlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerId: %s", err))
	}

	// ------------- Optional query parameter "bisPlayerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "bisPlayerId", ctx.QueryParams(), &params.BisPlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bisPlayerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DraftProspects1(ctx, year, params)
	return err
}

// DraftPicks1 converts echo context to params.
func (w *ServerInterfaceWrapper) DraftPicks1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "year" -------------
	var year int32

	err = runtime.BindStyledParameterWithOptions("simple", "year", ctx.Param("year"), &year, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter year: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DraftPicks1Params
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "sortBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortBy", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortBy: %s", err))
	}

	// ------------- Optional query parameter "drafted" -------------

	err = runtime.BindQueryParameter("form", true, false, "drafted", ctx.QueryParams(), &params.Drafted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter drafted: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "school" -------------

	err = runtime.BindQueryParameter("form", true, false, "school", ctx.QueryParams(), &params.School)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter school: %s", err))
	}

	// ------------- Optional query parameter "position" -------------

	err = runtime.BindQueryParameter("form", true, false, "position", ctx.QueryParams(), &params.Position)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter position: %s", err))
	}

	// ------------- Optional query parameter "team" -------------

	err = runtime.BindQueryParameter("form", true, false, "team", ctx.QueryParams(), &params.Team)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter team: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// ------------- Optional query parameter "country" -------------

	err = runtime.BindQueryParameter("form", true, false, "country", ctx.QueryParams(), &params.Country)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter country: %s", err))
	}

	// ------------- Optional query parameter "playerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerId", ctx.QueryParams(), &params.PlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerId: %s", err))
	}

	// ------------- Optional query parameter "bisPlayerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "bisPlayerId", ctx.QueryParams(), &params.BisPlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bisPlayerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DraftPicks1(ctx, year, params)
	return err
}

// LatestDraftPicks converts echo context to params.
func (w *ServerInterfaceWrapper) LatestDraftPicks(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "year" -------------
	var year int32

	err = runtime.BindStyledParameterWithOptions("simple", "year", ctx.Param("year"), &year, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter year: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LatestDraftPicksParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LatestDraftPicks(ctx, year, params)
	return err
}

// EventStatus converts echo context to params.
func (w *ServerInterfaceWrapper) EventStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EventStatus(ctx)
	return err
}

// EventTypes converts echo context to params.
func (w *ServerInterfaceWrapper) EventTypes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params EventTypesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EventTypes(ctx, params)
	return err
}

// FielderDetailTypes converts echo context to params.
func (w *ServerInterfaceWrapper) FielderDetailTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FielderDetailTypes(ctx)
	return err
}

// FreeGameTypes converts echo context to params.
func (w *ServerInterfaceWrapper) FreeGameTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FreeGameTypes(ctx)
	return err
}

// CurrentGameStats1 converts echo context to params.
func (w *ServerInterfaceWrapper) CurrentGameStats1(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CurrentGameStats1Params
	// ------------- Optional query parameter "updatedSince" -------------

	err = runtime.BindQueryParameter("form", true, false, "updatedSince", ctx.QueryParams(), &params.UpdatedSince)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updatedSince: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "sportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportIds", ctx.QueryParams(), &params.SportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportIds: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "gameTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameTypes", ctx.QueryParams(), &params.GameTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameTypes: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "gamePks" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamePks", ctx.QueryParams(), &params.GamePks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePks: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CurrentGameStats1(ctx, params)
	return err
}

// GameLastPitch converts echo context to params.
func (w *ServerInterfaceWrapper) GameLastPitch(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GameLastPitchParams
	// ------------- Required query parameter "gamePks" -------------

	err = runtime.BindQueryParameter("form", true, true, "gamePks", ctx.QueryParams(), &params.GamePks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePks: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GameLastPitch(ctx, params)
	return err
}

// GetGameContextMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameContextMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameContextMetricsParams
	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameContextMetrics(ctx, gamePk, params)
	return err
}

// GameGuids converts echo context to params.
func (w *ServerInterfaceWrapper) GameGuids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GameGuidsParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "gameModeId" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameModeId", ctx.QueryParams(), &params.GameModeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameModeId: %s", err))
	}

	// ------------- Optional query parameter "isPitch" -------------

	err = runtime.BindQueryParameter("form", true, false, "isPitch", ctx.QueryParams(), &params.IsPitch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isPitch: %s", err))
	}

	// ------------- Optional query parameter "isHit" -------------

	err = runtime.BindQueryParameter("form", true, false, "isHit", ctx.QueryParams(), &params.IsHit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHit: %s", err))
	}

	// ------------- Optional query parameter "isPickoff" -------------

	err = runtime.BindQueryParameter("form", true, false, "isPickoff", ctx.QueryParams(), &params.IsPickoff)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isPickoff: %s", err))
	}

	// ------------- Optional query parameter "hasUpdates" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasUpdates", ctx.QueryParams(), &params.HasUpdates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hasUpdates: %s", err))
	}

	// ------------- Optional query parameter "since" -------------

	err = runtime.BindQueryParameter("form", true, false, "since", ctx.QueryParams(), &params.Since)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since: %s", err))
	}

	// ------------- Optional query parameter "updatedSince" -------------

	err = runtime.BindQueryParameter("form", true, false, "updatedSince", ctx.QueryParams(), &params.UpdatedSince)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updatedSince: %s", err))
	}

	// ------------- Optional query parameter "lastPlayTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastPlayTime", ctx.QueryParams(), &params.LastPlayTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastPlayTime: %s", err))
	}

	// ------------- Optional query parameter "lastUpdatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastUpdatedTime", ctx.QueryParams(), &params.LastUpdatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastUpdatedTime: %s", err))
	}

	// ------------- Optional query parameter "lastMetricsUpdatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastMetricsUpdatedTime", ctx.QueryParams(), &params.LastMetricsUpdatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastMetricsUpdatedTime: %s", err))
	}

	// ------------- Optional query parameter "lastAuditUpdatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastAuditUpdatedTime", ctx.QueryParams(), &params.LastAuditUpdatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastAuditUpdatedTime: %s", err))
	}

	// ------------- Optional query parameter "lastVideoUpdatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastVideoUpdatedTime", ctx.QueryParams(), &params.LastVideoUpdatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastVideoUpdatedTime: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GameGuids(ctx, gamePk, params)
	return err
}

// GetWinProbability converts echo context to params.
func (w *ServerInterfaceWrapper) GetWinProbability(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWinProbabilityParams
	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "inclusiveTimecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "inclusiveTimecode", ctx.QueryParams(), &params.InclusiveTimecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter inclusiveTimecode: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWinProbability(ctx, gamePk, params)
	return err
}

// GetGameWithMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameWithMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameWithMetricsParams
	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// ------------- Optional query parameter "inclusiveTimecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "inclusiveTimecode", ctx.QueryParams(), &params.InclusiveTimecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter inclusiveTimecode: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameWithMetrics(ctx, gamePk, params)
	return err
}

// ParsedJsonFormattedAnalytics converts echo context to params.
func (w *ServerInterfaceWrapper) ParsedJsonFormattedAnalytics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Path parameter "guid" -------------
	var guid string

	err = runtime.BindStyledParameterWithOptions("simple", "guid", ctx.Param("guid"), &guid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ParsedJsonFormattedAnalyticsParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ParsedJsonFormattedAnalytics(ctx, gamePk, guid, params)
	return err
}

// ContextMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) ContextMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Path parameter "guid" -------------
	var guid string

	err = runtime.BindStyledParameterWithOptions("simple", "guid", ctx.Param("guid"), &guid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContextMetricsParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ContextMetrics(ctx, gamePk, guid, params)
	return err
}

// ContextMetricsWithAverages converts echo context to params.
func (w *ServerInterfaceWrapper) ContextMetricsWithAverages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Path parameter "guid" -------------
	var guid string

	err = runtime.BindStyledParameterWithOptions("simple", "guid", ctx.Param("guid"), &guid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContextMetricsWithAveragesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ContextMetricsWithAverages(ctx, gamePk, guid, params)
	return err
}

// ContextMetricsWithAveragesPost converts echo context to params.
func (w *ServerInterfaceWrapper) ContextMetricsWithAveragesPost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Path parameter "guid" -------------
	var guid string

	err = runtime.BindStyledParameterWithOptions("simple", "guid", ctx.Param("guid"), &guid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContextMetricsWithAveragesPostParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ContextMetricsWithAveragesPost(ctx, gamePk, guid, params)
	return err
}

// HomeRunBallparks converts echo context to params.
func (w *ServerInterfaceWrapper) HomeRunBallparks(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Path parameter "guid" -------------
	var guid string

	err = runtime.BindStyledParameterWithOptions("simple", "guid", ctx.Param("guid"), &guid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params HomeRunBallparksParams
	// ------------- Required query parameter "isHomeRunParks" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHomeRunParks", ctx.QueryParams(), &params.IsHomeRunParks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHomeRunParks: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HomeRunBallparks(ctx, gamePk, guid, params)
	return err
}

// Biomechanical converts echo context to params.
func (w *ServerInterfaceWrapper) Biomechanical(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Path parameter "playId" -------------
	var playId string

	err = runtime.BindStyledParameterWithOptions("simple", "playId", ctx.Param("playId"), &playId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playId: %s", err))
	}

	// ------------- Path parameter "positionId" -------------
	var positionId int32

	err = runtime.BindStyledParameterWithOptions("simple", "positionId", ctx.Param("positionId"), &positionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter positionId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BiomechanicalParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Biomechanical(ctx, gamePk, playId, positionId, params)
	return err
}

// SkeletalChunked converts echo context to params.
func (w *ServerInterfaceWrapper) SkeletalChunked(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Path parameter "playId" -------------
	var playId string

	err = runtime.BindStyledParameterWithOptions("simple", "playId", ctx.Param("playId"), &playId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SkeletalChunkedParams
	// ------------- Required query parameter "fileName" -------------

	err = runtime.BindQueryParameter("form", true, true, "fileName", ctx.QueryParams(), &params.FileName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fileName: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SkeletalChunked(ctx, gamePk, playId, params)
	return err
}

// SkeletalDataFileNames converts echo context to params.
func (w *ServerInterfaceWrapper) SkeletalDataFileNames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Path parameter "playId" -------------
	var playId string

	err = runtime.BindStyledParameterWithOptions("simple", "playId", ctx.Param("playId"), &playId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SkeletalDataFileNamesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SkeletalDataFileNames(ctx, gamePk, playId, params)
	return err
}

// Boxscore converts echo context to params.
func (w *ServerInterfaceWrapper) Boxscore(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "game_pk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "game_pk", ctx.Param("game_pk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_pk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params BoxscoreParams
	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "inclusiveTimecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "inclusiveTimecode", ctx.QueryParams(), &params.InclusiveTimecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter inclusiveTimecode: %s", err))
	}

	// ------------- Optional query parameter "numPlayers" -------------

	err = runtime.BindQueryParameter("form", true, false, "numPlayers", ctx.QueryParams(), &params.NumPlayers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter numPlayers: %s", err))
	}

	// ------------- Optional query parameter "noTies" -------------

	err = runtime.BindQueryParameter("form", true, false, "noTies", ctx.QueryParams(), &params.NoTies)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter noTies: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Boxscore(ctx, gamePk, params)
	return err
}

// Content converts echo context to params.
func (w *ServerInterfaceWrapper) Content(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "game_pk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "game_pk", ctx.Param("game_pk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_pk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ContentParams
	// ------------- Optional query parameter "highlightLimit" -------------

	err = runtime.BindQueryParameter("form", true, false, "highlightLimit", ctx.QueryParams(), &params.HighlightLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter highlightLimit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Content(ctx, gamePk, params)
	return err
}

// ColorFeed converts echo context to params.
func (w *ServerInterfaceWrapper) ColorFeed(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "game_pk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "game_pk", ctx.Param("game_pk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_pk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ColorFeedParams
	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ColorFeed(ctx, gamePk, params)
	return err
}

// ColorTimestamps converts echo context to params.
func (w *ServerInterfaceWrapper) ColorTimestamps(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "game_pk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "game_pk", ctx.Param("game_pk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_pk: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ColorTimestamps(ctx, gamePk)
	return err
}

// Linescore converts echo context to params.
func (w *ServerInterfaceWrapper) Linescore(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "game_pk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "game_pk", ctx.Param("game_pk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_pk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LinescoreParams
	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "inclusiveTimecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "inclusiveTimecode", ctx.QueryParams(), &params.InclusiveTimecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter inclusiveTimecode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Linescore(ctx, gamePk, params)
	return err
}

// PlayByPlay converts echo context to params.
func (w *ServerInterfaceWrapper) PlayByPlay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "game_pk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "game_pk", ctx.Param("game_pk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_pk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PlayByPlayParams
	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "inclusiveTimecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "inclusiveTimecode", ctx.QueryParams(), &params.InclusiveTimecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter inclusiveTimecode: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PlayByPlay(ctx, gamePk, params)
	return err
}

// GamePace converts echo context to params.
func (w *ServerInterfaceWrapper) GamePace(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GamePaceParams
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "teamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamIds", ctx.QueryParams(), &params.TeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamIds: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "leagueListId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueListId", ctx.QueryParams(), &params.LeagueListId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueListId: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "sportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportIds", ctx.QueryParams(), &params.SportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportIds: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "venueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "venueIds", ctx.QueryParams(), &params.VenueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter venueIds: %s", err))
	}

	// ------------- Optional query parameter "excludeVenueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "excludeVenueIds", ctx.QueryParams(), &params.ExcludeVenueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excludeVenueIds: %s", err))
	}

	// ------------- Optional query parameter "excludeGamePks" -------------

	err = runtime.BindQueryParameter("form", true, false, "excludeGamePks", ctx.QueryParams(), &params.ExcludeGamePks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excludeGamePks: %s", err))
	}

	// ------------- Optional query parameter "orgType" -------------

	err = runtime.BindQueryParameter("form", true, false, "orgType", ctx.QueryParams(), &params.OrgType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orgType: %s", err))
	}

	// ------------- Optional query parameter "includeChildren" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeChildren", ctx.QueryParams(), &params.IncludeChildren)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeChildren: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GamePace(ctx, params)
	return err
}

// GameStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GameStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GameStatus(ctx)
	return err
}

// UpdateGameStatuses converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateGameStatuses(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateGameStatuses(ctx)
	return err
}

// GameTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GameTypes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GameTypesParams
	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GameTypes(ctx, params)
	return err
}

// GamedayTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GamedayTypes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GamedayTypesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GamedayTypes(ctx, params)
	return err
}

// GroupByTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GroupByTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GroupByTypes(ctx)
	return err
}

// HighLowStats converts echo context to params.
func (w *ServerInterfaceWrapper) HighLowStats(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HighLowStats(ctx)
	return err
}

// HighLow converts echo context to params.
func (w *ServerInterfaceWrapper) HighLow(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "highLowType" -------------
	var highLowType HighLowTypeEnum

	err = runtime.BindStyledParameterWithOptions("simple", "highLowType", ctx.Param("highLowType"), &highLowType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter highLowType: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params HighLowParams
	// ------------- Optional query parameter "statGroup" -------------

	err = runtime.BindQueryParameter("form", true, false, "statGroup", ctx.QueryParams(), &params.StatGroup)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statGroup: %s", err))
	}

	// ------------- Optional query parameter "sortStat" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortStat", ctx.QueryParams(), &params.SortStat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortStat: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HighLow(ctx, highLowType, params)
	return err
}

// HitTrajectories converts echo context to params.
func (w *ServerInterfaceWrapper) HitTrajectories(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params HitTrajectoriesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HitTrajectories(ctx, params)
	return err
}

// HomeRunDerbyBracket1 converts echo context to params.
func (w *ServerInterfaceWrapper) HomeRunDerbyBracket1(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params HomeRunDerbyBracket1Params
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HomeRunDerbyBracket1(ctx, params)
	return err
}

// HomeRunDerbyBracket3 converts echo context to params.
func (w *ServerInterfaceWrapper) HomeRunDerbyBracket3(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params HomeRunDerbyBracket3Params
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HomeRunDerbyBracket3(ctx, params)
	return err
}

// HomeRunDerbyMixedMode1 converts echo context to params.
func (w *ServerInterfaceWrapper) HomeRunDerbyMixedMode1(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params HomeRunDerbyMixedMode1Params
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HomeRunDerbyMixedMode1(ctx, params)
	return err
}

// HomeRunDerbyPool1 converts echo context to params.
func (w *ServerInterfaceWrapper) HomeRunDerbyPool1(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params HomeRunDerbyPool1Params
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HomeRunDerbyPool1(ctx, params)
	return err
}

// HomeRunDerbyBracket converts echo context to params.
func (w *ServerInterfaceWrapper) HomeRunDerbyBracket(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params HomeRunDerbyBracketParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HomeRunDerbyBracket(ctx, gamePk, params)
	return err
}

// HomeRunDerbyBracket2 converts echo context to params.
func (w *ServerInterfaceWrapper) HomeRunDerbyBracket2(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params HomeRunDerbyBracket2Params
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HomeRunDerbyBracket2(ctx, gamePk, params)
	return err
}

// HomeRunDerbyMixedMode converts echo context to params.
func (w *ServerInterfaceWrapper) HomeRunDerbyMixedMode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params HomeRunDerbyMixedModeParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HomeRunDerbyMixedMode(ctx, gamePk, params)
	return err
}

// HomeRunDerbyPool converts echo context to params.
func (w *ServerInterfaceWrapper) HomeRunDerbyPool(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params HomeRunDerbyPoolParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HomeRunDerbyPool(ctx, gamePk, params)
	return err
}

// JobTypes converts echo context to params.
func (w *ServerInterfaceWrapper) JobTypes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params JobTypesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.JobTypes(ctx, params)
	return err
}

// UpdateJobTypes converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateJobTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateJobTypes(ctx)
	return err
}

// GetJobsByType converts echo context to params.
func (w *ServerInterfaceWrapper) GetJobsByType(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetJobsByTypeParams
	// ------------- Required query parameter "jobType" -------------

	err = runtime.BindQueryParameter("form", true, true, "jobType", ctx.QueryParams(), &params.JobType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jobType: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetJobsByType(ctx, params)
	return err
}

// Datacasters converts echo context to params.
func (w *ServerInterfaceWrapper) Datacasters(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DatacastersParams
	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Datacasters(ctx, params)
	return err
}

// OfficialScorers converts echo context to params.
func (w *ServerInterfaceWrapper) OfficialScorers(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params OfficialScorersParams
	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OfficialScorers(ctx, params)
	return err
}

// Umpires converts echo context to params.
func (w *ServerInterfaceWrapper) Umpires(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UmpiresParams
	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Umpires(ctx, params)
	return err
}

// UmpireSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) UmpireSchedule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "umpireId" -------------
	var umpireId int32

	err = runtime.BindStyledParameterWithOptions("simple", "umpireId", ctx.Param("umpireId"), &umpireId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter umpireId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UmpireScheduleParams
	// ------------- Required query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, true, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UmpireSchedule(ctx, umpireId, params)
	return err
}

// Languages converts echo context to params.
func (w *ServerInterfaceWrapper) Languages(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Languages(ctx)
	return err
}

// League converts echo context to params.
func (w *ServerInterfaceWrapper) League(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params LeagueParams
	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "activeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "activeStatus", ctx.QueryParams(), &params.ActiveStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter activeStatus: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.League(ctx, params)
	return err
}

// AllStarBallot converts echo context to params.
func (w *ServerInterfaceWrapper) AllStarBallot(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AllStarBallotParams
	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AllStarBallot(ctx, params)
	return err
}

// League1 converts echo context to params.
func (w *ServerInterfaceWrapper) League1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "leagueId" -------------
	var leagueId int32

	err = runtime.BindStyledParameterWithOptions("simple", "leagueId", ctx.Param("leagueId"), &leagueId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params League1Params
	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "activeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "activeStatus", ctx.QueryParams(), &params.ActiveStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter activeStatus: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.League1(ctx, leagueId, params)
	return err
}

// AllStarBallot1 converts echo context to params.
func (w *ServerInterfaceWrapper) AllStarBallot1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "leagueId" -------------
	var leagueId int32

	err = runtime.BindStyledParameterWithOptions("simple", "leagueId", ctx.Param("leagueId"), &leagueId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AllStarBallot1Params
	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AllStarBallot1(ctx, leagueId, params)
	return err
}

// AllStarFinalVote converts echo context to params.
func (w *ServerInterfaceWrapper) AllStarFinalVote(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "leagueId" -------------
	var leagueId int32

	err = runtime.BindStyledParameterWithOptions("simple", "leagueId", ctx.Param("leagueId"), &leagueId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AllStarFinalVoteParams
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AllStarFinalVote(ctx, leagueId, params)
	return err
}

// AllStarWriteIns converts echo context to params.
func (w *ServerInterfaceWrapper) AllStarWriteIns(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "leagueId" -------------
	var leagueId int32

	err = runtime.BindStyledParameterWithOptions("simple", "leagueId", ctx.Param("leagueId"), &leagueId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AllStarWriteInsParams
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AllStarWriteIns(ctx, leagueId, params)
	return err
}

// LeagueLeaderTypes converts echo context to params.
func (w *ServerInterfaceWrapper) LeagueLeaderTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LeagueLeaderTypes(ctx)
	return err
}

// League2 converts echo context to params.
func (w *ServerInterfaceWrapper) League2(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params League2Params
	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "activeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "activeStatus", ctx.QueryParams(), &params.ActiveStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter activeStatus: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.League2(ctx, params)
	return err
}

// AllStarBallot2 converts echo context to params.
func (w *ServerInterfaceWrapper) AllStarBallot2(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AllStarBallot2Params
	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AllStarBallot2(ctx, params)
	return err
}

// League3 converts echo context to params.
func (w *ServerInterfaceWrapper) League3(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "leagueId" -------------
	var leagueId int32

	err = runtime.BindStyledParameterWithOptions("simple", "leagueId", ctx.Param("leagueId"), &leagueId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params League3Params
	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "activeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "activeStatus", ctx.QueryParams(), &params.ActiveStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter activeStatus: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.League3(ctx, leagueId, params)
	return err
}

// AllStarBallot3 converts echo context to params.
func (w *ServerInterfaceWrapper) AllStarBallot3(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "leagueId" -------------
	var leagueId int32

	err = runtime.BindStyledParameterWithOptions("simple", "leagueId", ctx.Param("leagueId"), &leagueId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AllStarBallot3Params
	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AllStarBallot3(ctx, leagueId, params)
	return err
}

// AllStarFinalVote1 converts echo context to params.
func (w *ServerInterfaceWrapper) AllStarFinalVote1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "leagueId" -------------
	var leagueId int32

	err = runtime.BindStyledParameterWithOptions("simple", "leagueId", ctx.Param("leagueId"), &leagueId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AllStarFinalVote1Params
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AllStarFinalVote1(ctx, leagueId, params)
	return err
}

// AllStarWriteIns1 converts echo context to params.
func (w *ServerInterfaceWrapper) AllStarWriteIns1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "leagueId" -------------
	var leagueId int32

	err = runtime.BindStyledParameterWithOptions("simple", "leagueId", ctx.Param("leagueId"), &leagueId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AllStarWriteIns1Params
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AllStarWriteIns1(ctx, leagueId, params)
	return err
}

// LogicalEvents converts echo context to params.
func (w *ServerInterfaceWrapper) LogicalEvents(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params LogicalEventsParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LogicalEvents(ctx, params)
	return err
}

// GetLookupValues converts echo context to params.
func (w *ServerInterfaceWrapper) GetLookupValues(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLookupValues(ctx)
	return err
}

// MediaStateTypes converts echo context to params.
func (w *ServerInterfaceWrapper) MediaStateTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MediaStateTypes(ctx)
	return err
}

// Metrics converts echo context to params.
func (w *ServerInterfaceWrapper) Metrics(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Metrics(ctx)
	return err
}

// MilestoneDurations converts echo context to params.
func (w *ServerInterfaceWrapper) MilestoneDurations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MilestoneDurations(ctx)
	return err
}

// MilestoneLookups converts echo context to params.
func (w *ServerInterfaceWrapper) MilestoneLookups(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MilestoneLookups(ctx)
	return err
}

// MilestoneStatistics converts echo context to params.
func (w *ServerInterfaceWrapper) MilestoneStatistics(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MilestoneStatistics(ctx)
	return err
}

// MilestoneTypes converts echo context to params.
func (w *ServerInterfaceWrapper) MilestoneTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MilestoneTypes(ctx)
	return err
}

// Milestones converts echo context to params.
func (w *ServerInterfaceWrapper) Milestones(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MilestonesParams
	// ------------- Optional query parameter "orgType" -------------

	err = runtime.BindQueryParameter("form", true, false, "orgType", ctx.QueryParams(), &params.OrgType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orgType: %s", err))
	}

	// ------------- Optional query parameter "achievementStatuses" -------------

	err = runtime.BindQueryParameter("form", true, false, "achievementStatuses", ctx.QueryParams(), &params.AchievementStatuses)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter achievementStatuses: %s", err))
	}

	// ------------- Optional query parameter "milestoneTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "milestoneTypes", ctx.QueryParams(), &params.MilestoneTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter milestoneTypes: %s", err))
	}

	// ------------- Optional query parameter "isLastAchievement" -------------

	err = runtime.BindQueryParameter("form", true, false, "isLastAchievement", ctx.QueryParams(), &params.IsLastAchievement)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isLastAchievement: %s", err))
	}

	// ------------- Optional query parameter "milestoneStatistics" -------------

	err = runtime.BindQueryParameter("form", true, false, "milestoneStatistics", ctx.QueryParams(), &params.MilestoneStatistics)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter milestoneStatistics: %s", err))
	}

	// ------------- Optional query parameter "milestoneValues" -------------

	err = runtime.BindQueryParameter("form", true, false, "milestoneValues", ctx.QueryParams(), &params.MilestoneValues)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter milestoneValues: %s", err))
	}

	// ------------- Optional query parameter "playerIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerIds", ctx.QueryParams(), &params.PlayerIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerIds: %s", err))
	}

	// ------------- Optional query parameter "teamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamIds", ctx.QueryParams(), &params.TeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamIds: %s", err))
	}

	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "statGroup" -------------

	err = runtime.BindQueryParameter("form", true, false, "statGroup", ctx.QueryParams(), &params.StatGroup)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statGroup: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "venueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "venueIds", ctx.QueryParams(), &params.VenueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter venueIds: %s", err))
	}

	// ------------- Optional query parameter "gamePks" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamePks", ctx.QueryParams(), &params.GamePks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePks: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "showFirsts" -------------

	err = runtime.BindQueryParameter("form", true, false, "showFirsts", ctx.QueryParams(), &params.ShowFirsts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter showFirsts: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Milestones(ctx, params)
	return err
}

// MoundVisitTypes converts echo context to params.
func (w *ServerInterfaceWrapper) MoundVisitTypes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MoundVisitTypesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MoundVisitTypes(ctx, params)
	return err
}

// Person1 converts echo context to params.
func (w *ServerInterfaceWrapper) Person1(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params Person1Params
	// ------------- Optional query parameter "personIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "personIds", ctx.QueryParams(), &params.PersonIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter personIds: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Person1(ctx, params)
	return err
}

// CurrentGameStats converts echo context to params.
func (w *ServerInterfaceWrapper) CurrentGameStats(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CurrentGameStatsParams
	// ------------- Required query parameter "updatedSince" -------------

	err = runtime.BindQueryParameter("form", true, true, "updatedSince", ctx.QueryParams(), &params.UpdatedSince)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updatedSince: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CurrentGameStats(ctx, params)
	return err
}

// FreeAgents converts echo context to params.
func (w *ServerInterfaceWrapper) FreeAgents(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FreeAgentsParams
	// ------------- Required query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, true, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FreeAgents(ctx, params)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "names" -------------

	err = runtime.BindQueryParameter("form", true, false, "names", ctx.QueryParams(), &params.Names)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names: %s", err))
	}

	// ------------- Optional query parameter "personIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "personIds", ctx.QueryParams(), &params.PersonIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter personIds: %s", err))
	}

	// ------------- Optional query parameter "sportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportIds", ctx.QueryParams(), &params.SportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportIds: %s", err))
	}

	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "teamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamIds", ctx.QueryParams(), &params.TeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamIds: %s", err))
	}

	// ------------- Optional query parameter "leagueListId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueListId", ctx.QueryParams(), &params.LeagueListId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueListId: %s", err))
	}

	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", ctx.QueryParams(), &params.Active)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter active: %s", err))
	}

	// ------------- Optional query parameter "verified" -------------

	err = runtime.BindQueryParameter("form", true, false, "verified", ctx.QueryParams(), &params.Verified)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter verified: %s", err))
	}

	// ------------- Optional query parameter "rookie" -------------

	err = runtime.BindQueryParameter("form", true, false, "rookie", ctx.QueryParams(), &params.Rookie)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rookie: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// Person converts echo context to params.
func (w *ServerInterfaceWrapper) Person(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "personId" -------------
	var personId int32

	err = runtime.BindStyledParameterWithOptions("simple", "personId", ctx.Param("personId"), &personId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter personId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PersonParams
	// ------------- Optional query parameter "personIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "personIds", ctx.QueryParams(), &params.PersonIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter personIds: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Person(ctx, personId, params)
	return err
}

// Award converts echo context to params.
func (w *ServerInterfaceWrapper) Award(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "personId" -------------
	var personId int32

	err = runtime.BindStyledParameterWithOptions("simple", "personId", ctx.Param("personId"), &personId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter personId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AwardParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Award(ctx, personId, params)
	return err
}

// Stats3 converts echo context to params.
func (w *ServerInterfaceWrapper) Stats3(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "personId" -------------
	var personId int32

	err = runtime.BindStyledParameterWithOptions("simple", "personId", ctx.Param("personId"), &personId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter personId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params Stats3Params
	// ------------- Required query parameter "stats" -------------

	err = runtime.BindQueryParameter("form", true, true, "stats", ctx.QueryParams(), &params.Stats)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stats: %s", err))
	}

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "opposingTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opposingTeamId", ctx.QueryParams(), &params.OpposingTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opposingTeamId: %s", err))
	}

	// ------------- Optional query parameter "opposingPlayerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opposingPlayerId", ctx.QueryParams(), &params.OpposingPlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opposingPlayerId: %s", err))
	}

	// ------------- Optional query parameter "metrics" -------------

	err = runtime.BindQueryParameter("form", true, false, "metrics", ctx.QueryParams(), &params.Metrics)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter metrics: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "leagueListId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueListId", ctx.QueryParams(), &params.LeagueListId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueListId: %s", err))
	}

	// ------------- Optional query parameter "sitCodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "sitCodes", ctx.QueryParams(), &params.SitCodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sitCodes: %s", err))
	}

	// ------------- Optional query parameter "combineSits" -------------

	err = runtime.BindQueryParameter("form", true, false, "combineSits", ctx.QueryParams(), &params.CombineSits)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter combineSits: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "daysBack" -------------

	err = runtime.BindQueryParameter("form", true, false, "daysBack", ctx.QueryParams(), &params.DaysBack)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter daysBack: %s", err))
	}

	// ------------- Optional query parameter "gamesBack" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamesBack", ctx.QueryParams(), &params.GamesBack)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamesBack: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "eventType" -------------

	err = runtime.BindQueryParameter("form", true, false, "eventType", ctx.QueryParams(), &params.EventType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter eventType: %s", err))
	}

	// ------------- Optional query parameter "pitchType" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitchType", ctx.QueryParams(), &params.PitchType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitchType: %s", err))
	}

	// ------------- Optional query parameter "hitTrajectory" -------------

	err = runtime.BindQueryParameter("form", true, false, "hitTrajectory", ctx.QueryParams(), &params.HitTrajectory)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hitTrajectory: %s", err))
	}

	// ------------- Optional query parameter "batSide" -------------

	err = runtime.BindQueryParameter("form", true, false, "batSide", ctx.QueryParams(), &params.BatSide)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batSide: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", ctx.QueryParams(), &params.GroupBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupBy: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Stats3(ctx, personId, params)
	return err
}

// PlayerGameStats converts echo context to params.
func (w *ServerInterfaceWrapper) PlayerGameStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "personId" -------------
	var personId int32

	err = runtime.BindStyledParameterWithOptions("simple", "personId", ctx.Param("personId"), &personId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter personId: %s", err))
	}

	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PlayerGameStatsParams
	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PlayerGameStats(ctx, personId, gamePk, params)
	return err
}

// StatsMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) StatsMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "personId" -------------
	var personId int32

	err = runtime.BindStyledParameterWithOptions("simple", "personId", ctx.Param("personId"), &personId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter personId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params StatsMetricsParams
	// ------------- Required query parameter "stats" -------------

	err = runtime.BindQueryParameter("form", true, true, "stats", ctx.QueryParams(), &params.Stats)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stats: %s", err))
	}

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "opposingTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opposingTeamId", ctx.QueryParams(), &params.OpposingTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opposingTeamId: %s", err))
	}

	// ------------- Optional query parameter "opposingPlayerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opposingPlayerId", ctx.QueryParams(), &params.OpposingPlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opposingPlayerId: %s", err))
	}

	// ------------- Optional query parameter "metrics" -------------

	err = runtime.BindQueryParameter("form", true, false, "metrics", ctx.QueryParams(), &params.Metrics)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter metrics: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "leagueListId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueListId", ctx.QueryParams(), &params.LeagueListId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueListId: %s", err))
	}

	// ------------- Optional query parameter "sitCodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "sitCodes", ctx.QueryParams(), &params.SitCodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sitCodes: %s", err))
	}

	// ------------- Optional query parameter "combineSits" -------------

	err = runtime.BindQueryParameter("form", true, false, "combineSits", ctx.QueryParams(), &params.CombineSits)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter combineSits: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "daysBack" -------------

	err = runtime.BindQueryParameter("form", true, false, "daysBack", ctx.QueryParams(), &params.DaysBack)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter daysBack: %s", err))
	}

	// ------------- Optional query parameter "gamesBack" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamesBack", ctx.QueryParams(), &params.GamesBack)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamesBack: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "eventType" -------------

	err = runtime.BindQueryParameter("form", true, false, "eventType", ctx.QueryParams(), &params.EventType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter eventType: %s", err))
	}

	// ------------- Optional query parameter "pitchType" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitchType", ctx.QueryParams(), &params.PitchType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitchType: %s", err))
	}

	// ------------- Optional query parameter "hitTrajectory" -------------

	err = runtime.BindQueryParameter("form", true, false, "hitTrajectory", ctx.QueryParams(), &params.HitTrajectory)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hitTrajectory: %s", err))
	}

	// ------------- Optional query parameter "batSide" -------------

	err = runtime.BindQueryParameter("form", true, false, "batSide", ctx.QueryParams(), &params.BatSide)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batSide: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", ctx.QueryParams(), &params.GroupBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupBy: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StatsMetrics(ctx, personId, params)
	return err
}

// PerformerTypes converts echo context to params.
func (w *ServerInterfaceWrapper) PerformerTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PerformerTypes(ctx)
	return err
}

// PitchCodes converts echo context to params.
func (w *ServerInterfaceWrapper) PitchCodes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PitchCodesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PitchCodes(ctx, params)
	return err
}

// PitchTypes converts echo context to params.
func (w *ServerInterfaceWrapper) PitchTypes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PitchTypesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PitchTypes(ctx, params)
	return err
}

// Platforms converts echo context to params.
func (w *ServerInterfaceWrapper) Platforms(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Platforms(ctx)
	return err
}

// PlayerStatusCodes converts echo context to params.
func (w *ServerInterfaceWrapper) PlayerStatusCodes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PlayerStatusCodesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PlayerStatusCodes(ctx, params)
	return err
}

// Positions converts echo context to params.
func (w *ServerInterfaceWrapper) Positions(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Positions(ctx)
	return err
}

// GetProps converts echo context to params.
func (w *ServerInterfaceWrapper) GetProps(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPropsParams
	// ------------- Optional query parameter "batterId" -------------

	err = runtime.BindQueryParameter("form", true, false, "batterId", ctx.QueryParams(), &params.BatterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batterId: %s", err))
	}

	// ------------- Optional query parameter "pitcherId" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitcherId", ctx.QueryParams(), &params.PitcherId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitcherId: %s", err))
	}

	// ------------- Optional query parameter "venueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "venueId", ctx.QueryParams(), &params.VenueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter venueId: %s", err))
	}

	// ------------- Optional query parameter "batSide" -------------

	err = runtime.BindQueryParameter("form", true, false, "batSide", ctx.QueryParams(), &params.BatSide)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batSide: %s", err))
	}

	// ------------- Optional query parameter "pitchHand" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitchHand", ctx.QueryParams(), &params.PitchHand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitchHand: %s", err))
	}

	// ------------- Optional query parameter "batterPosition" -------------

	err = runtime.BindQueryParameter("form", true, false, "batterPosition", ctx.QueryParams(), &params.BatterPosition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batterPosition: %s", err))
	}

	// ------------- Optional query parameter "pitcherPosition" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitcherPosition", ctx.QueryParams(), &params.PitcherPosition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitcherPosition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProps(ctx, params)
	return err
}

// GetPropsAdjust converts echo context to params.
func (w *ServerInterfaceWrapper) GetPropsAdjust(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPropsAdjustParams
	// ------------- Required query parameter "gamePk" -------------

	err = runtime.BindQueryParameter("form", true, true, "gamePk", ctx.QueryParams(), &params.GamePk)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPropsAdjust(ctx, params)
	return err
}

// GetReviewInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetReviewInfo(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReviewInfoParams
	// ------------- Required query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, true, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Required query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, true, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetReviewInfo(ctx, params)
	return err
}

// ReviewReasons converts echo context to params.
func (w *ServerInterfaceWrapper) ReviewReasons(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ReviewReasonsParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ReviewReasons(ctx, params)
	return err
}

// RoofTypes converts echo context to params.
func (w *ServerInterfaceWrapper) RoofTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RoofTypes(ctx)
	return err
}

// RosterTypes converts echo context to params.
func (w *ServerInterfaceWrapper) RosterTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RosterTypes(ctx)
	return err
}

// RuleSettings converts echo context to params.
func (w *ServerInterfaceWrapper) RuleSettings(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RuleSettings(ctx)
	return err
}

// RunnerDetailTypes converts echo context to params.
func (w *ServerInterfaceWrapper) RunnerDetailTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RunnerDetailTypes(ctx)
	return err
}

// Schedule converts echo context to params.
func (w *ServerInterfaceWrapper) Schedule(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ScheduleParams
	// ------------- Optional query parameter "calendarTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "calendarTypes", ctx.QueryParams(), &params.CalendarTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter calendarTypes: %s", err))
	}

	// ------------- Optional query parameter "eventTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "eventTypes", ctx.QueryParams(), &params.EventTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter eventTypes: %s", err))
	}

	// ------------- Optional query parameter "scheduleEventTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduleEventTypes", ctx.QueryParams(), &params.ScheduleEventTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduleEventTypes: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "gamePk" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamePk", ctx.QueryParams(), &params.GamePk)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Optional query parameter "gamePks" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamePks", ctx.QueryParams(), &params.GamePks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePks: %s", err))
	}

	// ------------- Optional query parameter "eventIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "eventIds", ctx.QueryParams(), &params.EventIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter eventIds: %s", err))
	}

	// ------------- Optional query parameter "venueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "venueIds", ctx.QueryParams(), &params.VenueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter venueIds: %s", err))
	}

	// ------------- Optional query parameter "performerIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "performerIds", ctx.QueryParams(), &params.PerformerIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter performerIds: %s", err))
	}

	// ------------- Optional query parameter "gameTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameTypes", ctx.QueryParams(), &params.GameTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameTypes: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// ------------- Optional query parameter "useLatestGames" -------------

	err = runtime.BindQueryParameter("form", true, false, "useLatestGames", ctx.QueryParams(), &params.UseLatestGames)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter useLatestGames: %s", err))
	}

	// ------------- Optional query parameter "opponentId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opponentId", ctx.QueryParams(), &params.OpponentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opponentId: %s", err))
	}

	// ------------- Optional query parameter "publicFacing" -------------

	err = runtime.BindQueryParameter("form", true, false, "publicFacing", ctx.QueryParams(), &params.PublicFacing)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter publicFacing: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Required query parameter "usingPrivateEndpoint" -------------

	err = runtime.BindQueryParameter("form", true, true, "usingPrivateEndpoint", ctx.QueryParams(), &params.UsingPrivateEndpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usingPrivateEndpoint: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Schedule(ctx, params)
	return err
}

// TieGames converts echo context to params.
func (w *ServerInterfaceWrapper) TieGames(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params TieGamesParams
	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "gameTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameTypes", ctx.QueryParams(), &params.GameTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameTypes: %s", err))
	}

	// ------------- Required query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, true, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TieGames(ctx, params)
	return err
}

// PostseasonSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) PostseasonSchedule(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostseasonScheduleParams
	// ------------- Optional query parameter "gameTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameTypes", ctx.QueryParams(), &params.GameTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameTypes: %s", err))
	}

	// ------------- Optional query parameter "seriesNumber" -------------

	err = runtime.BindQueryParameter("form", true, false, "seriesNumber", ctx.QueryParams(), &params.SeriesNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seriesNumber: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "useLatestGames" -------------

	err = runtime.BindQueryParameter("form", true, false, "useLatestGames", ctx.QueryParams(), &params.UseLatestGames)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter useLatestGames: %s", err))
	}

	// ------------- Optional query parameter "useFeaturedGame" -------------

	err = runtime.BindQueryParameter("form", true, false, "useFeaturedGame", ctx.QueryParams(), &params.UseFeaturedGame)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter useFeaturedGame: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "publicFacing" -------------

	err = runtime.BindQueryParameter("form", true, false, "publicFacing", ctx.QueryParams(), &params.PublicFacing)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter publicFacing: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostseasonSchedule(ctx, params)
	return err
}

// PostseasonScheduleSeries converts echo context to params.
func (w *ServerInterfaceWrapper) PostseasonScheduleSeries(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostseasonScheduleSeriesParams
	// ------------- Optional query parameter "gameTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameTypes", ctx.QueryParams(), &params.GameTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameTypes: %s", err))
	}

	// ------------- Optional query parameter "seriesNumber" -------------

	err = runtime.BindQueryParameter("form", true, false, "seriesNumber", ctx.QueryParams(), &params.SeriesNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seriesNumber: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "useLatestGames" -------------

	err = runtime.BindQueryParameter("form", true, false, "useLatestGames", ctx.QueryParams(), &params.UseLatestGames)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter useLatestGames: %s", err))
	}

	// ------------- Optional query parameter "useFeaturedGame" -------------

	err = runtime.BindQueryParameter("form", true, false, "useFeaturedGame", ctx.QueryParams(), &params.UseFeaturedGame)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter useFeaturedGame: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostseasonScheduleSeries(ctx, params)
	return err
}

// TuneIn converts echo context to params.
func (w *ServerInterfaceWrapper) TuneIn(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params TuneInParams
	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TuneIn(ctx, params)
	return err
}

// TrackingEventsSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) TrackingEventsSchedule(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TrackingEventsScheduleParams
	// ------------- Optional query parameter "calendarTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "calendarTypes", ctx.QueryParams(), &params.CalendarTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter calendarTypes: %s", err))
	}

	// ------------- Optional query parameter "eventTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "eventTypes", ctx.QueryParams(), &params.EventTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter eventTypes: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "gamePk" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamePk", ctx.QueryParams(), &params.GamePk)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Optional query parameter "gamePks" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamePks", ctx.QueryParams(), &params.GamePks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePks: %s", err))
	}

	// ------------- Optional query parameter "eventIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "eventIds", ctx.QueryParams(), &params.EventIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter eventIds: %s", err))
	}

	// ------------- Optional query parameter "venueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "venueIds", ctx.QueryParams(), &params.VenueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter venueIds: %s", err))
	}

	// ------------- Optional query parameter "performerIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "performerIds", ctx.QueryParams(), &params.PerformerIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter performerIds: %s", err))
	}

	// ------------- Optional query parameter "gameTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameTypes", ctx.QueryParams(), &params.GameTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameTypes: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// ------------- Optional query parameter "useLatestGames" -------------

	err = runtime.BindQueryParameter("form", true, false, "useLatestGames", ctx.QueryParams(), &params.UseLatestGames)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter useLatestGames: %s", err))
	}

	// ------------- Optional query parameter "opponentId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opponentId", ctx.QueryParams(), &params.OpponentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opponentId: %s", err))
	}

	// ------------- Optional query parameter "publicFacing" -------------

	err = runtime.BindQueryParameter("form", true, false, "publicFacing", ctx.QueryParams(), &params.PublicFacing)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter publicFacing: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TrackingEventsSchedule(ctx, params)
	return err
}

// Schedule1 converts echo context to params.
func (w *ServerInterfaceWrapper) Schedule1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scheduleType" -------------
	var scheduleType string

	err = runtime.BindStyledParameterWithOptions("simple", "scheduleType", ctx.Param("scheduleType"), &scheduleType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduleType: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params Schedule1Params
	// ------------- Optional query parameter "calendarTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "calendarTypes", ctx.QueryParams(), &params.CalendarTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter calendarTypes: %s", err))
	}

	// ------------- Optional query parameter "eventTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "eventTypes", ctx.QueryParams(), &params.EventTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter eventTypes: %s", err))
	}

	// ------------- Optional query parameter "scheduleEventTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduleEventTypes", ctx.QueryParams(), &params.ScheduleEventTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduleEventTypes: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "gamePk" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamePk", ctx.QueryParams(), &params.GamePk)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Optional query parameter "gamePks" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamePks", ctx.QueryParams(), &params.GamePks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePks: %s", err))
	}

	// ------------- Optional query parameter "eventIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "eventIds", ctx.QueryParams(), &params.EventIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter eventIds: %s", err))
	}

	// ------------- Optional query parameter "venueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "venueIds", ctx.QueryParams(), &params.VenueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter venueIds: %s", err))
	}

	// ------------- Optional query parameter "performerIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "performerIds", ctx.QueryParams(), &params.PerformerIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter performerIds: %s", err))
	}

	// ------------- Optional query parameter "gameTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameTypes", ctx.QueryParams(), &params.GameTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameTypes: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// ------------- Optional query parameter "useLatestGames" -------------

	err = runtime.BindQueryParameter("form", true, false, "useLatestGames", ctx.QueryParams(), &params.UseLatestGames)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter useLatestGames: %s", err))
	}

	// ------------- Optional query parameter "opponentId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opponentId", ctx.QueryParams(), &params.OpponentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opponentId: %s", err))
	}

	// ------------- Optional query parameter "publicFacing" -------------

	err = runtime.BindQueryParameter("form", true, false, "publicFacing", ctx.QueryParams(), &params.PublicFacing)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter publicFacing: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Required query parameter "usingPrivateEndpoint" -------------

	err = runtime.BindQueryParameter("form", true, true, "usingPrivateEndpoint", ctx.QueryParams(), &params.UsingPrivateEndpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usingPrivateEndpoint: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Schedule1(ctx, scheduleType, params)
	return err
}

// ScheduleEventTypes converts echo context to params.
func (w *ServerInterfaceWrapper) ScheduleEventTypes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ScheduleEventTypesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ScheduleEventTypes(ctx, params)
	return err
}

// ScheduleTypes converts echo context to params.
func (w *ServerInterfaceWrapper) ScheduleTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ScheduleTypes(ctx)
	return err
}

// Seasons converts echo context to params.
func (w *ServerInterfaceWrapper) Seasons(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SeasonsParams
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "withGameTypeDates" -------------

	err = runtime.BindQueryParameter("form", true, false, "withGameTypeDates", ctx.QueryParams(), &params.WithGameTypeDates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter withGameTypeDates: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Seasons(ctx, params)
	return err
}

// AllSeasons converts echo context to params.
func (w *ServerInterfaceWrapper) AllSeasons(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AllSeasonsParams
	// ------------- Optional query parameter "divisionId" -------------

	err = runtime.BindQueryParameter("form", true, false, "divisionId", ctx.QueryParams(), &params.DivisionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter divisionId: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "withGameTypeDates" -------------

	err = runtime.BindQueryParameter("form", true, false, "withGameTypeDates", ctx.QueryParams(), &params.WithGameTypeDates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter withGameTypeDates: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AllSeasons(ctx, params)
	return err
}

// Seasons1 converts echo context to params.
func (w *ServerInterfaceWrapper) Seasons1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "seasonId" -------------
	var seasonId string

	err = runtime.BindStyledParameterWithOptions("simple", "seasonId", ctx.Param("seasonId"), &seasonId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasonId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params Seasons1Params
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "withGameTypeDates" -------------

	err = runtime.BindQueryParameter("form", true, false, "withGameTypeDates", ctx.QueryParams(), &params.WithGameTypeDates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter withGameTypeDates: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Seasons1(ctx, seasonId, params)
	return err
}

// SitCodes converts echo context to params.
func (w *ServerInterfaceWrapper) SitCodes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SitCodesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "statGroup" -------------

	err = runtime.BindQueryParameter("form", true, false, "statGroup", ctx.QueryParams(), &params.StatGroup)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statGroup: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SitCodes(ctx, params)
	return err
}

// Sky converts echo context to params.
func (w *ServerInterfaceWrapper) Sky(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SkyParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Sky(ctx, params)
	return err
}

// AggregateSortEnum converts echo context to params.
func (w *ServerInterfaceWrapper) AggregateSortEnum(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AggregateSortEnum(ctx)
	return err
}

// Sports converts echo context to params.
func (w *ServerInterfaceWrapper) Sports(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SportsParams
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "hasStats" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasStats", ctx.QueryParams(), &params.HasStats)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hasStats: %s", err))
	}

	// ------------- Optional query parameter "activeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "activeStatus", ctx.QueryParams(), &params.ActiveStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter activeStatus: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Sports(ctx, params)
	return err
}

// Sports1 converts echo context to params.
func (w *ServerInterfaceWrapper) Sports1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "sportId" -------------
	var sportId int32

	err = runtime.BindStyledParameterWithOptions("simple", "sportId", ctx.Param("sportId"), &sportId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params Sports1Params
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "hasStats" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasStats", ctx.QueryParams(), &params.HasStats)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hasStats: %s", err))
	}

	// ------------- Optional query parameter "activeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "activeStatus", ctx.QueryParams(), &params.ActiveStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter activeStatus: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Sports1(ctx, sportId, params)
	return err
}

// AllSportBallot converts echo context to params.
func (w *ServerInterfaceWrapper) AllSportBallot(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "sportId" -------------
	var sportId int32

	err = runtime.BindStyledParameterWithOptions("simple", "sportId", ctx.Param("sportId"), &sportId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AllSportBallotParams
	// ------------- Required query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, true, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AllSportBallot(ctx, sportId, params)
	return err
}

// SportPlayers converts echo context to params.
func (w *ServerInterfaceWrapper) SportPlayers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "sportId" -------------
	var sportId int32

	err = runtime.BindStyledParameterWithOptions("simple", "sportId", ctx.Param("sportId"), &sportId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SportPlayersParams
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "hasStats" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasStats", ctx.QueryParams(), &params.HasStats)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hasStats: %s", err))
	}

	// ------------- Optional query parameter "accent" -------------

	err = runtime.BindQueryParameter("form", true, false, "accent", ctx.QueryParams(), &params.Accent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accent: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SportPlayers(ctx, sportId, params)
	return err
}

// Standings1 converts echo context to params.
func (w *ServerInterfaceWrapper) Standings1(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params Standings1Params
	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "standingsTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "standingsTypes", ctx.QueryParams(), &params.StandingsTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter standingsTypes: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "includeMLB" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeMLB", ctx.QueryParams(), &params.IncludeMLB)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeMLB: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Standings1(ctx, params)
	return err
}

// Standings converts echo context to params.
func (w *ServerInterfaceWrapper) Standings(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "standingsType" -------------
	var standingsType string

	err = runtime.BindStyledParameterWithOptions("simple", "standingsType", ctx.Param("standingsType"), &standingsType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter standingsType: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params StandingsParams
	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "standingsTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "standingsTypes", ctx.QueryParams(), &params.StandingsTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter standingsTypes: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "includeMLB" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeMLB", ctx.QueryParams(), &params.IncludeMLB)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeMLB: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Standings(ctx, standingsType, params)
	return err
}

// StandingsTypes converts echo context to params.
func (w *ServerInterfaceWrapper) StandingsTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StandingsTypes(ctx)
	return err
}

// StatFields converts echo context to params.
func (w *ServerInterfaceWrapper) StatFields(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StatFields(ctx)
	return err
}

// StatGroups converts echo context to params.
func (w *ServerInterfaceWrapper) StatGroups(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StatGroups(ctx)
	return err
}

// StatTypes converts echo context to params.
func (w *ServerInterfaceWrapper) StatTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StatTypes(ctx)
	return err
}

// StatcastPositionTypes converts echo context to params.
func (w *ServerInterfaceWrapper) StatcastPositionTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StatcastPositionTypes(ctx)
	return err
}

// Stats2 converts echo context to params.
func (w *ServerInterfaceWrapper) Stats2(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params Stats2Params
	// ------------- Required query parameter "stats" -------------

	err = runtime.BindQueryParameter("form", true, true, "stats", ctx.QueryParams(), &params.Stats)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stats: %s", err))
	}

	// ------------- Optional query parameter "personId" -------------

	err = runtime.BindQueryParameter("form", true, false, "personId", ctx.QueryParams(), &params.PersonId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter personId: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "teamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamIds", ctx.QueryParams(), &params.TeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamIds: %s", err))
	}

	// ------------- Required query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, true, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "sportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportIds", ctx.QueryParams(), &params.SportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportIds: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "leagueListId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueListId", ctx.QueryParams(), &params.LeagueListId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueListId: %s", err))
	}

	// ------------- Optional query parameter "metrics" -------------

	err = runtime.BindQueryParameter("form", true, false, "metrics", ctx.QueryParams(), &params.Metrics)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter metrics: %s", err))
	}

	// ------------- Optional query parameter "gamePk" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamePk", ctx.QueryParams(), &params.GamePk)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Optional query parameter "batterTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "batterTeamId", ctx.QueryParams(), &params.BatterTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batterTeamId: %s", err))
	}

	// ------------- Optional query parameter "pitcherTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitcherTeamId", ctx.QueryParams(), &params.PitcherTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitcherTeamId: %s", err))
	}

	// ------------- Optional query parameter "batterId" -------------

	err = runtime.BindQueryParameter("form", true, false, "batterId", ctx.QueryParams(), &params.BatterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batterId: %s", err))
	}

	// ------------- Optional query parameter "pitcherId" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitcherId", ctx.QueryParams(), &params.PitcherId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitcherId: %s", err))
	}

	// ------------- Optional query parameter "sitCodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "sitCodes", ctx.QueryParams(), &params.SitCodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sitCodes: %s", err))
	}

	// ------------- Optional query parameter "combineSits" -------------

	err = runtime.BindQueryParameter("form", true, false, "combineSits", ctx.QueryParams(), &params.CombineSits)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter combineSits: %s", err))
	}

	// ------------- Optional query parameter "opposingTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opposingTeamId", ctx.QueryParams(), &params.OpposingTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opposingTeamId: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "sortStat" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortStat", ctx.QueryParams(), &params.SortStat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortStat: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "playerPool" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerPool", ctx.QueryParams(), &params.PlayerPool)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerPool: %s", err))
	}

	// ------------- Optional query parameter "position" -------------

	err = runtime.BindQueryParameter("form", true, false, "position", ctx.QueryParams(), &params.Position)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter position: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "daysBack" -------------

	err = runtime.BindQueryParameter("form", true, false, "daysBack", ctx.QueryParams(), &params.DaysBack)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter daysBack: %s", err))
	}

	// ------------- Optional query parameter "gamesBack" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamesBack", ctx.QueryParams(), &params.GamesBack)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamesBack: %s", err))
	}

	// ------------- Optional query parameter "excludeTradedPlayers" -------------

	err = runtime.BindQueryParameter("form", true, false, "excludeTradedPlayers", ctx.QueryParams(), &params.ExcludeTradedPlayers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excludeTradedPlayers: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Stats2(ctx, params)
	return err
}

// GetOutsAboveAverage converts echo context to params.
func (w *ServerInterfaceWrapper) GetOutsAboveAverage(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOutsAboveAverageParams
	// ------------- Required query parameter "gamePk" -------------

	err = runtime.BindQueryParameter("form", true, true, "gamePk", ctx.QueryParams(), &params.GamePk)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOutsAboveAverage(ctx, params)
	return err
}

// GetSprayChart converts echo context to params.
func (w *ServerInterfaceWrapper) GetSprayChart(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSprayChartParams
	// ------------- Required query parameter "gamePk" -------------

	err = runtime.BindQueryParameter("form", true, true, "gamePk", ctx.QueryParams(), &params.GamePk)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSprayChart(ctx, params)
	return err
}

// GetStolenBaseProbability converts echo context to params.
func (w *ServerInterfaceWrapper) GetStolenBaseProbability(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStolenBaseProbabilityParams
	// ------------- Required query parameter "gamePk" -------------

	err = runtime.BindQueryParameter("form", true, true, "gamePk", ctx.QueryParams(), &params.GamePk)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Optional query parameter "timecode" -------------

	err = runtime.BindQueryParameter("form", true, false, "timecode", ctx.QueryParams(), &params.Timecode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timecode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStolenBaseProbability(ctx, params)
	return err
}

// GroupedStats converts echo context to params.
func (w *ServerInterfaceWrapper) GroupedStats(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GroupedStatsParams
	// ------------- Required query parameter "stats" -------------

	err = runtime.BindQueryParameter("form", true, true, "stats", ctx.QueryParams(), &params.Stats)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stats: %s", err))
	}

	// ------------- Optional query parameter "personId" -------------

	err = runtime.BindQueryParameter("form", true, false, "personId", ctx.QueryParams(), &params.PersonId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter personId: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "teamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamIds", ctx.QueryParams(), &params.TeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamIds: %s", err))
	}

	// ------------- Required query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, true, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "sportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportIds", ctx.QueryParams(), &params.SportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportIds: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "leagueListId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueListId", ctx.QueryParams(), &params.LeagueListId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueListId: %s", err))
	}

	// ------------- Optional query parameter "metrics" -------------

	err = runtime.BindQueryParameter("form", true, false, "metrics", ctx.QueryParams(), &params.Metrics)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter metrics: %s", err))
	}

	// ------------- Optional query parameter "gamePk" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamePk", ctx.QueryParams(), &params.GamePk)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Optional query parameter "batterTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "batterTeamId", ctx.QueryParams(), &params.BatterTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batterTeamId: %s", err))
	}

	// ------------- Optional query parameter "pitcherTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitcherTeamId", ctx.QueryParams(), &params.PitcherTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitcherTeamId: %s", err))
	}

	// ------------- Optional query parameter "batterId" -------------

	err = runtime.BindQueryParameter("form", true, false, "batterId", ctx.QueryParams(), &params.BatterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batterId: %s", err))
	}

	// ------------- Optional query parameter "pitcherId" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitcherId", ctx.QueryParams(), &params.PitcherId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitcherId: %s", err))
	}

	// ------------- Optional query parameter "sitCodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "sitCodes", ctx.QueryParams(), &params.SitCodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sitCodes: %s", err))
	}

	// ------------- Optional query parameter "combineSits" -------------

	err = runtime.BindQueryParameter("form", true, false, "combineSits", ctx.QueryParams(), &params.CombineSits)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter combineSits: %s", err))
	}

	// ------------- Optional query parameter "opposingTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opposingTeamId", ctx.QueryParams(), &params.OpposingTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opposingTeamId: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "sortStat" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortStat", ctx.QueryParams(), &params.SortStat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortStat: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "playerPool" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerPool", ctx.QueryParams(), &params.PlayerPool)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerPool: %s", err))
	}

	// ------------- Optional query parameter "position" -------------

	err = runtime.BindQueryParameter("form", true, false, "position", ctx.QueryParams(), &params.Position)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter position: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "daysBack" -------------

	err = runtime.BindQueryParameter("form", true, false, "daysBack", ctx.QueryParams(), &params.DaysBack)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter daysBack: %s", err))
	}

	// ------------- Optional query parameter "gamesBack" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamesBack", ctx.QueryParams(), &params.GamesBack)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamesBack: %s", err))
	}

	// ------------- Optional query parameter "excludeTradedPlayers" -------------

	err = runtime.BindQueryParameter("form", true, false, "excludeTradedPlayers", ctx.QueryParams(), &params.ExcludeTradedPlayers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excludeTradedPlayers: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "statFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "statFields", ctx.QueryParams(), &params.StatFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statFields: %s", err))
	}

	// ------------- Optional query parameter "sortField" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortField", ctx.QueryParams(), &params.SortField)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortField: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GroupedStats(ctx, params)
	return err
}

// Leaders2 converts echo context to params.
func (w *ServerInterfaceWrapper) Leaders2(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params Leaders2Params
	// ------------- Optional query parameter "leaderCategories" -------------

	err = runtime.BindQueryParameter("form", true, false, "leaderCategories", ctx.QueryParams(), &params.LeaderCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leaderCategories: %s", err))
	}

	// ------------- Optional query parameter "leaderGameTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "leaderGameTypes", ctx.QueryParams(), &params.LeaderGameTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leaderGameTypes: %s", err))
	}

	// ------------- Optional query parameter "statGroup" -------------

	err = runtime.BindQueryParameter("form", true, false, "statGroup", ctx.QueryParams(), &params.StatGroup)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statGroup: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "sportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportIds", ctx.QueryParams(), &params.SportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportIds: %s", err))
	}

	// ------------- Optional query parameter "stats" -------------

	err = runtime.BindQueryParameter("form", true, false, "stats", ctx.QueryParams(), &params.Stats)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stats: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "teamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamIds", ctx.QueryParams(), &params.TeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamIds: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "leagueListId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueListId", ctx.QueryParams(), &params.LeagueListId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueListId: %s", err))
	}

	// ------------- Optional query parameter "playerPool" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerPool", ctx.QueryParams(), &params.PlayerPool)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerPool: %s", err))
	}

	// ------------- Optional query parameter "statType" -------------

	err = runtime.BindQueryParameter("form", true, false, "statType", ctx.QueryParams(), &params.StatType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statType: %s", err))
	}

	// ------------- Optional query parameter "playerActive" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerActive", ctx.QueryParams(), &params.PlayerActive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerActive: %s", err))
	}

	// ------------- Optional query parameter "position" -------------

	err = runtime.BindQueryParameter("form", true, false, "position", ctx.QueryParams(), &params.Position)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter position: %s", err))
	}

	// ------------- Optional query parameter "sitCodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "sitCodes", ctx.QueryParams(), &params.SitCodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sitCodes: %s", err))
	}

	// ------------- Optional query parameter "opposingTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opposingTeamId", ctx.QueryParams(), &params.OpposingTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opposingTeamId: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "daysBack" -------------

	err = runtime.BindQueryParameter("form", true, false, "daysBack", ctx.QueryParams(), &params.DaysBack)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter daysBack: %s", err))
	}

	// ------------- Optional query parameter "gamesBack" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamesBack", ctx.QueryParams(), &params.GamesBack)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamesBack: %s", err))
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", ctx.QueryParams(), &params.GroupBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupBy: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Leaders2(ctx, params)
	return err
}

// MetricStats converts echo context to params.
func (w *ServerInterfaceWrapper) MetricStats(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params MetricStatsParams
	// ------------- Optional query parameter "personId" -------------

	err = runtime.BindQueryParameter("form", true, false, "personId", ctx.QueryParams(), &params.PersonId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter personId: %s", err))
	}

	// ------------- Optional query parameter "personIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "personIds", ctx.QueryParams(), &params.PersonIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter personIds: %s", err))
	}

	// ------------- Optional query parameter "batterId" -------------

	err = runtime.BindQueryParameter("form", true, false, "batterId", ctx.QueryParams(), &params.BatterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batterId: %s", err))
	}

	// ------------- Optional query parameter "pitcherId" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitcherId", ctx.QueryParams(), &params.PitcherId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitcherId: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Required query parameter "stats" -------------

	err = runtime.BindQueryParameter("form", true, true, "stats", ctx.QueryParams(), &params.Stats)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stats: %s", err))
	}

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "opposingTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opposingTeamId", ctx.QueryParams(), &params.OpposingTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opposingTeamId: %s", err))
	}

	// ------------- Optional query parameter "opposingPlayerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opposingPlayerId", ctx.QueryParams(), &params.OpposingPlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opposingPlayerId: %s", err))
	}

	// ------------- Optional query parameter "position" -------------

	err = runtime.BindQueryParameter("form", true, false, "position", ctx.QueryParams(), &params.Position)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter position: %s", err))
	}

	// ------------- Optional query parameter "eventType" -------------

	err = runtime.BindQueryParameter("form", true, false, "eventType", ctx.QueryParams(), &params.EventType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter eventType: %s", err))
	}

	// ------------- Optional query parameter "pitchType" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitchType", ctx.QueryParams(), &params.PitchType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitchType: %s", err))
	}

	// ------------- Optional query parameter "hitTrajectory" -------------

	err = runtime.BindQueryParameter("form", true, false, "hitTrajectory", ctx.QueryParams(), &params.HitTrajectory)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hitTrajectory: %s", err))
	}

	// ------------- Optional query parameter "batSide" -------------

	err = runtime.BindQueryParameter("form", true, false, "batSide", ctx.QueryParams(), &params.BatSide)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batSide: %s", err))
	}

	// ------------- Optional query parameter "pitchHand" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitchHand", ctx.QueryParams(), &params.PitchHand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitchHand: %s", err))
	}

	// ------------- Optional query parameter "venueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "venueId", ctx.QueryParams(), &params.VenueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter venueId: %s", err))
	}

	// ------------- Required query parameter "metrics" -------------

	err = runtime.BindQueryParameter("form", true, true, "metrics", ctx.QueryParams(), &params.Metrics)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter metrics: %s", err))
	}

	// ------------- Optional query parameter "gamePk" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamePk", ctx.QueryParams(), &params.GamePk)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Optional query parameter "minValue" -------------

	err = runtime.BindQueryParameter("form", true, false, "minValue", ctx.QueryParams(), &params.MinValue)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minValue: %s", err))
	}

	// ------------- Optional query parameter "maxValue" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxValue", ctx.QueryParams(), &params.MaxValue)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxValue: %s", err))
	}

	// ------------- Optional query parameter "percentile" -------------

	err = runtime.BindQueryParameter("form", true, false, "percentile", ctx.QueryParams(), &params.Percentile)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter percentile: %s", err))
	}

	// ------------- Optional query parameter "minOccurrences" -------------

	err = runtime.BindQueryParameter("form", true, false, "minOccurrences", ctx.QueryParams(), &params.MinOccurrences)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minOccurrences: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "batterTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "batterTeamId", ctx.QueryParams(), &params.BatterTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batterTeamId: %s", err))
	}

	// ------------- Optional query parameter "pitcherTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitcherTeamId", ctx.QueryParams(), &params.PitcherTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitcherTeamId: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "debug" -------------

	err = runtime.BindQueryParameter("form", true, false, "debug", ctx.QueryParams(), &params.Debug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter debug: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MetricStats(ctx, params)
	return err
}

// BeastStats converts echo context to params.
func (w *ServerInterfaceWrapper) BeastStats(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BeastStatsParams
	// ------------- Required query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, true, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "gamePks" -------------

	err = runtime.BindQueryParameter("form", true, false, "gamePks", ctx.QueryParams(), &params.GamePks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePks: %s", err))
	}

	// ------------- Optional query parameter "playIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "playIds", ctx.QueryParams(), &params.PlayIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playIds: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "gameTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameTypes", ctx.QueryParams(), &params.GameTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameTypes: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "teamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamIds", ctx.QueryParams(), &params.TeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamIds: %s", err))
	}

	// ------------- Optional query parameter "pitcherTeamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitcherTeamIds", ctx.QueryParams(), &params.PitcherTeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitcherTeamIds: %s", err))
	}

	// ------------- Optional query parameter "batterTeamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "batterTeamIds", ctx.QueryParams(), &params.BatterTeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batterTeamIds: %s", err))
	}

	// ------------- Optional query parameter "sportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportIds", ctx.QueryParams(), &params.SportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportIds: %s", err))
	}

	// ------------- Optional query parameter "pitcherSportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitcherSportIds", ctx.QueryParams(), &params.PitcherSportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitcherSportIds: %s", err))
	}

	// ------------- Optional query parameter "batterSportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "batterSportIds", ctx.QueryParams(), &params.BatterSportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batterSportIds: %s", err))
	}

	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "pitcherLeagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitcherLeagueIds", ctx.QueryParams(), &params.PitcherLeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitcherLeagueIds: %s", err))
	}

	// ------------- Optional query parameter "batterLeagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "batterLeagueIds", ctx.QueryParams(), &params.BatterLeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batterLeagueIds: %s", err))
	}

	// ------------- Optional query parameter "divisionIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "divisionIds", ctx.QueryParams(), &params.DivisionIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter divisionIds: %s", err))
	}

	// ------------- Optional query parameter "pitcherDivisionIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitcherDivisionIds", ctx.QueryParams(), &params.PitcherDivisionIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitcherDivisionIds: %s", err))
	}

	// ------------- Optional query parameter "batterDivisionIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "batterDivisionIds", ctx.QueryParams(), &params.BatterDivisionIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batterDivisionIds: %s", err))
	}

	// ------------- Optional query parameter "pitchersOnTeamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitchersOnTeamIds", ctx.QueryParams(), &params.PitchersOnTeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitchersOnTeamIds: %s", err))
	}

	// ------------- Optional query parameter "battersOnTeamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "battersOnTeamIds", ctx.QueryParams(), &params.BattersOnTeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter battersOnTeamIds: %s", err))
	}

	// ------------- Optional query parameter "playerIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerIds", ctx.QueryParams(), &params.PlayerIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerIds: %s", err))
	}

	// ------------- Optional query parameter "playerPool" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerPool", ctx.QueryParams(), &params.PlayerPool)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerPool: %s", err))
	}

	// ------------- Optional query parameter "pitcherIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitcherIds", ctx.QueryParams(), &params.PitcherIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitcherIds: %s", err))
	}

	// ------------- Optional query parameter "batterIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "batterIds", ctx.QueryParams(), &params.BatterIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batterIds: %s", err))
	}

	// ------------- Optional query parameter "catcherIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "catcherIds", ctx.QueryParams(), &params.CatcherIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter catcherIds: %s", err))
	}

	// ------------- Optional query parameter "firstBasemanIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "firstBasemanIds", ctx.QueryParams(), &params.FirstBasemanIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter firstBasemanIds: %s", err))
	}

	// ------------- Optional query parameter "secondBasemanIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "secondBasemanIds", ctx.QueryParams(), &params.SecondBasemanIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter secondBasemanIds: %s", err))
	}

	// ------------- Optional query parameter "thirdBasemanIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "thirdBasemanIds", ctx.QueryParams(), &params.ThirdBasemanIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thirdBasemanIds: %s", err))
	}

	// ------------- Optional query parameter "shortstopIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "shortstopIds", ctx.QueryParams(), &params.ShortstopIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shortstopIds: %s", err))
	}

	// ------------- Optional query parameter "leftFielderIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leftFielderIds", ctx.QueryParams(), &params.LeftFielderIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leftFielderIds: %s", err))
	}

	// ------------- Optional query parameter "centerFielderIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "centerFielderIds", ctx.QueryParams(), &params.CenterFielderIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter centerFielderIds: %s", err))
	}

	// ------------- Optional query parameter "rightFielderIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "rightFielderIds", ctx.QueryParams(), &params.RightFielderIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rightFielderIds: %s", err))
	}

	// ------------- Optional query parameter "runnerFirstIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "runnerFirstIds", ctx.QueryParams(), &params.RunnerFirstIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter runnerFirstIds: %s", err))
	}

	// ------------- Optional query parameter "runnerSecondIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "runnerSecondIds", ctx.QueryParams(), &params.RunnerSecondIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter runnerSecondIds: %s", err))
	}

	// ------------- Optional query parameter "runnerThirdIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "runnerThirdIds", ctx.QueryParams(), &params.RunnerThirdIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter runnerThirdIds: %s", err))
	}

	// ------------- Optional query parameter "venueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "venueIds", ctx.QueryParams(), &params.VenueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter venueIds: %s", err))
	}

	// ------------- Optional query parameter "pitchHand" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitchHand", ctx.QueryParams(), &params.PitchHand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitchHand: %s", err))
	}

	// ------------- Optional query parameter "batSide" -------------

	err = runtime.BindQueryParameter("form", true, false, "batSide", ctx.QueryParams(), &params.BatSide)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batSide: %s", err))
	}

	// ------------- Optional query parameter "pitchTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitchTypes", ctx.QueryParams(), &params.PitchTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitchTypes: %s", err))
	}

	// ------------- Optional query parameter "pitchCodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitchCodes", ctx.QueryParams(), &params.PitchCodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitchCodes: %s", err))
	}

	// ------------- Optional query parameter "eventTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "eventTypes", ctx.QueryParams(), &params.EventTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter eventTypes: %s", err))
	}

	// ------------- Optional query parameter "positions" -------------

	err = runtime.BindQueryParameter("form", true, false, "positions", ctx.QueryParams(), &params.Positions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter positions: %s", err))
	}

	// ------------- Optional query parameter "primaryPositions" -------------

	err = runtime.BindQueryParameter("form", true, false, "primaryPositions", ctx.QueryParams(), &params.PrimaryPositions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter primaryPositions: %s", err))
	}

	// ------------- Optional query parameter "minPitchSpeed" -------------

	err = runtime.BindQueryParameter("form", true, false, "minPitchSpeed", ctx.QueryParams(), &params.MinPitchSpeed)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minPitchSpeed: %s", err))
	}

	// ------------- Optional query parameter "maxPitchSpeed" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxPitchSpeed", ctx.QueryParams(), &params.MaxPitchSpeed)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxPitchSpeed: %s", err))
	}

	// ------------- Optional query parameter "minSpinRate" -------------

	err = runtime.BindQueryParameter("form", true, false, "minSpinRate", ctx.QueryParams(), &params.MinSpinRate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minSpinRate: %s", err))
	}

	// ------------- Optional query parameter "maxSpinRate" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxSpinRate", ctx.QueryParams(), &params.MaxSpinRate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxSpinRate: %s", err))
	}

	// ------------- Optional query parameter "minExtension" -------------

	err = runtime.BindQueryParameter("form", true, false, "minExtension", ctx.QueryParams(), &params.MinExtension)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minExtension: %s", err))
	}

	// ------------- Optional query parameter "maxExtension" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxExtension", ctx.QueryParams(), &params.MaxExtension)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxExtension: %s", err))
	}

	// ------------- Optional query parameter "minExitVelocityAgainst" -------------

	err = runtime.BindQueryParameter("form", true, false, "minExitVelocityAgainst", ctx.QueryParams(), &params.MinExitVelocityAgainst)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minExitVelocityAgainst: %s", err))
	}

	// ------------- Optional query parameter "maxExitVelocityAgainst" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxExitVelocityAgainst", ctx.QueryParams(), &params.MaxExitVelocityAgainst)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxExitVelocityAgainst: %s", err))
	}

	// ------------- Optional query parameter "minLaunchAngleAgainst" -------------

	err = runtime.BindQueryParameter("form", true, false, "minLaunchAngleAgainst", ctx.QueryParams(), &params.MinLaunchAngleAgainst)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minLaunchAngleAgainst: %s", err))
	}

	// ------------- Optional query parameter "maxLaunchAngleAgainst" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxLaunchAngleAgainst", ctx.QueryParams(), &params.MaxLaunchAngleAgainst)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxLaunchAngleAgainst: %s", err))
	}

	// ------------- Optional query parameter "minExitVelocity" -------------

	err = runtime.BindQueryParameter("form", true, false, "minExitVelocity", ctx.QueryParams(), &params.MinExitVelocity)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minExitVelocity: %s", err))
	}

	// ------------- Optional query parameter "maxExitVelocity" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxExitVelocity", ctx.QueryParams(), &params.MaxExitVelocity)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxExitVelocity: %s", err))
	}

	// ------------- Optional query parameter "minLaunchAngle" -------------

	err = runtime.BindQueryParameter("form", true, false, "minLaunchAngle", ctx.QueryParams(), &params.MinLaunchAngle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minLaunchAngle: %s", err))
	}

	// ------------- Optional query parameter "maxLaunchAngle" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxLaunchAngle", ctx.QueryParams(), &params.MaxLaunchAngle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxLaunchAngle: %s", err))
	}

	// ------------- Optional query parameter "minHomeRunDistance" -------------

	err = runtime.BindQueryParameter("form", true, false, "minHomeRunDistance", ctx.QueryParams(), &params.MinHomeRunDistance)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minHomeRunDistance: %s", err))
	}

	// ------------- Optional query parameter "maxHomeRunDistance" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxHomeRunDistance", ctx.QueryParams(), &params.MaxHomeRunDistance)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxHomeRunDistance: %s", err))
	}

	// ------------- Optional query parameter "minHitDistance" -------------

	err = runtime.BindQueryParameter("form", true, false, "minHitDistance", ctx.QueryParams(), &params.MinHitDistance)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minHitDistance: %s", err))
	}

	// ------------- Optional query parameter "maxHitDistance" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxHitDistance", ctx.QueryParams(), &params.MaxHitDistance)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxHitDistance: %s", err))
	}

	// ------------- Optional query parameter "minHangTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "minHangTime", ctx.QueryParams(), &params.MinHangTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minHangTime: %s", err))
	}

	// ------------- Optional query parameter "maxHangTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxHangTime", ctx.QueryParams(), &params.MaxHangTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxHangTime: %s", err))
	}

	// ------------- Optional query parameter "minHitProbability" -------------

	err = runtime.BindQueryParameter("form", true, false, "minHitProbability", ctx.QueryParams(), &params.MinHitProbability)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minHitProbability: %s", err))
	}

	// ------------- Optional query parameter "maxHitProbability" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxHitProbability", ctx.QueryParams(), &params.MaxHitProbability)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxHitProbability: %s", err))
	}

	// ------------- Optional query parameter "minCatchProbability" -------------

	err = runtime.BindQueryParameter("form", true, false, "minCatchProbability", ctx.QueryParams(), &params.MinCatchProbability)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minCatchProbability: %s", err))
	}

	// ------------- Optional query parameter "maxCatchProbability" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxCatchProbability", ctx.QueryParams(), &params.MaxCatchProbability)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxCatchProbability: %s", err))
	}

	// ------------- Optional query parameter "minAttackAngle" -------------

	err = runtime.BindQueryParameter("form", true, false, "minAttackAngle", ctx.QueryParams(), &params.MinAttackAngle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minAttackAngle: %s", err))
	}

	// ------------- Optional query parameter "maxAttackAngle" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxAttackAngle", ctx.QueryParams(), &params.MaxAttackAngle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxAttackAngle: %s", err))
	}

	// ------------- Optional query parameter "minBatSpeed" -------------

	err = runtime.BindQueryParameter("form", true, false, "minBatSpeed", ctx.QueryParams(), &params.MinBatSpeed)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minBatSpeed: %s", err))
	}

	// ------------- Optional query parameter "maxBatSpeed" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxBatSpeed", ctx.QueryParams(), &params.MaxBatSpeed)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxBatSpeed: %s", err))
	}

	// ------------- Optional query parameter "minHomeRunXBallparks" -------------

	err = runtime.BindQueryParameter("form", true, false, "minHomeRunXBallparks", ctx.QueryParams(), &params.MinHomeRunXBallparks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minHomeRunXBallparks: %s", err))
	}

	// ------------- Optional query parameter "maxHomeRunXBallparks" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxHomeRunXBallparks", ctx.QueryParams(), &params.MaxHomeRunXBallparks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxHomeRunXBallparks: %s", err))
	}

	// ------------- Optional query parameter "isBarrel" -------------

	err = runtime.BindQueryParameter("form", true, false, "isBarrel", ctx.QueryParams(), &params.IsBarrel)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isBarrel: %s", err))
	}

	// ------------- Optional query parameter "hitTrajectories" -------------

	err = runtime.BindQueryParameter("form", true, false, "hitTrajectories", ctx.QueryParams(), &params.HitTrajectories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hitTrajectories: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", ctx.QueryParams(), &params.GroupBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupBy: %s", err))
	}

	// ------------- Optional query parameter "compareOver" -------------

	err = runtime.BindQueryParameter("form", true, false, "compareOver", ctx.QueryParams(), &params.CompareOver)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter compareOver: %s", err))
	}

	// ------------- Optional query parameter "sortStat" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortStat", ctx.QueryParams(), &params.SortStat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortStat: %s", err))
	}

	// ------------- Optional query parameter "sortModifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortModifier", ctx.QueryParams(), &params.SortModifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortModifier: %s", err))
	}

	// ------------- Optional query parameter "sortOrder" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortOrder", ctx.QueryParams(), &params.SortOrder)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortOrder: %s", err))
	}

	// ------------- Optional query parameter "percentile" -------------

	err = runtime.BindQueryParameter("form", true, false, "percentile", ctx.QueryParams(), &params.Percentile)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter percentile: %s", err))
	}

	// ------------- Optional query parameter "minOccurrences" -------------

	err = runtime.BindQueryParameter("form", true, false, "minOccurrences", ctx.QueryParams(), &params.MinOccurrences)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minOccurrences: %s", err))
	}

	// ------------- Optional query parameter "minPlateAppearances" -------------

	err = runtime.BindQueryParameter("form", true, false, "minPlateAppearances", ctx.QueryParams(), &params.MinPlateAppearances)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minPlateAppearances: %s", err))
	}

	// ------------- Optional query parameter "minInnings" -------------

	err = runtime.BindQueryParameter("form", true, false, "minInnings", ctx.QueryParams(), &params.MinInnings)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minInnings: %s", err))
	}

	// ------------- Optional query parameter "qualifierRate" -------------

	err = runtime.BindQueryParameter("form", true, false, "qualifierRate", ctx.QueryParams(), &params.QualifierRate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter qualifierRate: %s", err))
	}

	// ------------- Optional query parameter "sitCodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "sitCodes", ctx.QueryParams(), &params.SitCodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sitCodes: %s", err))
	}

	// ------------- Optional query parameter "showTotals" -------------

	err = runtime.BindQueryParameter("form", true, false, "showTotals", ctx.QueryParams(), &params.ShowTotals)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter showTotals: %s", err))
	}

	// ------------- Optional query parameter "includeNullMetrics" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeNullMetrics", ctx.QueryParams(), &params.IncludeNullMetrics)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeNullMetrics: %s", err))
	}

	// ------------- Optional query parameter "statFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "statFields", ctx.QueryParams(), &params.StatFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statFields: %s", err))
	}

	// ------------- Optional query parameter "atBatNumbers" -------------

	err = runtime.BindQueryParameter("form", true, false, "atBatNumbers", ctx.QueryParams(), &params.AtBatNumbers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter atBatNumbers: %s", err))
	}

	// ------------- Optional query parameter "pitchNumbers" -------------

	err = runtime.BindQueryParameter("form", true, false, "pitchNumbers", ctx.QueryParams(), &params.PitchNumbers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pitchNumbers: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "debug" -------------

	err = runtime.BindQueryParameter("form", true, false, "debug", ctx.QueryParams(), &params.Debug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter debug: %s", err))
	}

	// ------------- Optional query parameter "activeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "activeStatus", ctx.QueryParams(), &params.ActiveStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter activeStatus: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BeastStats(ctx, params)
	return err
}

// StatSearchConfig converts echo context to params.
func (w *ServerInterfaceWrapper) StatSearchConfig(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params StatSearchConfigParams
	// ------------- Optional query parameter "filterLevel" -------------

	err = runtime.BindQueryParameter("form", true, false, "filterLevel", ctx.QueryParams(), &params.FilterLevel)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filterLevel: %s", err))
	}

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StatSearchConfig(ctx, params)
	return err
}

// StatSearchGroupByTypes converts echo context to params.
func (w *ServerInterfaceWrapper) StatSearchGroupByTypes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params StatSearchGroupByTypesParams
	// ------------- Optional query parameter "filterLevel" -------------

	err = runtime.BindQueryParameter("form", true, false, "filterLevel", ctx.QueryParams(), &params.FilterLevel)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filterLevel: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StatSearchGroupByTypes(ctx, params)
	return err
}

// StatSearchParams converts echo context to params.
func (w *ServerInterfaceWrapper) StatSearchParams(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params StatSearchParamsParams
	// ------------- Optional query parameter "filterLevel" -------------

	err = runtime.BindQueryParameter("form", true, false, "filterLevel", ctx.QueryParams(), &params.FilterLevel)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filterLevel: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StatSearchParams(ctx, params)
	return err
}

// StatSearchStats converts echo context to params.
func (w *ServerInterfaceWrapper) StatSearchStats(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params StatSearchStatsParams
	// ------------- Optional query parameter "filterLevel" -------------

	err = runtime.BindQueryParameter("form", true, false, "filterLevel", ctx.QueryParams(), &params.FilterLevel)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filterLevel: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StatSearchStats(ctx, params)
	return err
}

// GetStreaks converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreaks(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreaksParams
	// ------------- Optional query parameter "streakOrg" -------------

	err = runtime.BindQueryParameter("form", true, false, "streakOrg", ctx.QueryParams(), &params.StreakOrg)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter streakOrg: %s", err))
	}

	// ------------- Optional query parameter "streakStat" -------------

	err = runtime.BindQueryParameter("form", true, false, "streakStat", ctx.QueryParams(), &params.StreakStat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter streakStat: %s", err))
	}

	// ------------- Optional query parameter "streakSpan" -------------

	err = runtime.BindQueryParameter("form", true, false, "streakSpan", ctx.QueryParams(), &params.StreakSpan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter streakSpan: %s", err))
	}

	// ------------- Optional query parameter "streakLevel" -------------

	err = runtime.BindQueryParameter("form", true, false, "streakLevel", ctx.QueryParams(), &params.StreakLevel)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter streakLevel: %s", err))
	}

	// ------------- Optional query parameter "streakThreshold" -------------

	err = runtime.BindQueryParameter("form", true, false, "streakThreshold", ctx.QueryParams(), &params.StreakThreshold)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter streakThreshold: %s", err))
	}

	// ------------- Optional query parameter "inverse" -------------

	err = runtime.BindQueryParameter("form", true, false, "inverse", ctx.QueryParams(), &params.Inverse)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter inverse: %s", err))
	}

	// ------------- Optional query parameter "startersOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "startersOnly", ctx.QueryParams(), &params.StartersOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startersOnly: %s", err))
	}

	// ------------- Optional query parameter "statGroup" -------------

	err = runtime.BindQueryParameter("form", true, false, "statGroup", ctx.QueryParams(), &params.StatGroup)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statGroup: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "activeStreak" -------------

	err = runtime.BindQueryParameter("form", true, false, "activeStreak", ctx.QueryParams(), &params.ActiveStreak)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter activeStreak: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "playerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerId", ctx.QueryParams(), &params.PlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreaks(ctx, params)
	return err
}

// StreakTypes converts echo context to params.
func (w *ServerInterfaceWrapper) StreakTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StreakTypes(ctx)
	return err
}

// Teams converts echo context to params.
func (w *ServerInterfaceWrapper) Teams(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params TeamsParams
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "divisionId" -------------

	err = runtime.BindQueryParameter("form", true, false, "divisionId", ctx.QueryParams(), &params.DivisionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter divisionId: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "sportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportIds", ctx.QueryParams(), &params.SportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportIds: %s", err))
	}

	// ------------- Optional query parameter "activeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "activeStatus", ctx.QueryParams(), &params.ActiveStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter activeStatus: %s", err))
	}

	// ------------- Optional query parameter "leagueListId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueListId", ctx.QueryParams(), &params.LeagueListId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueListId: %s", err))
	}

	// ------------- Optional query parameter "allStarStatuses" -------------

	err = runtime.BindQueryParameter("form", true, false, "allStarStatuses", ctx.QueryParams(), &params.AllStarStatuses)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allStarStatuses: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Teams(ctx, params)
	return err
}

// Affiliates1 converts echo context to params.
func (w *ServerInterfaceWrapper) Affiliates1(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params Affiliates1Params
	// ------------- Optional query parameter "teamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamIds", ctx.QueryParams(), &params.TeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamIds: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Affiliates1(ctx, params)
	return err
}

// AllTeams1 converts echo context to params.
func (w *ServerInterfaceWrapper) AllTeams1(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AllTeams1Params
	// ------------- Optional query parameter "teamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamIds", ctx.QueryParams(), &params.TeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamIds: %s", err))
	}

	// ------------- Optional query parameter "startSeason" -------------

	err = runtime.BindQueryParameter("form", true, false, "startSeason", ctx.QueryParams(), &params.StartSeason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startSeason: %s", err))
	}

	// ------------- Optional query parameter "endSeason" -------------

	err = runtime.BindQueryParameter("form", true, false, "endSeason", ctx.QueryParams(), &params.EndSeason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endSeason: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AllTeams1(ctx, params)
	return err
}

// Stats1 converts echo context to params.
func (w *ServerInterfaceWrapper) Stats1(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params Stats1Params
	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "stats" -------------

	err = runtime.BindQueryParameter("form", true, false, "stats", ctx.QueryParams(), &params.Stats)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stats: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "sportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportIds", ctx.QueryParams(), &params.SportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportIds: %s", err))
	}

	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Required query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, true, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "sortStat" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortStat", ctx.QueryParams(), &params.SortStat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortStat: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "daysBack" -------------

	err = runtime.BindQueryParameter("form", true, false, "daysBack", ctx.QueryParams(), &params.DaysBack)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter daysBack: %s", err))
	}

	// ------------- Optional query parameter "sitCodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "sitCodes", ctx.QueryParams(), &params.SitCodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sitCodes: %s", err))
	}

	// ------------- Optional query parameter "combineSits" -------------

	err = runtime.BindQueryParameter("form", true, false, "combineSits", ctx.QueryParams(), &params.CombineSits)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter combineSits: %s", err))
	}

	// ------------- Optional query parameter "opposingTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opposingTeamId", ctx.QueryParams(), &params.OpposingTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opposingTeamId: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Stats1(ctx, params)
	return err
}

// Leaders1 converts echo context to params.
func (w *ServerInterfaceWrapper) Leaders1(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params Leaders1Params
	// ------------- Optional query parameter "leaderCategories" -------------

	err = runtime.BindQueryParameter("form", true, false, "leaderCategories", ctx.QueryParams(), &params.LeaderCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leaderCategories: %s", err))
	}

	// ------------- Optional query parameter "gameTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameTypes", ctx.QueryParams(), &params.GameTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameTypes: %s", err))
	}

	// ------------- Optional query parameter "stats" -------------

	err = runtime.BindQueryParameter("form", true, false, "stats", ctx.QueryParams(), &params.Stats)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stats: %s", err))
	}

	// ------------- Optional query parameter "statType" -------------

	err = runtime.BindQueryParameter("form", true, false, "statType", ctx.QueryParams(), &params.StatType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statType: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "sportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportIds", ctx.QueryParams(), &params.SportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportIds: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "statGroup" -------------

	err = runtime.BindQueryParameter("form", true, false, "statGroup", ctx.QueryParams(), &params.StatGroup)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statGroup: %s", err))
	}

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "daysBack" -------------

	err = runtime.BindQueryParameter("form", true, false, "daysBack", ctx.QueryParams(), &params.DaysBack)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter daysBack: %s", err))
	}

	// ------------- Optional query parameter "sitCodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "sitCodes", ctx.QueryParams(), &params.SitCodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sitCodes: %s", err))
	}

	// ------------- Optional query parameter "opposingTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opposingTeamId", ctx.QueryParams(), &params.OpposingTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opposingTeamId: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Leaders1(ctx, params)
	return err
}

// Teams1 converts echo context to params.
func (w *ServerInterfaceWrapper) Teams1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "teamId" -------------
	var teamId int32

	err = runtime.BindStyledParameterWithOptions("simple", "teamId", ctx.Param("teamId"), &teamId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params Teams1Params
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "divisionId" -------------

	err = runtime.BindQueryParameter("form", true, false, "divisionId", ctx.QueryParams(), &params.DivisionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter divisionId: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "sportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportIds", ctx.QueryParams(), &params.SportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportIds: %s", err))
	}

	// ------------- Optional query parameter "activeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "activeStatus", ctx.QueryParams(), &params.ActiveStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter activeStatus: %s", err))
	}

	// ------------- Optional query parameter "leagueListId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueListId", ctx.QueryParams(), &params.LeagueListId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueListId: %s", err))
	}

	// ------------- Optional query parameter "allStarStatuses" -------------

	err = runtime.BindQueryParameter("form", true, false, "allStarStatuses", ctx.QueryParams(), &params.AllStarStatuses)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allStarStatuses: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Teams1(ctx, teamId, params)
	return err
}

// Affiliates converts echo context to params.
func (w *ServerInterfaceWrapper) Affiliates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "teamId" -------------
	var teamId int32

	err = runtime.BindStyledParameterWithOptions("simple", "teamId", ctx.Param("teamId"), &teamId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AffiliatesParams
	// ------------- Optional query parameter "teamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamIds", ctx.QueryParams(), &params.TeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamIds: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Affiliates(ctx, teamId, params)
	return err
}

// Alumni converts echo context to params.
func (w *ServerInterfaceWrapper) Alumni(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "teamId" -------------
	var teamId int32

	err = runtime.BindStyledParameterWithOptions("simple", "teamId", ctx.Param("teamId"), &teamId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AlumniParams
	// ------------- Required query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, true, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Alumni(ctx, teamId, params)
	return err
}

// UpdateAlumni converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAlumni(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "teamId" -------------
	var teamId int32

	err = runtime.BindStyledParameterWithOptions("simple", "teamId", ctx.Param("teamId"), &teamId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateAlumniParams
	// ------------- Required query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, true, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAlumni(ctx, teamId, params)
	return err
}

// Coaches converts echo context to params.
func (w *ServerInterfaceWrapper) Coaches(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "teamId" -------------
	var teamId int32

	err = runtime.BindStyledParameterWithOptions("simple", "teamId", ctx.Param("teamId"), &teamId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params CoachesParams
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Coaches(ctx, teamId, params)
	return err
}

// AllTeams converts echo context to params.
func (w *ServerInterfaceWrapper) AllTeams(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "teamId" -------------
	var teamId int32

	err = runtime.BindStyledParameterWithOptions("simple", "teamId", ctx.Param("teamId"), &teamId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AllTeamsParams
	// ------------- Optional query parameter "teamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamIds", ctx.QueryParams(), &params.TeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamIds: %s", err))
	}

	// ------------- Optional query parameter "startSeason" -------------

	err = runtime.BindQueryParameter("form", true, false, "startSeason", ctx.QueryParams(), &params.StartSeason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startSeason: %s", err))
	}

	// ------------- Optional query parameter "endSeason" -------------

	err = runtime.BindQueryParameter("form", true, false, "endSeason", ctx.QueryParams(), &params.EndSeason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endSeason: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AllTeams(ctx, teamId, params)
	return err
}

// Leaders converts echo context to params.
func (w *ServerInterfaceWrapper) Leaders(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "teamId" -------------
	var teamId int32

	err = runtime.BindStyledParameterWithOptions("simple", "teamId", ctx.Param("teamId"), &teamId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LeadersParams
	// ------------- Optional query parameter "leaderCategories" -------------

	err = runtime.BindQueryParameter("form", true, false, "leaderCategories", ctx.QueryParams(), &params.LeaderCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leaderCategories: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "leaderGameTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "leaderGameTypes", ctx.QueryParams(), &params.LeaderGameTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leaderGameTypes: %s", err))
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expand: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "playerPool" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerPool", ctx.QueryParams(), &params.PlayerPool)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerPool: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Leaders(ctx, teamId, params)
	return err
}

// Personnel converts echo context to params.
func (w *ServerInterfaceWrapper) Personnel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "teamId" -------------
	var teamId int32

	err = runtime.BindStyledParameterWithOptions("simple", "teamId", ctx.Param("teamId"), &teamId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PersonnelParams
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Personnel(ctx, teamId, params)
	return err
}

// Roster converts echo context to params.
func (w *ServerInterfaceWrapper) Roster(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "teamId" -------------
	var teamId int32

	err = runtime.BindStyledParameterWithOptions("simple", "teamId", ctx.Param("teamId"), &teamId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params RosterParams
	// ------------- Optional query parameter "rosterType" -------------

	err = runtime.BindQueryParameter("form", true, false, "rosterType", ctx.QueryParams(), &params.RosterType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rosterType: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Roster(ctx, teamId, params)
	return err
}

// Roster1 converts echo context to params.
func (w *ServerInterfaceWrapper) Roster1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "teamId" -------------
	var teamId int32

	err = runtime.BindStyledParameterWithOptions("simple", "teamId", ctx.Param("teamId"), &teamId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Path parameter "rosterType" -------------
	var rosterType string

	err = runtime.BindStyledParameterWithOptions("simple", "rosterType", ctx.Param("rosterType"), &rosterType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rosterType: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params Roster1Params
	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Roster1(ctx, teamId, rosterType, params)
	return err
}

// Stats converts echo context to params.
func (w *ServerInterfaceWrapper) Stats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "teamId" -------------
	var teamId int32

	err = runtime.BindStyledParameterWithOptions("simple", "teamId", ctx.Param("teamId"), &teamId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params StatsParams
	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "stats" -------------

	err = runtime.BindQueryParameter("form", true, false, "stats", ctx.QueryParams(), &params.Stats)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stats: %s", err))
	}

	// ------------- Required query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, true, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "sortStat" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortStat", ctx.QueryParams(), &params.SortStat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortStat: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", ctx.QueryParams(), &params.GroupBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupBy: %s", err))
	}

	// ------------- Optional query parameter "opposingTeamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opposingTeamId", ctx.QueryParams(), &params.OpposingTeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opposingTeamId: %s", err))
	}

	// ------------- Optional query parameter "opposingPlayerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "opposingPlayerId", ctx.QueryParams(), &params.OpposingPlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter opposingPlayerId: %s", err))
	}

	// ------------- Optional query parameter "sitCodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "sitCodes", ctx.QueryParams(), &params.SitCodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sitCodes: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Stats(ctx, teamId, params)
	return err
}

// TrackingSoftwareVersions converts echo context to params.
func (w *ServerInterfaceWrapper) TrackingSoftwareVersions(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TrackingSoftwareVersions(ctx)
	return err
}

// TrackingSystemOwners converts echo context to params.
func (w *ServerInterfaceWrapper) TrackingSystemOwners(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TrackingSystemOwners(ctx)
	return err
}

// TrackingVendors converts echo context to params.
func (w *ServerInterfaceWrapper) TrackingVendors(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TrackingVendors(ctx)
	return err
}

// TrackingVersions converts echo context to params.
func (w *ServerInterfaceWrapper) TrackingVersions(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TrackingVersions(ctx)
	return err
}

// TransactionTypes converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionTypes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionTypesParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionTypes(ctx, params)
	return err
}

// Transactions converts echo context to params.
func (w *ServerInterfaceWrapper) Transactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionsParams
	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "teamId" -------------

	err = runtime.BindQueryParameter("form", true, false, "teamId", ctx.QueryParams(), &params.TeamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamId: %s", err))
	}

	// ------------- Optional query parameter "playerId" -------------

	err = runtime.BindQueryParameter("form", true, false, "playerId", ctx.QueryParams(), &params.PlayerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playerId: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "transactionIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "transactionIds", ctx.QueryParams(), &params.TransactionIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transactionIds: %s", err))
	}

	// ------------- Optional query parameter "transactionTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "transactionTypes", ctx.QueryParams(), &params.TransactionTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transactionTypes: %s", err))
	}

	// ------------- Optional query parameter "divisionIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "divisionIds", ctx.QueryParams(), &params.DivisionIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter divisionIds: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Transactions(ctx, params)
	return err
}

// UniformsByGame converts echo context to params.
func (w *ServerInterfaceWrapper) UniformsByGame(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UniformsByGameParams
	// ------------- Required query parameter "gamePks" -------------

	err = runtime.BindQueryParameter("form", true, true, "gamePks", ctx.QueryParams(), &params.GamePks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePks: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UniformsByGame(ctx, params)
	return err
}

// UniformsByTeam converts echo context to params.
func (w *ServerInterfaceWrapper) UniformsByTeam(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UniformsByTeamParams
	// ------------- Required query parameter "teamIds" -------------

	err = runtime.BindQueryParameter("form", true, true, "teamIds", ctx.QueryParams(), &params.TeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter teamIds: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UniformsByTeam(ctx, params)
	return err
}

// Venues converts echo context to params.
func (w *ServerInterfaceWrapper) Venues(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params VenuesParams
	// ------------- Optional query parameter "venueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "venueIds", ctx.QueryParams(), &params.VenueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter venueIds: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "gameTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameTypes", ctx.QueryParams(), &params.GameTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameTypes: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", ctx.QueryParams(), &params.Active)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter active: %s", err))
	}

	// ------------- Optional query parameter "includeEvents" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeEvents", ctx.QueryParams(), &params.IncludeEvents)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeEvents: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "sportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportIds", ctx.QueryParams(), &params.SportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportIds: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Venues(ctx, params)
	return err
}

// Venues1 converts echo context to params.
func (w *ServerInterfaceWrapper) Venues1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "venueId" -------------
	var venueId int32

	err = runtime.BindStyledParameterWithOptions("simple", "venueId", ctx.Param("venueId"), &venueId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter venueId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params Venues1Params
	// ------------- Optional query parameter "venueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "venueIds", ctx.QueryParams(), &params.VenueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter venueIds: %s", err))
	}

	// ------------- Optional query parameter "leagueId" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueId", ctx.QueryParams(), &params.LeagueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueId: %s", err))
	}

	// ------------- Optional query parameter "leagueIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "leagueIds", ctx.QueryParams(), &params.LeagueIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter leagueIds: %s", err))
	}

	// ------------- Optional query parameter "gameType" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameType", ctx.QueryParams(), &params.GameType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameType: %s", err))
	}

	// ------------- Optional query parameter "gameTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameTypes", ctx.QueryParams(), &params.GameTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameTypes: %s", err))
	}

	// ------------- Optional query parameter "season" -------------

	err = runtime.BindQueryParameter("form", true, false, "season", ctx.QueryParams(), &params.Season)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter season: %s", err))
	}

	// ------------- Optional query parameter "seasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "seasons", ctx.QueryParams(), &params.Seasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seasons: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", ctx.QueryParams(), &params.Active)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter active: %s", err))
	}

	// ------------- Optional query parameter "includeEvents" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeEvents", ctx.QueryParams(), &params.IncludeEvents)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeEvents: %s", err))
	}

	// ------------- Optional query parameter "sportId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportId", ctx.QueryParams(), &params.SportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportId: %s", err))
	}

	// ------------- Optional query parameter "sportIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sportIds", ctx.QueryParams(), &params.SportIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sportIds: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Venues1(ctx, venueId, params)
	return err
}

// VideoResolutionTypes converts echo context to params.
func (w *ServerInterfaceWrapper) VideoResolutionTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VideoResolutionTypes(ctx)
	return err
}

// ViolationTypes converts echo context to params.
func (w *ServerInterfaceWrapper) ViolationTypes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ViolationTypes(ctx)
	return err
}

// WeatherForecast converts echo context to params.
func (w *ServerInterfaceWrapper) WeatherForecast(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Path parameter "roofType" -------------
	var roofType RoofType

	err = runtime.BindStyledParameterWithOptions("simple", "roofType", ctx.Param("roofType"), &roofType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter roofType: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params WeatherForecastParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WeatherForecast(ctx, gamePk, roofType, params)
	return err
}

// WeatherDataBasedOnPlay converts echo context to params.
func (w *ServerInterfaceWrapper) WeatherDataBasedOnPlay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gamePk" -------------
	var gamePk int32

	err = runtime.BindStyledParameterWithOptions("simple", "gamePk", ctx.Param("gamePk"), &gamePk, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gamePk: %s", err))
	}

	// ------------- Path parameter "playId" -------------
	var playId string

	err = runtime.BindStyledParameterWithOptions("simple", "playId", ctx.Param("playId"), &playId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params WeatherDataBasedOnPlayParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WeatherDataBasedOnPlay(ctx, gamePk, playId, params)
	return err
}

// WeatherBasic converts echo context to params.
func (w *ServerInterfaceWrapper) WeatherBasic(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "venueId" -------------
	var venueId int32

	err = runtime.BindStyledParameterWithOptions("simple", "venueId", ctx.Param("venueId"), &venueId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter venueId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params WeatherBasicParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WeatherBasic(ctx, venueId, params)
	return err
}

// WeatherFull converts echo context to params.
func (w *ServerInterfaceWrapper) WeatherFull(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "venueId" -------------
	var venueId int32

	err = runtime.BindStyledParameterWithOptions("simple", "venueId", ctx.Param("venueId"), &venueId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter venueId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params WeatherFullParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WeatherFull(ctx, venueId, params)
	return err
}

// WeatherTrajectoryConfidences converts echo context to params.
func (w *ServerInterfaceWrapper) WeatherTrajectoryConfidences(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WeatherTrajectoryConfidences(ctx)
	return err
}

// WindDirection converts echo context to params.
func (w *ServerInterfaceWrapper) WindDirection(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params WindDirectionParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WindDirection(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1.1/game/:game_pk/feed/live", wrapper.LiveGameV1)
	router.GET(baseURL+"/api/v1.1/game/:game_pk/feed/live/diffPatch", wrapper.LiveGameDiffPatchV1)
	router.GET(baseURL+"/api/v1.1/game/:game_pk/feed/live/timestamps", wrapper.LiveTimestampv11)
	router.GET(baseURL+"/api/v1/achievementStatuses", wrapper.AchievementStatuses)
	router.GET(baseURL+"/api/v1/analytics/game", wrapper.GameGuidsFromPostgresRangeByGame)
	router.GET(baseURL+"/api/v1/analytics/guids", wrapper.GameGuidsFromPostgresRange)
	router.GET(baseURL+"/api/v1/attendance", wrapper.GetTeamAttendance)
	router.GET(baseURL+"/api/v1/awards", wrapper.Awards)
	router.GET(baseURL+"/api/v1/awards/:awardId", wrapper.Awards1)
	router.GET(baseURL+"/api/v1/awards/:awardId/recipients", wrapper.AwardRecipients)
	router.GET(baseURL+"/api/v1/baseballStats", wrapper.BaseballStats)
	router.GET(baseURL+"/api/v1/batTracking/game/:gamePk/:playId", wrapper.BatTracking)
	router.GET(baseURL+"/api/v1/broadcast", wrapper.GetBroadcasts)
	router.GET(baseURL+"/api/v1/broadcastAvailability", wrapper.BroadcastAvailabilityTypes)
	router.GET(baseURL+"/api/v1/broadcasters", wrapper.GetAllBroadcasters)
	router.GET(baseURL+"/api/v1/coachingVideoTypes", wrapper.CoachingVideoTypes)
	router.GET(baseURL+"/api/v1/conferences", wrapper.Conferences)
	router.GET(baseURL+"/api/v1/conferences/:conferenceId", wrapper.Conferences1)
	router.GET(baseURL+"/api/v1/divisions", wrapper.Divisions)
	router.GET(baseURL+"/api/v1/divisions/:divisionId", wrapper.Divisions1)
	router.GET(baseURL+"/api/v1/draft", wrapper.DraftPicks)
	router.GET(baseURL+"/api/v1/draft/prospects", wrapper.DraftProspects)
	router.GET(baseURL+"/api/v1/draft/prospects/:year", wrapper.DraftProspects1)
	router.GET(baseURL+"/api/v1/draft/:year", wrapper.DraftPicks1)
	router.GET(baseURL+"/api/v1/draft/:year/latest", wrapper.LatestDraftPicks)
	router.GET(baseURL+"/api/v1/eventStatus", wrapper.EventStatus)
	router.GET(baseURL+"/api/v1/eventTypes", wrapper.EventTypes)
	router.GET(baseURL+"/api/v1/fielderDetailTypes", wrapper.FielderDetailTypes)
	router.GET(baseURL+"/api/v1/freeGameTypes", wrapper.FreeGameTypes)
	router.GET(baseURL+"/api/v1/game/changes", wrapper.CurrentGameStats1)
	router.GET(baseURL+"/api/v1/game/lastPitch", wrapper.GameLastPitch)
	router.GET(baseURL+"/api/v1/game/:gamePk/contextMetrics", wrapper.GetGameContextMetrics)
	router.GET(baseURL+"/api/v1/game/:gamePk/guids", wrapper.GameGuids)
	router.GET(baseURL+"/api/v1/game/:gamePk/winProbability", wrapper.GetWinProbability)
	router.GET(baseURL+"/api/v1/game/:gamePk/withMetrics", wrapper.GetGameWithMetrics)
	router.GET(baseURL+"/api/v1/game/:gamePk/:guid/analytics", wrapper.ParsedJsonFormattedAnalytics)
	router.GET(baseURL+"/api/v1/game/:gamePk/:guid/contextMetrics", wrapper.ContextMetrics)
	router.GET(baseURL+"/api/v1/game/:gamePk/:guid/contextMetricsAverages", wrapper.ContextMetricsWithAverages)
	router.POST(baseURL+"/api/v1/game/:gamePk/:guid/contextMetricsAverages", wrapper.ContextMetricsWithAveragesPost)
	router.GET(baseURL+"/api/v1/game/:gamePk/:guid/homeRunBallparks", wrapper.HomeRunBallparks)
	router.GET(baseURL+"/api/v1/game/:gamePk/:playId/analytics/biomechanics/:positionId", wrapper.Biomechanical)
	router.GET(baseURL+"/api/v1/game/:gamePk/:playId/analytics/skeletalData/chunked", wrapper.SkeletalChunked)
	router.GET(baseURL+"/api/v1/game/:gamePk/:playId/analytics/skeletalData/files", wrapper.SkeletalDataFileNames)
	router.GET(baseURL+"/api/v1/game/:game_pk/boxscore", wrapper.Boxscore)
	router.GET(baseURL+"/api/v1/game/:game_pk/content", wrapper.Content)
	router.GET(baseURL+"/api/v1/game/:game_pk/feed/color", wrapper.ColorFeed)
	router.GET(baseURL+"/api/v1/game/:game_pk/feed/color/timestamps", wrapper.ColorTimestamps)
	router.GET(baseURL+"/api/v1/game/:game_pk/linescore", wrapper.Linescore)
	router.GET(baseURL+"/api/v1/game/:game_pk/playByPlay", wrapper.PlayByPlay)
	router.GET(baseURL+"/api/v1/gamePace", wrapper.GamePace)
	router.GET(baseURL+"/api/v1/gameStatus", wrapper.GameStatus)
	router.POST(baseURL+"/api/v1/gameStatus", wrapper.UpdateGameStatuses)
	router.GET(baseURL+"/api/v1/gameTypes", wrapper.GameTypes)
	router.GET(baseURL+"/api/v1/gamedayTypes", wrapper.GamedayTypes)
	router.GET(baseURL+"/api/v1/groupByTypes", wrapper.GroupByTypes)
	router.GET(baseURL+"/api/v1/highLow/types", wrapper.HighLowStats)
	router.GET(baseURL+"/api/v1/highLow/:highLowType", wrapper.HighLow)
	router.GET(baseURL+"/api/v1/hitTrajectories", wrapper.HitTrajectories)
	router.GET(baseURL+"/api/v1/homeRunDerby", wrapper.HomeRunDerbyBracket1)
	router.GET(baseURL+"/api/v1/homeRunDerby/bracket", wrapper.HomeRunDerbyBracket3)
	router.GET(baseURL+"/api/v1/homeRunDerby/mixed", wrapper.HomeRunDerbyMixedMode1)
	router.GET(baseURL+"/api/v1/homeRunDerby/pool", wrapper.HomeRunDerbyPool1)
	router.GET(baseURL+"/api/v1/homeRunDerby/:gamePk", wrapper.HomeRunDerbyBracket)
	router.GET(baseURL+"/api/v1/homeRunDerby/:gamePk/bracket", wrapper.HomeRunDerbyBracket2)
	router.GET(baseURL+"/api/v1/homeRunDerby/:gamePk/mixed", wrapper.HomeRunDerbyMixedMode)
	router.GET(baseURL+"/api/v1/homeRunDerby/:gamePk/pool", wrapper.HomeRunDerbyPool)
	router.GET(baseURL+"/api/v1/jobTypes", wrapper.JobTypes)
	router.POST(baseURL+"/api/v1/jobTypes", wrapper.UpdateJobTypes)
	router.GET(baseURL+"/api/v1/jobs", wrapper.GetJobsByType)
	router.GET(baseURL+"/api/v1/jobs/datacasters", wrapper.Datacasters)
	router.GET(baseURL+"/api/v1/jobs/officialScorers", wrapper.OfficialScorers)
	router.GET(baseURL+"/api/v1/jobs/umpires", wrapper.Umpires)
	router.GET(baseURL+"/api/v1/jobs/umpires/games/:umpireId", wrapper.UmpireSchedule)
	router.GET(baseURL+"/api/v1/languages", wrapper.Languages)
	router.GET(baseURL+"/api/v1/league", wrapper.League)
	router.GET(baseURL+"/api/v1/league/allStarBallot", wrapper.AllStarBallot)
	router.GET(baseURL+"/api/v1/league/:leagueId", wrapper.League1)
	router.GET(baseURL+"/api/v1/league/:leagueId/allStarBallot", wrapper.AllStarBallot1)
	router.GET(baseURL+"/api/v1/league/:leagueId/allStarFinalVote", wrapper.AllStarFinalVote)
	router.GET(baseURL+"/api/v1/league/:leagueId/allStarWriteIns", wrapper.AllStarWriteIns)
	router.GET(baseURL+"/api/v1/leagueLeaderTypes", wrapper.LeagueLeaderTypes)
	router.GET(baseURL+"/api/v1/leagues", wrapper.League2)
	router.GET(baseURL+"/api/v1/leagues/allStarBallot", wrapper.AllStarBallot2)
	router.GET(baseURL+"/api/v1/leagues/:leagueId", wrapper.League3)
	router.GET(baseURL+"/api/v1/leagues/:leagueId/allStarBallot", wrapper.AllStarBallot3)
	router.GET(baseURL+"/api/v1/leagues/:leagueId/allStarFinalVote", wrapper.AllStarFinalVote1)
	router.GET(baseURL+"/api/v1/leagues/:leagueId/allStarWriteIns", wrapper.AllStarWriteIns1)
	router.GET(baseURL+"/api/v1/logicalEvents", wrapper.LogicalEvents)
	router.GET(baseURL+"/api/v1/lookup/values/all", wrapper.GetLookupValues)
	router.GET(baseURL+"/api/v1/mediaState", wrapper.MediaStateTypes)
	router.GET(baseURL+"/api/v1/metrics", wrapper.Metrics)
	router.GET(baseURL+"/api/v1/milestoneDurations", wrapper.MilestoneDurations)
	router.GET(baseURL+"/api/v1/milestoneLookups", wrapper.MilestoneLookups)
	router.GET(baseURL+"/api/v1/milestoneStatistics", wrapper.MilestoneStatistics)
	router.GET(baseURL+"/api/v1/milestoneTypes", wrapper.MilestoneTypes)
	router.GET(baseURL+"/api/v1/milestones", wrapper.Milestones)
	router.GET(baseURL+"/api/v1/moundVisitTypes", wrapper.MoundVisitTypes)
	router.GET(baseURL+"/api/v1/people", wrapper.Person1)
	router.GET(baseURL+"/api/v1/people/changes", wrapper.CurrentGameStats)
	router.GET(baseURL+"/api/v1/people/freeAgents", wrapper.FreeAgents)
	router.GET(baseURL+"/api/v1/people/search", wrapper.Search)
	router.GET(baseURL+"/api/v1/people/:personId", wrapper.Person)
	router.GET(baseURL+"/api/v1/people/:personId/awards", wrapper.Award)
	router.GET(baseURL+"/api/v1/people/:personId/stats", wrapper.Stats3)
	router.GET(baseURL+"/api/v1/people/:personId/stats/game/:gamePk", wrapper.PlayerGameStats)
	router.GET(baseURL+"/api/v1/people/:personId/stats/metrics", wrapper.StatsMetrics)
	router.GET(baseURL+"/api/v1/performerTypes", wrapper.PerformerTypes)
	router.GET(baseURL+"/api/v1/pitchCodes", wrapper.PitchCodes)
	router.GET(baseURL+"/api/v1/pitchTypes", wrapper.PitchTypes)
	router.GET(baseURL+"/api/v1/platforms", wrapper.Platforms)
	router.GET(baseURL+"/api/v1/playerStatusCodes", wrapper.PlayerStatusCodes)
	router.GET(baseURL+"/api/v1/positions", wrapper.Positions)
	router.GET(baseURL+"/api/v1/props/play/predictions", wrapper.GetProps)
	router.GET(baseURL+"/api/v1/props/play/predictions/adjust", wrapper.GetPropsAdjust)
	router.GET(baseURL+"/api/v1/review", wrapper.GetReviewInfo)
	router.GET(baseURL+"/api/v1/reviewReasons", wrapper.ReviewReasons)
	router.GET(baseURL+"/api/v1/roofTypes", wrapper.RoofTypes)
	router.GET(baseURL+"/api/v1/rosterTypes", wrapper.RosterTypes)
	router.GET(baseURL+"/api/v1/ruleSettings", wrapper.RuleSettings)
	router.GET(baseURL+"/api/v1/runnerDetailTypes", wrapper.RunnerDetailTypes)
	router.GET(baseURL+"/api/v1/schedule", wrapper.Schedule)
	router.GET(baseURL+"/api/v1/schedule/games/tied", wrapper.TieGames)
	router.GET(baseURL+"/api/v1/schedule/postseason", wrapper.PostseasonSchedule)
	router.GET(baseURL+"/api/v1/schedule/postseason/series", wrapper.PostseasonScheduleSeries)
	router.GET(baseURL+"/api/v1/schedule/postseason/tuneIn", wrapper.TuneIn)
	router.GET(baseURL+"/api/v1/schedule/trackingEvents", wrapper.TrackingEventsSchedule)
	router.GET(baseURL+"/api/v1/schedule/:scheduleType", wrapper.Schedule1)
	router.GET(baseURL+"/api/v1/scheduleEventTypes", wrapper.ScheduleEventTypes)
	router.GET(baseURL+"/api/v1/scheduleTypes", wrapper.ScheduleTypes)
	router.GET(baseURL+"/api/v1/seasons", wrapper.Seasons)
	router.GET(baseURL+"/api/v1/seasons/all", wrapper.AllSeasons)
	router.GET(baseURL+"/api/v1/seasons/:seasonId", wrapper.Seasons1)
	router.GET(baseURL+"/api/v1/situationCodes", wrapper.SitCodes)
	router.GET(baseURL+"/api/v1/sky", wrapper.Sky)
	router.GET(baseURL+"/api/v1/sortModifiers", wrapper.AggregateSortEnum)
	router.GET(baseURL+"/api/v1/sports", wrapper.Sports)
	router.GET(baseURL+"/api/v1/sports/:sportId", wrapper.Sports1)
	router.GET(baseURL+"/api/v1/sports/:sportId/allSportBallot", wrapper.AllSportBallot)
	router.GET(baseURL+"/api/v1/sports/:sportId/players", wrapper.SportPlayers)
	router.GET(baseURL+"/api/v1/standings", wrapper.Standings1)
	router.GET(baseURL+"/api/v1/standings/:standingsType", wrapper.Standings)
	router.GET(baseURL+"/api/v1/standingsTypes", wrapper.StandingsTypes)
	router.GET(baseURL+"/api/v1/statFields", wrapper.StatFields)
	router.GET(baseURL+"/api/v1/statGroups", wrapper.StatGroups)
	router.GET(baseURL+"/api/v1/statTypes", wrapper.StatTypes)
	router.GET(baseURL+"/api/v1/statcastPositionTypes", wrapper.StatcastPositionTypes)
	router.GET(baseURL+"/api/v1/stats", wrapper.Stats2)
	router.GET(baseURL+"/api/v1/stats/analytics/outsAboveAverage", wrapper.GetOutsAboveAverage)
	router.GET(baseURL+"/api/v1/stats/analytics/sprayChart", wrapper.GetSprayChart)
	router.GET(baseURL+"/api/v1/stats/analytics/stolenBaseProbability", wrapper.GetStolenBaseProbability)
	router.GET(baseURL+"/api/v1/stats/grouped", wrapper.GroupedStats)
	router.GET(baseURL+"/api/v1/stats/leaders", wrapper.Leaders2)
	router.GET(baseURL+"/api/v1/stats/metrics", wrapper.MetricStats)
	router.GET(baseURL+"/api/v1/stats/search", wrapper.BeastStats)
	router.GET(baseURL+"/api/v1/stats/search/config", wrapper.StatSearchConfig)
	router.GET(baseURL+"/api/v1/stats/search/groupByTypes", wrapper.StatSearchGroupByTypes)
	router.GET(baseURL+"/api/v1/stats/search/params", wrapper.StatSearchParams)
	router.GET(baseURL+"/api/v1/stats/search/stats", wrapper.StatSearchStats)
	router.GET(baseURL+"/api/v1/streaks", wrapper.GetStreaks)
	router.GET(baseURL+"/api/v1/streaks/types", wrapper.StreakTypes)
	router.GET(baseURL+"/api/v1/teams", wrapper.Teams)
	router.GET(baseURL+"/api/v1/teams/affiliates", wrapper.Affiliates1)
	router.GET(baseURL+"/api/v1/teams/history", wrapper.AllTeams1)
	router.GET(baseURL+"/api/v1/teams/stats", wrapper.Stats1)
	router.GET(baseURL+"/api/v1/teams/stats/leaders", wrapper.Leaders1)
	router.GET(baseURL+"/api/v1/teams/:teamId", wrapper.Teams1)
	router.GET(baseURL+"/api/v1/teams/:teamId/affiliates", wrapper.Affiliates)
	router.GET(baseURL+"/api/v1/teams/:teamId/alumni", wrapper.Alumni)
	router.POST(baseURL+"/api/v1/teams/:teamId/alumni", wrapper.UpdateAlumni)
	router.GET(baseURL+"/api/v1/teams/:teamId/coaches", wrapper.Coaches)
	router.GET(baseURL+"/api/v1/teams/:teamId/history", wrapper.AllTeams)
	router.GET(baseURL+"/api/v1/teams/:teamId/leaders", wrapper.Leaders)
	router.GET(baseURL+"/api/v1/teams/:teamId/personnel", wrapper.Personnel)
	router.GET(baseURL+"/api/v1/teams/:teamId/roster", wrapper.Roster)
	router.GET(baseURL+"/api/v1/teams/:teamId/roster/:rosterType", wrapper.Roster1)
	router.GET(baseURL+"/api/v1/teams/:teamId/stats", wrapper.Stats)
	router.GET(baseURL+"/api/v1/trackingSoftwareVersions", wrapper.TrackingSoftwareVersions)
	router.GET(baseURL+"/api/v1/trackingSystemOwners", wrapper.TrackingSystemOwners)
	router.GET(baseURL+"/api/v1/trackingVendors", wrapper.TrackingVendors)
	router.GET(baseURL+"/api/v1/trackingVersions", wrapper.TrackingVersions)
	router.GET(baseURL+"/api/v1/transactionTypes", wrapper.TransactionTypes)
	router.GET(baseURL+"/api/v1/transactions", wrapper.Transactions)
	router.GET(baseURL+"/api/v1/uniforms/game", wrapper.UniformsByGame)
	router.GET(baseURL+"/api/v1/uniforms/team", wrapper.UniformsByTeam)
	router.GET(baseURL+"/api/v1/venues", wrapper.Venues)
	router.GET(baseURL+"/api/v1/venues/:venueId", wrapper.Venues1)
	router.GET(baseURL+"/api/v1/videoResolutionTypes", wrapper.VideoResolutionTypes)
	router.GET(baseURL+"/api/v1/violationTypes", wrapper.ViolationTypes)
	router.GET(baseURL+"/api/v1/weather/game/:gamePk/forecast/:roofType", wrapper.WeatherForecast)
	router.GET(baseURL+"/api/v1/weather/game/:gamePk/:playId", wrapper.WeatherDataBasedOnPlay)
	router.GET(baseURL+"/api/v1/weather/venues/:venueId/basic", wrapper.WeatherBasic)
	router.GET(baseURL+"/api/v1/weather/venues/:venueId/full", wrapper.WeatherFull)
	router.GET(baseURL+"/api/v1/weatherTrajectoryConfidences", wrapper.WeatherTrajectoryConfidences)
	router.GET(baseURL+"/api/v1/windDirection", wrapper.WindDirection)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9/Y7jOJYn+iqG7wX2XiC6p7tqZnp6gMVCtuWwKh2SV5IjMmux0DAs2manLKklKiKj",
	"Fg3Mayxw9+X6SS74pW9KpOzIzJqpfzLD4uE3eXh4eM7v/K/5IbmkSQxjnM//9X/N88MZXgD903hOCkz+",
	"SLMkhRlGkH4GeAGwFYfwC/l1TLILwPN/naMY//jD/G6O31LIfsITzOZ/u5sfQIrRC8AoPmllS9K3DJ3O",
	"tAk8OccZik8kFcahjy6wUVYIMPwdJl/vuhnOIDpacUx+9ZV3BrnDehvC/JChFKMknv/rfJXAfIbPcJZG",
	"4G2G4kNUhHAG4llS4P9W1fOcJBEEMS/JhS8IvtbqqSWjsg0KY4DyZXJJI4ihpLDcOySkC7sIvMlI/CTt",
	"dLxGkGOQYZ2x/Fv5JXn+CzxgUogRhoiMGIgWKOmumXNygX7yGvcOPQqVRmO0Whfm2GFJnQYML6aB5vXW",
	"ejpl8AQw9JIM+28pNOPiQvJC+v//mIOX0/xufgFfyL8ont/NScLdPP2nP5B///RP5N8/k7/J5mPJAf3z",
	"f/as3E51wx0NYW8fh0egsejVBiGKPAyydtft+d380/xuvp7fzf353dyZ382t/m7FIHrD6JDfgwt8gBiE",
	"AIOhroEiRHifkpUZGnhCJ0/gAnefe5MiFPcnXCDO0CEfrrYYTH1BIUyGCugd3r7RecpAmsJs+kInI0DJ",
	"EIYX+sf/ncHj/F/n/9c/VMfAP/Az4B/GZqhqN8gy8EZ/JxhElii8vqf/+R9V97SolfA0pXVBDiS7uDzD",
	"TJGtqqwkEB2KiBA8sBWgPGrLVs7hATskMYZfsPECM3CC71zLe3dlaOkdMjgw3LXjvHfRrgCWJz5wnjfU",
	"lXtO5zsjnOBUsPOoT0JgSybvP0fPCHvwdIExHmvLpqRsDuj5LcwAYcHNGeq0pD3weiJF/AIiFPoZOHx+",
	"r5WA8g3CMnHkAcQFiGSpO3T4nByP8mR8OMtloax4fobhREHoAjFYAQzGxsLDAHtphHDeHAWloyKmfMo5",
	"smE0syzJcsWZS0GWw3CNov6dkLKR02KEKRlO/RyK63xXo20OFS1FuuGJqL14EyLtUA0LkMNnEEWEtlUD",
	"+1JE460sKZslZOBVOtYNmbknNUOf4c9JDK34mIzV/1OexDbhYGQjyYokCUuZaCcSneMxh5MllLF2WmsI",
	"w+YQXSfZ1M/3qyUbMt8TJBuJjPHOks1QN8ly5nsmH1/+UbRLcn4FWnX68AzweBGYHgUoPjXz9gpAOkfE",
	"MokxQHFjUlm56JkdcyrMdlmRywr8zyJBhQicMnDpF04mig7XnnnXs9mUr98HkFJhvrzR7xrbQukUgFme",
	"xL1DXG3CPDniV5DBR5jlYrxU2fMVjB1kJ4jFXlVfP9XufgDpCIMi2xiG5ovgHGoVROCNZhkufOoJ8QoB",
	"PjPhYijnEyPrngL9fDRNI3Sgy33wXhiHWYLCHTh8Bqf+k5OT7LNogjoBHRKJQivGXDrqJiX5UHtQksva",
	"EgOZtJShC8h6tX+9g5dhdGBiTWu4qgTVVR3yW5maBpbwCphZoaqcgDGMQxAfoAsPSRYOqwAELT8GjFcm",
	"PKooA9p5N0lLF6qR9xMOtbNu0Ok8KZP0Utwku+crR4WFeoczDIsIEkGnuZOrMrfJq3Zzt8mrQmu3yeut",
	"G+ukkNz4/hSCN+PlpN1unp3PrnZ2nwiN03KRFk/LOWnt05yTVj7N+QnmGGaTm6y+bcb1mz79OK4NKhX3",
	"Qi9Kxk1nwmimDX060MykkyFhK3B6Ho2F1MinsYwa+TQWUSPfNsnxlHzqawdDJj2r8BYfghZPeYMgm3B0",
	"DRxa4l2HdmP8zio/D0f3RUZzaNyPB+tqCoe9A/AKsrDb4155oU9UGH6OupufUY6ThszTfMzbgROUCVIS",
	"9S66DOSJIDgVo1xly6iGhLU4aeqPq5QkO4EY/UKlWkt1RTORSu9+xNcDShGMsWCWPSvmrwXMMYpP+xxm",
	"bjIuGFIampNc8jTWGlkr/A7Zc/PIIcglqyA/Jxm2ZUOdJxl2slBZs5mnSTZ6i/Uo0QReQpVwOcx2GXpB",
	"EdRRVJRZOsNzNy9i9NcCcrUUzgpI7mpijSl0mtIaLwBF4DlSZduvKI5hpjnDTzSTBvuYrgv8LtjM5Mec",
	"d2ZPTVY+gVFN4TktzboC95nMQ4b1GN8hN2k1+CoZ5Z23/tBe5SrA5j6dfoqwiVI+CL8Sa/1qnK+5kHXN",
	"mSayHs0xv2IwJsmTfBy7cjRJXKnyfEptqV83AXtv1pOvaDblSuAlxRLrvTjBpjw1ZRVqN2+q2FjX4Cn0",
	"KwMSo6oBLjxFriJ5rPA6DtZZlz17Tnsp6FzRbnCsyob7mjNFOmCDj5h0k+kf3xOfxvraWH8aXY0YkB2S",
	"+IhCGB+mWE6K96vRl8AkyUIUAwxbT2i4Y3qbFORALjvFTEbaVgCjL9B9dgEqdchkshcYJQeE3yZ2dGyS",
	"Ou/XuqaNMIYZOtSfzpXWXq99Snv1XW/bdSO7Ge0HxIF9oHTyCr5gLLzlGUQRjE+wd7+/lcm5Cy8AaZik",
	"NXPvcxhOzui8wAwXWXxFER4GcagqRB94VhSf/Akn1xnkVeUSs8LkAqcPbTO3xtB2M2oPbbcIraGN0AXh",
	"P+OzpWPdmFHPC1cmX6iu8JGz7U3vNKXOINctFh1JQnFRTetDNmVoF8mX/JBk0E4wnM7hI/AM+/UfLyAq",
	"4BVtesoaxhWa7ToiGIVbxF4vFJny4Lj0GXcgHE3t4fSeIW7l8k6dSo5HdED86UOpDofnGC6XnrUoPtlC",
	"G6J+BSaicn6tHRLZMWIUem2QcJLuYEbYmc79uW7sCrN7cIFea3q1TvTv7zj/D3uYfu2jbAUPKOd3kubM",
	"DqgamNYIhjuYpIzXyPZAdz03PtzNXzOEoRNHb6XiLEryKQqHYfXHFdpF8AL1W/NVlYy6zVNZD19fpThh",
	"3pv8TH+mWgaIEwZz/NoqhvUI4xwOW3NjfN0AkBJQfNJ5ezgAfDhfV+sBxle2e0xmynJ8TfEo3ijs96ES",
	"Ini8qgVJvIKHz9eUQOWUK3V+YoQn7y94SOLwqhLOSYZznKRXmWlfdR/CZ5SF77THM3DEW4BhfsWDTAy/",
	"4H2qLejRundZkqfwMKKgivV8uNTXrbQN44OGrhmykBShN1JarRNd6mHZKN/pvXM8o9w7nJMk0nhWupRa",
	"yh4/jzyNwNsOHT5ruebRIdNsOs3jYYCL0bFeVaTCbJLmVrG3XAlCkRPGpwjl50VUZM/9AgcEYX5O8Fbm",
	"mK+iwtgmzEvgqreyc4KTdQQkTqOp7iyRDG5SxKHUiZOmbqXKDkLyKFF4sFQYEhYpdRcU70RKd5DJVmCk",
	"E9pLOKfbaFRlz6gofVJg6romzC26b43oRC5diyQu+rdbnoJ4cCl+x6ZeryDfghzvOEPvLs9XkO9Anst8",
	"ol9B7sEIHrCMQMPodezE+CaM9lk6q2O+dlfwYG2O2IIBuCXra0nNOa1X7iJPFsvtbA3a4u7NWaWcD+ow",
	"uXdnVS2B+QZM66uZssskrCni3Cdereqc5NMkZrpkpmpFe0vQ9UVHOtAaE6T9TLIphjp2Dy7QiGDW96JF",
	"PluhBAcHw5PMBnbMfpZeDVcjRJMsfvqNFJT6P/i2N3UkrkHXeqdx6ltC2iO2ZG7vY++hTyjeZckzeEYR",
	"txBRsDRhOqY1glHogcM6emsVMchXOxnGEQO/pFTQIVcYlGN0yFUd37t2E6ebeCmSc3zSyEXwiG84bnTM",
	"blleEccwc2L//dQy9wwTCpD/Bxk1iGAcgoy6uFurKXuXzsIGAq5/7fU51JIcSIYQvEmN3yUeAKmqPDNk",
	"406TVky4lWDJwOcMgs+Szk5kI2OmXeC59XSnsmIkBht/u2NsXP8E7jsi9FE6AIbCpE+10hXA0EeXVi+O",
	"EThptX0dgdN0PiXZUrwUFcCLe07XgsUiwsojytG4Ou+hIm3p2vm7P33wvkphLkp6hPG4xwwl6gKe8Ef7",
	"d4cq4cgOZFIOIL/yPSalPDqCO/booLWwdjxv241HoNyqlOPy5+xGCUUEPUjft9R3q1vLNObsc0gI87/R",
	"COZKalJql0Epuy8cN7EsGVk0LxMXth5Si+Y53eZu3QPgkl6mHM68aHUQkhC82UOg0ivtEgVHUfZASTJ0",
	"QrFGhgzmRQWBqUGu1xGWL1xnyUWzrjKPXoUStLux9SSU8d1rCNkedrJB4s29q8USVDuYHeEB3zfd/VqW",
	"QuPFCarR4hBDlxgusM9wpso4XEd/3s14L4YzTqlUuzL9SuLBWUmHZ0NlfY1deG+40hSgyW+3Dt914Lb0",
	"knQdhuN1R3RpCDx6iVbrS36FxRTCK5RjwL2KVEWtzhhy75MUwvDacpgPyvUljY4dehm98T0L+1hNq2Id",
	"I6OQm72pq2C7dnLMuz7UFJi7q4dhzEOtPm9Fhu4VRMtYmGHp6s7gNkk+o/g6rPmdqs7iDEFIxqe3pM/o",
	"INNHXGCIAOndMzh87r4KShzjUp5B/dJRDYioTO9ZQSDoX+njBi6wB99RwQrzhA4gmpKVyGgeBpe0l/oV",
	"IDzZ73bkhnmV442+RaKOS4y+rvK6OVdRVA+o23Q3ozQYRsQZuxYr7B4GGrizI/tncNw5Bn3HILc8ARU0",
	"7VPsd9laS7Lwo+pDCCH+pEg8+JbUJyvXMuQKVv0dVjBg1X8GWRjDPJcJQPovG5rRkRYgy6A0loD3mmSh",
	"9yoF/I9AHKL4pPgMlGGTqgdALesuyVUnucrxSTlHjh8gyIsMhtPaWMSHsxGfIqhcI8mhUte2oizz6eyr",
	"SFjm9b+fT7CLZtqIsDjAcNnw59dz/tJ+iU4wiOqCvoqLfQbIlpK9JVfJKjOxQdhvZpj2TLNBeFRm1+Od",
	"hwoIQAMzQMW/9eZc59swktb14Irt3i7pa2z8vjpvxgKu3cnf3a5UFloSvEyi8Ockhn2SYpT034PyVwix",
	"dFNgKJHfX6T2c78ksTYHqZo+LO7KOjG87b+HLlYOnC23ShrHRwMxl2XQgMo9I6xTPiHXKD2CR+zEpJca",
	"dVSZNGri4QJVQH7piRDZRf/DUFbEOgNCyJWbObQEtnUtTveCqhXRiWTY8HdxRXIrr2DQ+pXO23JaNIr1",
	"RI8U6af4Z5O/Vbv6DPC0Kmg2bhQ/UYqceudj+XaKeFBlfkH/FX09W9Z3EzLXg/mpPfYdiiyDMdZygW/k",
	"cRg/kENwTFkwZcZ8oT/2VeZVAffpYuK6aRVjTfBs7SnGmeCeWnrmCu6hl1VLyXQq7SRGw8pUJhVCUafF",
	"ZUkGDS5LyIe5LKHQ5rIkkw6XFU962igYHMaBDFh+YxQHNHFpMq3OBkRHCcwMSSYNhgPp+vZ8nNf0Bqgc",
	"igXZC2AhTG4ngVj09yuZuEWTeK3vPs8yehPcvVnOCca8NGOhvPEmq324TZ6dYCsu5+gq67zamdy1ykty",
	"7EydAZZ56iyw3BNn4gpfztI+fEKt7yimUycsalsfWhWLULKQJuM/7ZCbCHdQhY9TbSQFNZjWRowk5h94",
	"OALuV/FaVbpcjUXIzG8SLuhdZdKQocOo2x60wWS+/sHJOjUW23kkjLL8uDtqDYhz7BkQjeNkKm/Q26TC",
	"qlfLnoPIal1DecmuVdovPSVOej8X5dzmvbwqbawTRdrf3l1lbq+HkVfxwjaUb3KB71Dqe4KnTT+5vwuG",
	"XqRjq/K6+bjGW+f61TDV0bjL3t4JPExdJSXorgcg+96xv74L7K7JF4m+YryrcbwmXy5uDSj23WKB7UoI",
	"jBYLK1n9Ao06yRkN4r/dzTXiikbFJUZbkGNP7uLJw/hqBF/gcX97eOeUMA595TwD7KFwHBPlLQYXdNgm",
	"yeciFUhRnIVV263T42eU4fMS4beB1KSIcTZAoOzwQqmpxL3LkhckixkhzJul8aT4NWKKhi+EYKC/LHWg",
	"v5RgpR4iDaj0N4QpPi/PQMftdlXm6VszFDFEK4w5zCiEhhBfewsU+Bq31ozq4ptU8HbTMUL6OgnDgllV",
	"qPjrmg1i8YQg03rTY5swH+maphTy1CKK1g/bwfTt+mEwXZp4grHMP/8MhSSiZIdOdV0Q6mWw4sNZ+c4o",
	"7gpGjVPfcCmWxZfM+x0KXzbZ1zvUsGpylHeooVz+71T+A/oCwzU3iHqH8m34BVMjsPcaICbv/JQ852aM",
	"MwTftx43yTHM3rkmekzszglO3qsKF0YAo5d364KXHBDTOL5H4e/waCjKfkde8YhCePMJRaoYgyhGw+ci",
	"yo0DWRJS1+AIwywGGC5BigGKZXQjybvSfbIv1U2Sz0jahEeYoSOS4QJGID4V4ASVYRcjkOP1oDRAKKwY",
	"DRMMJtLuqsd9vKAwjOTy+KXOrNWU5ZS6Rwa7RM8r+Fxg5abF4ALXQrrqB5AGF/gAcIYiFEPJe0NM3ajg",
	"EX2RJntRcZIm+pIQMySVbSnZlSNuHERaAm0dHKsX1xodPkvnTCRqurTJHyjwGWZlgYNxaCpKBhEcQ4wO",
	"0oam5YGjdpkh5NLANhswrl7pvUmnnTt03fWbYc1UQFbdTjCKa+zb0iyJi/iAhuy+a6enGhwMz9GLk3gF",
	"fDHhlkzNorm8MirHDAxkTk/wBxgioHJL81rkHIkmV0Guy6sXrZ+TGC4SjJOLoj18lc1nj91qNvRxDg56",
	"IQr9KlOvLf9rG7GgGsoih4Mnb5HDobSvEo2/lE2UiqeiTN8wvOpcY79k8GhpaO4+Unq9B4yO7rSrFx2Q",
	"eqbrTNtQbyqy0/toTqkEMPz6dPtAuHq61C669K9TWzo0uUo2Hoayln2iZrY5yv/xdLTDq/Iqba1C0V9Z",
	"tTrcIlhXHCkpWFvAjr96TerN4oPd8pI9fP8du+F+dxdWKQrD+9xkh5f8d3GnDWGawQOg4QuIdHU34Zbr",
	"FcehG/IVl+Cxm2r8jW+qrdf+CVdShairGpfTrmhy8ztov0HLe9xCdSySsgFN3BX3zrxUDCveJrvophpR",
	"8zHAyyQmQlkbZazTrl/P9XO4I9dcNjVvgQoc+SvcB6eatlFjjX677aXU+ZuijutgFtAMmyRDv5B1GOnk",
	"2sL4hM86OR5JNw56tYg8VkyxDHSyftQh/qRD/LMiMYxDHTAH+AXDWIQcVqA/QQw+atB+0qD9WZ021WhD",
	"qlHuy8c/aBB/0iH+WZU4Bjl+W4MDTjLFHOnxy0d1UtXhSKNeYGA5409RvEIZPOD2chow2k9R7LZF0yEb",
	"f5BpQdlcfYbRe/Q7nnxVnicUKteEM4AGWDL50ERgUSjziyqd6jpWBfF5Uy3wF2VCDhByFV4EPQxHkZUI",
	"ax4XMhnVO0IrvTPXn8CSdJnHbzs7m7x1b7PeeWSZ7lNAEltxCL80hFAVF6u2Sh0vAJao+UlSWck7QJ9o",
	"QphcafQ8FYKkBsTkab0UdrLrX4Dr+FX9rxeYXhiLCFM42lEVKiGioZL4MwB6ARjFJ51ZPogoQdQfTSNG",
	"cxpBLENtz2CINC7MZFssaZ5eHTd1/kQv0IjQKb7AWBaEbiyS3DuCfTK+sWsGjqqNCIxDvfAPsJza3qNI",
	"pJocMkp5lZRxk24wMScaatGKcbIa6X5F6WcoHad0CgkTO4Po2PGvraMf5gNZc7cMytOTjLA0wW+g3ylD",
	"201BNmEY2kq7v36osAz6GLFL+T7uD0cxONP9We7VlslY5sGV05+ZDDyKT1p5tKuJi4sW4k5cXLTxcRp5",
	"eK9Uskra2ymrrjNWa477jDSIi1h1dJgfvAKz18FOAW/J8Th9T93Asuwmwt10DBiWcbLo081/c9mH3mWM",
	"NIUgA803+rodnpiVCW8P9Qm9oSkczNMkztFzBKcinNWK2E3HdiYyo+S5hiQ9gPQKiacs5tZiE4uSZ8W7",
	"LDllUBZdnVE5LzDDRRbLXqkZlVRkYsn6C4fLDH2rhkZy7e5smTl9K+ND8gIvk9ay28gvr8GJ//g8CZSI",
	"5v3hirw/TsibDx7WVI8ZIZxX26xrO0oJHmBcna0SmiGPWaol0RPW9WBR8uJyAdmbDucSnt/2BNlhBNYI",
	"jwjk3xwlozdIT09wcko47WC4BiSDW8SJAZxWJY1atHir5kkDkahcH+2n5Wo/5ddJHmOzU0pWfWotQiAR",
	"4ahGSis69PuqpHKoQUqY8CC7ulbFVYcV6a66iVqbUGJC+q0UNpyQIeFcr9a5Wsx5TxURymF8Aid6aNvK",
	"SN/vo1mSa5WuHsLpuilYivY3HPZjllyWYMC5R00vpHTFYdtBX+Wjrq1F8V+KbCA6vp72x5C/FqB8AaJI",
	"npbDDZJmnaDnsWL5EkdypR7KS3satWiqKtdMlHtUoJOljmH8FRcrPkNSe8hEdQ3V0DPMnCMDStPVEHWy",
	"TlPuqGtgjircW0dPc/wiKSRFh8/J8aglK6RiYSiJZJRY5FrypT9N13Odpki/j4Ib6NcnF82mRJutoQ1r",
	"gz5yjK3pzpNJjhcawh7F89JYmUmO3cadukc5VaP5QYHmxwEaT+tCmWZQq+8Z1Ol6BvVak8E0AgcBJzFF",
	"l/Wr1wndJ9LDIRtZRdnICspGVg/dTZLR+AqajeccI1y0RPV6E/R1Hy2tbZ9t8SVF2QQkaJZPffqd4xFR",
	"M/KeiX9BSQR0uNdjmUHtfj3mS3rjm7bWbXjssjqsQEmK8XcZ6g943U11xJHuBoDUIcQARQpug4xsyuXt",
	"zAIRatxIutHobnnfoDeBUVWIXEpn0vYo27gJOjbfvfr7fcS15/ZSq84U95lQTpMlbysNdvBTr3FKSnK8",
	"1GITaQb1MlwjtTQby4SKlRovcBvE087om56LynCvY/r456QYHX2DEpHz6cYWkFoGcL+C02mq1dZwqVP9",
	"ki8AH87FaIyPB052WxsIIg/pnpq3sBsYcVssH+CHdzuluppJyF6eJ4xnVimo1BCFRt6ex3gGzGjAsrEw",
	"JuNh/7XChSEqod5rZqOrdko+rTOkgnbsfYfUCsFaV/VBqn7/H/Od5S83pju/my8N8dfacj0/WBieOb+b",
	"e+bSsVfil7+x3PKHt3Fc3/Od3fxuvjXXfrC2zO2KFGXavumWP13rflMlrkzPurcN31wFG8v3aY07y15u",
	"2j/dvW3Tn+ZH3zWqVFJ7lejsfVGyZYu/PN9wfcu+D6ruuebWMte1D8ut49E/9v7W8j+VfwS8mFpaICph",
	"JdHubAx7Za5q5dER6HxtENNmdYj7v9L2PnbLqH33n5zgyfgkams0vJ3W6EE7ce9bfAjKlK3xiQ82H/W9",
	"/cF2nmzSHDr0gWMHdKE0vrDV0vhEl8z8f/Yw3pbCpLvNJz1jfjUN0dBWY126NqRMEyRHaJXEsKD4dB3S",
	"zlis+HwpJiCXR3Oc1odMhiU1OKiUF3aH8juNIJOVzdVTH1YcX46Rp6LVdytKbiCkvIe+uVlPfRB6rXn4",
	"UTZBZOsGKKxuB0qIaOMarUHIrQjkufJEwFgd9aaEUa6jQb8DdPAoJi9NXScZfnsAckReZhnVMdjrI9oN",
	"wW+i3IkXMFZQIEla/BeY5XAIOuUvybPsu0QlIkWfSYEASFNeAmkZOmWCWbdm9KFrHtn+WoCIwkStEyrF",
	"s0mTHqxTuWouRyFkSUrG6yWIbon0mSYZVp4TqodR3ph5HfFlGk5MPzrMpI4qBY7ufRFmWZW7jScEaMFS",
	"EKnv6UgaMzXVPpz6FZvf4njSOXDU45BXYchbjw03OEr+A7LvW2rHNZgiJepAW2kyuom1qPOkLvjZO/Ol",
	"dqjRfg41yDqaarHuRfemBrYQyC+0sIrd3IdgQdKsWBUa6728kN/F0hPlpmxc+sm5D6OOK6nZMp4dynTh",
	"q8GVyzNNEpVhZAuN6YLFaCYZOiEdY8FEZk6ZFFi6eJIC678narzDZL2zcSsHOTpsk52SZNNOue9fiw6M",
	"yIhcKfdOEqnqW5Twun0s5whDXEsEmOh7vssPDdXQDW+XIIK3D8v03Iip+16l1wfsdqE8+mp8t9EvnxJv",
	"WOaJIdG+IPjq4SR728ITOLxNHRtSGmFt6qflPc8hrjEKkQdOHcDZW0RkOScXKJzd3yMoG2FDK/SCcnL3",
	"MKiZOjM0fK/KthCcCvhVqvLI/fyr1PQI4/fv07uoqsvCs+QZVOdh/iuNeLaFIHy/1tdqsGLOnt6xqvde",
	"UO+6alF8iIoQMiEdHT5DnKuKxiynhzBcZAkIDyBXzhuhF7hNks/o5hwzJdOdFLmwSbxp0WzvOXV7wnco",
	"X+xtO8E3FwIyeMxgfrZiDLOXFnDv0LvrZJUuPzc1jXC8erZ+H+fqPL79aU5E6/wJ4fN9R1jQtbTpF0K+",
	"ucazMQJ9l4DyfVh1TI2FV+VpCPtaU0NG3CBZpSZ+uyy5JJo6WJFFWihjfVsUf9ZvMss7UvRNi30Fb3Rl",
	"LsChPxgGobDyJyTuvj2gkK/gjcl4yupOmiXJc2WvEJKBmmGgC9TOKCQd/au7LlYApYcZgrk+JEEaIez9",
	"tQChfJSnBLOn+ZDWeD2hKFyCLBxfGE8o1oFGqC7XOs59zPzzuSEYKF/pVqAmU/Qic4DDGX6Ab5JHkAjG",
	"IciUtcYiAz1tJO8GB11+2GCGB7V+Ly8cjRjQ510W9U514Gj0Ci8psgMsDUPGT6IQyGJtHdhlU90xhmVQ",
	"Am6gbuIbKqKPEpCBcWKoZ/hbL4Bsqh1AmWy9wBDhJEMgEtqEYaqBWHn8hU2vqaVeRvV4XEegfKPrXePS",
	"qkiO+wKFUttaayBJISgnHUBH5NDiplST9FmDWO110qqeJ+saJl29EskXArk7FFUqWTE7RVRtk5MLHGbW",
	"hGL4FCcUmqc4zaJzGJMMk05xknH6KV7XqGkb7stUdFq244ReXyyg2UbEAkIzRSyg+fRWmJpYwCiVxQKm",
	"mRDz2vO6f7ThAeY5kARyrKWvRo4KBmyykMSnGcI4WcEjKCJ83ww+1IIrsRPsJRk28tVGRrSGABcZDIcK",
	"stHpLKtJgjaLoLKuREAlTMFWKHOTLZyhEOYTixEKm7Hs24qS5EsOIDIuu0t//D+Sqh76j1CLs7UnNZ9g",
	"Nc3C0Mknr+Y+qtzO6f6mvX5PSY65oUd5uoyYijTpe8qQeXtmkBxkzm3b31LI6bDw9MZX/bR4jtBhDQ5c",
	"jzpYUI1WiAEZCFGyeKc7TQYPSRYyAV4G6Mq1NnpSX5XvXiYxDmcL11k7BIhafTSjToXFRb9vxUW7X8UF",
	"UqX6aNhxSlTm0R8HkUmzcTSPbgtfYJbDTXKBxit4q6TjPqQQPjsMy0oZ40MGK3mNUDZo8ktY1Zh8wKju",
	"da8bLJvaHcKr09KQkhK7OTmYSpLRA0bCd0WynUiT9TqXZGWg7t7SpIcotbdJsvyM0huxXG3ja1zka5Ub",
	"sVcjLXNasWSEVUI4sKsiD9+Ab661xbLophhBGulKogvBGTh8RvHJe8sxvDivCuZMfk+WWkmPMMsVjE79",
	"Fvnf7uZFfElC6gmw1FWyvcA4TLInCPAZZuskgwceAnmEvfVkYqVpMMdXVsAYPa+H5mD3jini5LSoonoO",
	"1fXnm2Ewhusecpr2sdc+6YyYwF/7uKNQ/HVvMcMV3ELXPYJH3dBTrySwFTLd8TC6Q792+JDEWCF4BtVd",
	"M1IdN1Sp7hm82fJMUxXTbcimK1XUX0/X22z496n1JXTddr6vBnhQG/se2trJ6sjhbf1r0ZapKMJ8mZAz",
	"XYvVHLyoMvNVf4rsFNGvBVVXctW3aKXw6ocd+wp6oxGcsmvVOqPFT1LwtDyh3u3gbyt9evwMbqXWGYMK",
	"+k3B8/UUPF9FWaOsc6mMUNVhZlvockUEPUj9P3VAm6pMw4vzWymFRlo15hG+QnkaScTI71KB1HJv1Fbt",
	"XKWgGRnsq/x9p6lu2mXoqGlavYHgMmgtq2sY2uMf2rG3fcfrpKJWaJoup1m1ujKlmU9PrdKb9ypFULPE",
	"aXqXoUlQ1cC0Voomph0atPCIqHWHS0WH0YFG8TbJc0bcEa/qtuXX+KznGjYUOYThBLaqyRKHjS3ylIw0",
	"s5IZfbzmo91mLFN9ygdXkPCx6YBMlCm3ARPhqBGK4CmUluIQ/+1ufkQwClXzrjmxyCystJSPFJFRwNso",
	"Zd5xYpGZTJdSRp8TsoyjMyV8tAW6omG5zt735ndzw/Msj/3lBwuj/lewM91g4zyY7t6miHvbDxx4z7Lv",
	"A+PRdI17s/slWBjbrRdYNgXrm9/N//veoGCFFE+QlL8w//veNPyNueJwif0fA2/puOaKpG2dJzvwjEfT",
	"qwAhA9M1ql+kQt9016Zr2kuTft/fb/zA801ja9n35MvGsJesBOdhtzV9M7g3HgjtytkvtiZtr1f+JH+Z",
	"hmuzBjV+1Dpvuq5D229+tPzg0dw6S4ZYyMAhKSbkxqLdpjiHFPzRdJem7bMC1ttPfCpIY7xgbdmWt6Hd",
	"Zh8o5GH1k6Ey0t+us7dXpN9O0OqBJClwdjvH9fe25Vtmm853rV2nCNE08SPwnYC1OHAN33Lmd3PeO/Jf",
	"4Frejv1NV9CDYYtfAtSxJCWL68+BZVMKZ7uiCc4DRdBs/E0pd1vDNwNjtzMN12ATbNkb07X8cr30fKpW",
	"kGXbln3vMVxOj7elltD44pu2bzm2sQ2ejO0HksnyHAGD6dgCZrT+U/R863ge7aO9f1iYbuCsA893rQ+t",
	"b3SLNL5UoyNKbKyS8uN27wXedn9/z9a0gM8Mqn28/5lClRqeZ67KinbW8oOzXrM/aU10WFnvWx97xnq3",
	"9wO+FFzDvjeDtbH0HZeS8z3U+S4m1zUNMrJkpOhmYSCcHv8voECeZAnO7+aesXSttbU0g8XeprVVX9Zb",
	"tmQFFyD/d9azt9n7vJ1ikJrj6PnO1mRj6TV/tunIpImiyh+NjrU+9wxbSUEXUrlj/I3rPJGmlczDd3xj",
	"W7ZK/PJ9wtfWxpKuS/a1XQulb+5c9pP8RZcvbVzZksbXniazxHKHsgVS2x1iR1SFiOEgX/gSe7K2HGuW",
	"/rDZN7s5xKR79opXu9rTwbE5oee7pvGB76fq15OzICz/Y/3/Jc300Xgky/ijtyX/bY29vdwEhn2/NWus",
	"JFhZns8rJEyp/tOw7wPfoiv5wfgYbEzrfuNzup3rLIyFgKKlB07r28JwXXNb7q7A25l0tLydZZNpN9mB",
	"YNoe6+PGca2fHZtOM++b4T7Qjtr3Phk10bZg6TyajIeZH8kJxg4NBpkbLPau1+iHSPhp/7Dr+042Ixnn",
	"ZhopxPPNXeNHYK7X1tIy7SXp4c7Z0fEJ/rio//qh8etH8otIFmYzs7dzLdsvR4Wu/8BYLveuQdPZh1qT",
	"mh+CJ8vfBAtnz9e7sVyaW7NcMHQQyqb7DpVZ6r9L8N/yC8P+ra0M33V88ZsccRxAWPwuSxAfRAFb01jV",
	"G072OuHvzscKorpqUfVB5GdfDPdT0C6JCi5Btw/se09J9DvDwa5q9I37oDG/1Yd6oeRrt0jytVNg6zdl",
	"f8bCeTRrQlEp6bDz2zUfTZvJLNVWtmyRzzV3W2NpPpi2z6WcYMW2zKPp+taytkk66/2J7lN24Hfb0Uxd",
	"uqbBWtH7nZ6t4lTqa5mQcxtV3Xe6W0/ZOZ7FRYlOWgkX3puzbOLWNO73ZmCsftozTOuqTUJUovuKyTrk",
	"/N/61gPh6/UK6iXajh80BMSdKKgkqZ+LPK3spGWvzJ1pr0gDKLdjxZsfd+aS5B0jHEwPHiy7NgvbrfNk",
	"Mlz3VfBkuPyIXzlPtE0P5rb8W2CGi1vI1uR/kGo+lpKePJ0uPGmqaa/Ixq7OygFS1yi70ebDhu8byw/l",
	"ybQwKq5Y8qKPVGrbGe6HuhwcPJr23gyslTeIWU6ve/5bOhin4IxO523yqgdXs6ky9SLWMGDcpIix9K0q",
	"As8wkhjAJ5+LdAcyieFfDCRGf0l20uuGk51AjH6hEUR6XQ25Ovg+S4pUT5FBs/SXxx61X2CkU2KZqX+8",
	"h279wvarbVH1nMEXBKTvCWAA9ZItrkzt1cBgxKLhwy6vUfFsy+b3kMRHmAmosuFwNiWluvEPGSdu/MP9",
	"V0P4gg5QXfv+U57EdhLSSkMOcjSKGCnoqJYqgktZhPMjynL8CYLMOe5kL0XHDMSHMxqPM7YuCeu5pCN/",
	"5i+D/Ykc3mXVM1rvgCJDcZsbj+zvXkkZZfqdavJaj2HvVE3NaPB9a3jP8fIS6qBzY/AgVbvuSEP7XtEr",
	"m41HyUEpBOdW0NXySDdvPJSwBfGpACe4QfTN0oxDJYuBnqyEx2O1zPALZhGJKixCnUdNUcY1+RN8Zg71",
	"tkDGGRQUmtQlyrKTndRBlkUO6UTR+H3nJAplb2hpBN6S41HFlpFiBTDyvG7cdO24i3KuKSNTegSsiy8e",
	"BnHIbD9o1hvFPFEPddK04XiXB8NzkmHp0sgp16PIGCqz77XIhf/KaD5KNOmtscql5++V42wAiAJTmUwi",
	"EZHEFczRKVZimn6TvBSkmzB+SvK4oJdAbkmnkb7pwb9qAOPe+An1HbyBXlErOspXjoeg60PzNdxayFJb",
	"JF9KC4Pm1euZxpPJrw182A6icFVZIjjNVYUUUZTC+NpiEGdwWgtUjLadYPiUgXTYJkkET5hcxYilbg3U",
	"9NpQoSPoojeIz1iXlK8LO6BqsdAJrzC2l4Zdw76VIuPWuoq2y9FErcWIr9JX1Gk0O/QNtButBtxCz6Ef",
	"bPhdLpeqniCaF8pWsdOvlppXPEHXrF/nktdfwn+Ga5qk55oXtf5S1K5qPVe0VjFKVy52TvWFBrrhHUrj",
	"6tRqifIFqp3vOrNN3UtV90zWuUD10ky8Ho3YhY9elKZffUZqzpB0SKaakH9do+1aoFpNI+0MXgCK+auc",
	"WpTVcA1QBDXCsoZecTjAPD8WarjcYz1ta3+kcYp7npNQTMP2owPASTZAIwtGdcWbE/81DFhX0bkgHiWh",
	"/VdfZA07+r6dIHVc5wLc8gwuaf/ACJLh7gkqJwyblyDmll4thpjpympZpONREtx6NGCELoixwoFQfR2q",
	"ZWOJjNOvalL0OHV1cIzTeuKIGid9QlF4AFm/wzz8ksIDhuHtR5gXzAkHK+c0Qyi1X3AGam5+/f7x0rVJ",
	"U4nwpczbThmQNPoMci7G7RIUY1kscpD3jHtPsPIe3xqxarZtJIdheEYBm9mCURrEaQQ59mH/kJO0fRoC",
	"DEN1l1R2rxlmFNw9SLbn695DN1yPkQ4M7AWc0GGAMcTSQzeJoVvEZQyGbvoLzKi37I27R28qGsHukuNR",
	"g1Gn5UpXibxRxCt0pHwSq4frKOLciKLkVXmHkhwUG1cZqGvAMTeNEL75nNBrxPBeoCTSrVC/T4yVU1HK",
	"i6OmRVIhXD84svJ+wkV27JfB8yWMcQYiSarJ/Sx7kmg8mEh+ZL7kW3jEA0kGjw0xQvKE4gGKDYemHiGR",
	"F+JKWQlPG2lmSTNSxUhDSxp5MU9QOhfMG7S/7FclNGdBJT3zajTSBf7KT1wNziay7DT4Jwda28HsQFjc",
	"CSrXpYhWPXZL2seIlHGF/66ynlKmbRy80hesfUae6zxAdnuld1Fm75a9N8YqVI5UFzxCksQeiKApCUcu",
	"R9EULteqA46Hm8GSJShR46MzfcUotauMRTQxUPI1HXxESVSqtpo9exFJY7gaJSG9KkyIwFsW4BXPUiiv",
	"kkivl+jAoQSeMpCmDcWX5lyGAANFAIRlErOZbGn4ihhhjfek/i5h65KCw+CiBBiDw2cjPjGtdgMBb+6f",
	"4QyQpFlynOEznD0D/F/yWQrw+W4G8AzR4u9mGSTj/QJnOJmdkwz9khDB9PczYxbDE0t5AVEBZxlMM5iT",
	"PszyVxSfUHyahclr/Aqy8G4GZiz0fUlepCTh9/M7FeZ/IJUeML0zKuiXStr+MPrDE3wGcRjBnWKg/k2D",
	"ulnPGYJQuZwabVuvDaGCERhfDx6hbke5p972TEHVWgQiafZ6hjFZAjMQhzOyL2cQkTU8I+w1y+EBz1A8",
	"O4Ccrhc+H3ezJBOfc1JEBslSepuFSfz3f//feHZIogiF8G6G6xVlkNWA8tkhSnKYY7K4QPw2o1elGYiS",
	"+CTW5O/7sWWj5IDwm/KwPPIM44/pknHsbq4jf6lpjijNR4aI7R/eI7raZjSLGDvFlf8Mj9w2Rr0elkez",
	"oqFNMThSPUMrH6yJk2UccXs4Jpa0YAXctsNG/1oQhILDntALjNlM3TWWBJtDMlE6J9GXbo1uxYNJhRW/",
	"noXoAuMcJfFdxbdxQljwDJ9RRvZ8Du8qJs3TqLkBTVNcRm+jjQphis/D7SEb//A5x0nabRG3Gfr7v//v",
	"fHZJilj1CPlltGE05NGhOVbHLLmwuctIXTqnluYaWkg2usIi4vv9t1X0n2cV9YgKmnJsyktgl6tml6wQ",
	"xhgdEcxmxySbvZ7R4TxLQYZrsiL9XxSS/0N1wJdy4O9n6ySbxckrWRv57BVF0SyJo7fZM5USZn//9/+P",
	"SEh///f/Q4UO8YkKVH//9/9zN3suMJER8oJ2kMgIhzOIT5CIHIT6WOAig70CQtmwbueECU8uOkMaUe8Y",
	"7xvbaGW/clKPmllurxinchfH3iuE2EuTYbH+CwKRczzm7MLe7N0K5RjEB1ituVyUSQaQfGhIDE1Za2aL",
	"XYRyvlU4D6CzUhulzpbKy7G8gcBxNw95P9ZZciGy8UBPG13o73ergbMnshafqYhECsF0mRORlN5ccsUe",
	"ZCC84UykMEthHKJDEYFMUHQm5RlGdEPB2QESybx/SlA+A8/Jiyq7pVcMdgCx46n/upgLmbPZmSuEzveU",
	"4wUC4tBWeq44qY6tP1bZ4mMrvII/b470nlruz0jyDJWMuDGgA7je5fQpDWfLFC4Cb33HAW8RSa61aPb/",
	"pDCjzfx/e1lwuUAUWtPH90gRNJyJQv5m/JP30LZIa+g5duMjOhWZ3FRsws0Dw2wFMUCRUHuVqHQUNawE",
	"oKOIFhR9iKNozO/mnsWRExiqWYl2xPEbauhwLTg4AaNQR2XioEUl5lfAfzEyd2EJrLJ6Q0RL6qhmtASG",
	"w7XefprfzdeG3W4Ag3Nqf+U4HO5+awZllyzbs1Zm4G/MYGe4H4Ja29fOfhuwpg+hkfWMnG8aD0ErT+db",
	"75AbS94r8tdiT7FQ1ttPvBm8B+xHHTeEQgPVP/zY/rDZdXH6WLb2xx/7PtLsHNiMwxLxHz/Uf9C8EkA8",
	"OQSeAC6rw5btLHu5CTaW30Q1a01pD6jW3v5gO0+2BLijAq3sikcocwrl93aQ5yhXp8YLoEm8g9mGhZLo",
	"d7poETmZXUT9D7rgBWb8vayT9gyeUSpJiaLcioWzgFIM+Ka/VE/4dOa2Qx+RayZdCmUfQHE6Yw9DEKnb",
	"VhKp/6D8XM6kDVVqahu1ADncIOWJPUZvetQa6/EkjF9UaZlhlhMvEnz2BSS2ambqi65u1oXCVIPUSdMk",
	"w+T4Ve8Rwso1JEZ/9Dx2x9aYIJZBY47OCC/eKAyteoYpYWdU5D3q0EQfC59A9DlX9qA5Yicmy179KVtn",
	"hxByjQEVboZdUzF6U3CODMVatbiE9qxpYdDzJk2JoiL3ouJ0auIv1cjUe5Giw2fqn6JKTvu0g9kuAhga",
	"aQpBBtqsdMCsTJbfw5nMH6dOptzOJNWY+TRJNSY+LbDGAF8BZaC+owgpFbhDS9mdBhwWhbqJXw4O60jd",
	"/CtH8Un9PMuHFnOOkwiqbI4+wgHJpCJXbmZpTadGjD5DjYWSF5cLD6410Ziiz96X6YaMOHxAGtawOMEg",
	"0hkamsF71YjJgjOUqq+QrwQ28KpxHL2iKNRh8b2XZLKgeuD1aUyN0gZC5cWVZNiUbx46uXpCsI3keOSv",
	"BVPyWHFYHNr25cNZP+oQf9Ih/lmROE9RvEIZPAjtiFLABxS7bcsxvbXB43UZLwBF4BlFXOcotChbZ2ls",
	"A8sOHgz3g0k1BfQLh6Ytv7rmPUUmnd/NbcMXf9LLbO33/dZZ0D/Mj8vt3rMezf5bbF+rBhX/NTqpY16d",
	"SNlwrp7Jh1/wbdRWon/sGtnqCwUbGIqg9SybtEFdYG+memkwWyaXCwcM6N6WK7IVzA9jNMoDXMsjHd86",
	"zVsqhwBo0am0k9BNautbCuXrAUSRh06SwJS5Ddi5OzTHEYdGG3WUFXR/u5tfXtLQKPC5nGqJc3mGiAxA",
	"rsTq0ciTDJdqj+s4DcyM2grvxBJZ+oQrENZR/rlw/M0wnxg2WxzfUeDajdQyoxua/xuZUFfLaHwBdWoR",
	"K8WFfy1QJvNcjeV+8EV2gEPcAussLqxhsFrNOEdV6hFr9JnQgA/Pl7IaSZL/mkhTNUxxlyA6FOQeGj5A",
	"nKFDnye6rjl+/AIixMtTl2fbLRl+yru8a+mvIIu1wjyyQp9YNl07g4G2dZlKeX2iwZ60UHC4vvoRRIWy",
	"7M01Uj3s5JJCTB+3dcobg/gZtmiHOUYX4cLZZRwnCl3df/iZw1lRvoFR6MSyVBeEIKNPjrISLuCLzkCw",
	"9avMKS4o1ildDm9TXJbVzDmHQ5HR1wJlxWBx0c+UMpUFiuA//UGnF1W+P/3TtHx/1quvfG7vU9W9aTD2",
	"pi2XipKLO4Ep6VKoGp9iqku8Vy6lrFov75//sV/9ECOJI5wYOlX+QjPsY6q9h6H6AQRjsrkEAL4QyXau",
	"9WC4n+rxRehrr+tb5M8+wWwJIvTM3vlvcI4laakJGDlZRKUt7CDCMybmloxUD2m3UxWZZDHXKHx00fD/",
	"0r1wLkF0WdUh7ppmLNwrZxYKklkIMGD+C9Fldii9dX4/+zdhfvZv/zqrjstaThTPBElpEIUBWVjh7F/+",
	"8Lsj/h1I4ZfZMXqjng5nhPvrqWxrB2pqGOBeX2nNc6eq5gJBnHNLsiiaQbKlZkU6uyRZZeEXwSOe0RCR",
	"XStjUvVtTmXeRcXCzlCUpEKsq9bDnQWrYafbBDxpDpfyDaj/bO3qp4cb8C29XSXSwXCD8zETK1jJBGoS",
	"uQQ+UsdoT9LkIXczqflx23dH126/4dWlYtVfVsytp78Ps/52q74fu/52y76CYT/HJ/Wq56vmijhCgIuM",
	"3NtCNOqEum4QM1SdDTqdI7Kk8kcUwkSKvrPLKGiaQXocQSmZCw8gHSN6ygZp+schyUIUc5V/cwxUD5m3",
	"K9i2qH2YBwkqTZjT4W09EO4JYISLUPVcjJL4pEOvoZ5aNrv+nvPDd+aV85hPP/5+c4/61blH0Xhqfbb+",
	"UaSqQhjTOGoAQ6LcT1KrzNFlkToGMEUcw8yJ//jcX5RI/2Ek/UdJOjO0mP4GvyKrbnnm8W2aw09XpKY+",
	"QxlDQtBfZSSUK4Gbr95icEGHLQ2+V4+NoYsA9VXsMIZnaYgtvsd8SQAOdMadjHgXuXcqFn//8DSAftuj",
	"cm0YFcX71EjLrsAvGcExvqp9GKAo70cR8kSMDyUL9ChaJpEEiPYZYA+FcPKCOYAomp5Z9ip/3VNDiHIY",
	"n8AJXmCMbfZYrGK9/iJ7mqQpUhQdcuIumRX/gHAvcJP78Td1JhRVoe76njsWIIrkadQ2X5ZceTb0pTpF",
	"n2NmApksQh3a6EDNUHyIihDOQDxLCvzfqk40iusx1O0jIyOD4tNQwzx60kosF4jwtQFxOHmRsnP+PpHK",
	"HDgDaGCHibvApMpf6lhSg+jggnCUI9eAgG8Y0+R6yGrl95ZxQFsetXHZ1Gy9Q1xIBnOZ/1oCQ6qqPxml",
	"d5YBO8eFiB+h4yRzhTA5gJeqZWWkH5EuybDUduzbCZ3dUDfffjfrwYKNbOFvGb5mMHTprTfFN1naqmfE",
	"FaoegZevvi364zeNW+CsMnDE/ZaBK9dY+zS2ve34QfXL+2Dtduwvc2suK5LyZ98LNa2ojD5fq+Ynd343",
	"/8kjZdB/yE/3cX43p3bLrkH+8QkJqcZQKHx42N9BZu4d15rXfbMJFxRFKFc0URCPqivwpptlkxSZbp4H",
	"FBc9LpIjuTx4SOJQLVfvWPXKb19n7m5hadvVw/Rd1uWN6EX0p4XJYu6zVOmd6voumSHCScZjL7WORvaA",
	"omV/l2blDU49S/IMnjXryeABpDoZXjMd+v6RKtjjnIgd1l60kZ584x3OSRL1vdac0emc09TrSxvsyfAm",
	"nNSfa9Bppvdb9zA0yQXcI4L2VXYK9B5/LzXJHNKHyFtVaibbgmqOM3BgkfswwDIOKWGdIdWTwVCeNccg",
	"wz66QH+xUn00Nes9FOf8CVxgQEubM5f/4IhilJ9hOGdqtrnwIQ/4L6p9SApC/xwlh88wFCmgwMkFYHQQ",
	"Hw4gimAYsFeDOXeQRPGp+nJMioj/F2CUij+fi5iWX8Q4qKVdUJ6T6lhqWVqtRZS49rtVY8BbTG8ln+Pk",
	"Na6aUrW+/HRGOEAxToI0ojeZxu8gTgJWSfMzi1VcjVPQLqU/oSpOkl6VS73IA4AxvKQ4+ONzz8cf+j7+",
	"WP/YyNYg52RU+RfkGKZBcjzW0mGWJVkzP/v0Q/cTLYuFaQ4wukDWQ/piGBDRmPyKEzZjc+HKPL+rPedR",
	"19U50ygGWRGXiWI4qbkZq25+Nxf/s698UZC/YZYHh3OCDrD7RdAlWfn3iVuNsglo1thMYy0UaaUrcvl3",
	"UP9BprVZWPW9WVCrWHAIjtHbvMRWCSjs8rEaXVTHWil72P7MFH8dYhD3ENZmrsjIL/gX7pV5Nz/krW6E",
	"8AjjHL3AAMUhouuFt7ndX3AoNzD/s0XxCqLPFdfhv8heeH4rFwrdEeQ331K1nwFFbKEF/KXISOozxK8Q",
	"ki4yJwqOdBCASlF7N0/yICsiyk4gDZIXpBmiS6k3hdrf3M0BYYu4ZKB8eC/JC9XTk5oAY1mMISaYTB0I",
	"X0BjOpr95x9pzCHCqSJ4xEESB9T3ge9MytKK5xwjXPApyWCE4LFiI8lRzEiLsJqq/JUPZ3FJUdYhLHmA",
	"IMsgHeALiAGRUcsPLLvIERzOhO/HJyiOFBC+oDzJ2HJPIlj2pfaLcY/6hx/bH2hQLwERRDgTwwjqfGFF",
	"tT/+2PeRF1kbkvYQMG7WW4Ms8cehRF7jM1vWlOXQ5UF+vaIoLJc4WytsLnuv1+aXFMRh++K+M13PsQPP",
	"N3xycec/bePBrP1c7l3XtP3AN42H6qvnLC16vTeeDHflBexz9ZtT81+u6e23tA7X8XzTrcgXhu9b9j1r",
	"g8jl+Ya9suz7ng9b07jfm41PK+vR8jhUWvlx6dgVIlj12TWXjrvq+dRfCk8bLCxwHk3X2G4rODfeQvpL",
	"jC39wTovftVqpL8btdAva9ewlxurDhVnrEy3LM9bbszVfmsGtvnR73zcueaj5exLat9aMsdzURuF3KPY",
	"drXmlyNEf+22xidnvQ4se+2IbzbD+WOViWXAemQ+WktSsbMzXd8yvXZlnrn0LYdqicpmbi3b9JaOa9Y/",
	"ljB4W+NTg3plLumgNT6KVVL+Fj0tvzya9r5RwcJ1jNXS8Hyv/ysfkjLFNVaWI8n1YPrGyvCN+rd748Es",
	"u90qq5H2YK4sY5DCXFm+41rGVpGKzrv5pEDpmktjp1Kv61vLremNdMLc3Y9QPFhb0/Mde6CojXW/2Vr3",
	"m+4UyMjo4lk4BtvX6tSjA1XLRb4vTZvt3lHqspsdYs90LdMLvP1D6R9U/8DTOZimWNflmq/YZmN/1D7X",
	"uShnFlUq40yCiTCyvsNi3bYM7vM2ULj2Ui9PiVIFpEBg9aqY0FF4Yg08Mg3SpW7ZWxSrmipkHXeSEVqt",
	"xtAcOq1JkqNU44iLTMf3upzbYXeu95vlEcvn39bAV1oDPycxHHHpuyg4EtZ87UYn9yjqHfVaEISkU01V",
	"IorDJBn1cLQoVa1pg8PQquXbPV2t2YVeAvLseZZHhCNn7zPI5PLLzvA8cxUs2MFLE6ufK3O9ZeIbyxvY",
	"+4cFPQ93e5+hD/vOnmIxC7xeWgI5psoPzn5b/li5zm7Hyy8/trB8/Y3rPNVLkKBLf7e4x1T8FY1nQnID",
	"/ZhJ5g3Y4yGwYjqzvwK04kF04ffCEDZd41cLMUyG451AibMsyZTxhfn6GoF0/A20+DfQ4u8GtLhEu+nx",
	"rZkGaPyfGJ+YMgBD62TQQTWmGm5hof0bDPK7wCBf4e+kCaEM4hNcgwNOsh3M/mzF/eY5TbJ7mXXhVwFk",
	"/g1d+Td0ZTmo3jlLSEZTR2L6apDMOhLidwniXPySqYbn/8pwz2sUYZhRVKrOExkPL1SGRrJs27Lv6TXP",
	"X24C/9OuFvvIMw2mal0arknvxrZjm5KbXKPO6bZKcsjJQ5LCW4xJn9GS3APrADIo8wQbD2ImMYcfcHlO",
	"hRja44LcNi4ftHlaJxk8gBx/g+DuouqbBxtbZ+ACr4/rqcEUlILZDeHNSLoRH84o74HwoHgHHp1oZQ+q",
	"oyhO3eeKOzy5SY5hdmuHpwhodyHigDK2bPdfErKciECghVp8hRSW5EpxuZnUyQaywr1trjBlBNzBA4eU",
	"LB2fb+a8VK7l6dvy66z5KatS5lP0bstVadGxxdb19LfVwcTWGYTGCcZ4i3J8xcyJYtRXXFnzMEtlHKrD",
	"q0cRhKQOWIOjMAj2ADBcwUMEsnY8CYB7oRnJdw+dYkXyGL76V8A0MA1M/+AkGTqhGETXlc8AV5Xv3zDL",
	"2+fllRgYmo5zRRZpzD+5wIs3pdZRXEsVcvTYym7QU02VHHR+rEVt2X3tmtzswlnTYJ4r+r5SfTY/+q4R",
	"MIne65fSa8Vft+tFKVJv2jqRNAxDnUiD9VeZJAEYhoaWwhDfpvM6K0KG66K0Kooo4qL1CPRjWMm3CnL6",
	"sszQ9vaNMR9YtVIItY7DcImtqtrS8s06H3N2rY3VV7ny9M/Nba47ZO0sL3nvTLfAEEecuuvUf7ubw7o3",
	"3VDWyu2OX2htcdgM5bovCbm3FMNVHMtWITCKd4hi1Bduy6gojLsC8CMHfJQONhupKzytVAeW1FYObnPh",
	"6A9zM7/6gJMCqkFX9KdXGmdSMh3rFttTW7C1qeCLdmzXD+bQnMNfDxYo6fUKYNgI9yOJhXLbSFFKcaJW",
	"7bhkMhG4zLHPorFwTcptbwoLzgvMQDQYcEmQqtCUEPnKd55SZui5tJza83hftBAzCvLhrl/HuPus8RRt",
	"vIK3qehs7xe2inCK0uNzlH8zyr5wV0MNS5Mcnxjkx+sgXQYFmZ+rA/LnaLz1HmLt1oYCwRkEFxSf6vtx",
	"qA9awZdeCItzYZ5EhRo0VZOcBzpS3w3dCE5KvtAdZqcaDvAG4bx4cRFcJ5knJmMkNJ8y97siVphgR9+K",
	"obXvUjq8rXvu1tjTt4qKRtiLJFTHFCbVHJorY64RBnbPOZOUddUJ9BjXhBhvjEJ2aGOZXfZ1DKeLqsei",
	"sKmvXsZ1dLEYZBL7TfBIRt6t9NFKvgHwCB2gFxhjbqjt9KHOROxG3Y9Bof5+NcQqNANE5RjgQLrpNE5S",
	"2Zj03rA07ySEi1aOFKpzqn4TrOeKOI6cKv0FRTDHCv4L9UwU0uE54Yhx+rl2ultCNjtjTj8AYxiHQMPG",
	"ekTzFYE3gcUlQbeSGjNnOe5aqQ4yd3r6TqhNNlrtO72ueiSmtuShXGaB6UlnQcD0ZEQYZrHCsVzPpxUt",
	"pJFxUOIqt8IUMCoPJ+OqkfEF/ZCEsI/3XhlVSVpfqapqVheraLDGe9PWb+laE92mFTtwgDt3l2R4+Ogn",
	"23AHsz9ZcSwWySBGosDk4zYk3Ox0YlbzC87AlOwJBpFospbZ35+nZKo38zpmRGblCjUfwnnNzlclQhrL",
	"IcZXPYdbKFcx8dmbuw0w3xG9Nk6HXOUgKZpjUhmlawx9lWlSTcyiMlMPPtqwgtdsaje3TpszxmWqeIdq",
	"wYUHuBQ3KdfrBc+h0fIh6NtJULbXha8o2eKf/rTr8WrQ5K1XcHSR9Qnhc1Jgwf4mng0Tsk1sNw8soJmr",
	"lE9183UdXDRL4Ez2/U+9MtMyuaQRxDA0QRa9TSrCO5xhWETKHnvN3D1L6l2P7j9f3/M/X9XzP9+g5/ry",
	"RyujCNSrtdKojnVqRq1manhiUXqrLjqoBsQjGfmhqlWZnjMgyzLNJ43mVXa8HBIxrzYjiaqwEkr6yR7Z",
	"ts/SkZyXty4UC4fjm5UpG1kPA/y9u/3rqn6+DU7Adw0EoOFU/64u+HX4e1X+e6LqwVjDte03Z//fnP21",
	"nP1/c+jXdOjPf/O0fzdPez1v+d/823/zb/+2/u1fy1X9O3M8/9ru5JUJ0fQrEMqXRZbBmIjfWOZOXRLV",
	"1LW9kSvjBYxlTtIo9wSOtZYdbfn61uyWloFlBHK8T0OAYSju+mrPtBOClxUX0mJ1ZpeCkwYPaRmM1Tbz",
	"ubg8xwBFw6k+vNATTuMdkU7A0AqbOhU3mAb1wZP1ru9FVv9++QreFlHyGnvgBV7nYsxL2yRReHVB1KZB",
	"z5aBZgky+ZNBZewgdtIIyd5f6plF6DX4VDJBZt0ktdIJ0s8aRQZsqwUolttE3m7GSWk3mfHkeEQHBCIW",
	"mUXVjJnHjghCgEFlzK8UVfGQxOG0rJ/fJHZdlxRm1AikP53ICnpL5BXFYRCijEcK6SuVkuQphKEGY6Qe",
	"lKDXyALGobKZ8UnRabHtwnqbqLTcLi85Hl1yX1ddMSyLxHaZ3vzd5BnFingpNbn6nGRY6r2vGVUWg0zV",
	"2nt0jq+xrfq+1kLLSf0/06ro+PreZH20/cG9HcXM913D4hhOrnm/3xpuUOI2rS3X8wPX2dur+d1cROio",
	"YPk5hP5yYzzsLMf2NtauSnxy3O2q+lknmt/Nbcs2fdO0/U2wNG1/X0f752E2PBozdRt4vsGxkF3D++97",
	"g7TF/LixFhaFX+5zVL+HMcxAxCJYDu0JGk1nbBWTwkQ4zMHoc7dGrm7WXJu7heEHnrUyWcgYMlAcR3lD",
	"oxkE3hNFlDbWfh2Sa2V8Yikbyw82hruyTc/jP33X+Mlc+g4Nw2CtA9tcmp7HojI8kAUQkMkvi2NwX0tn",
	"Vf3YGHSVNIDAyEyS5viGTyOvsBATgSsWGCmRF+J9oADQlrlwTeOD6IPvGrYnSqPw13RpWfYqWFkuB+Du",
	"XQFZUqSLtw6AGW2QaCb9a2H4LJCFiIrCA0aIWDz8Z4neLcKr7BwaxrcM2cN/l3TiQxkBR1CWH0rS8kst",
	"CI6grn0q6evRecRQ7hzP8suIPX5w7zr7XYXF1pgW85GGMOqZSlGr466qYRJTW1t1D47tb0iDjU+Bsw6e",
	"TPMD/2Vb9xu/DNnBqmBRdZ4o3gSFHCctJAmu5e3qKHJLZ2/7FALdK395vmt9MKvfzt7vXbSsqSUMO4Oo",
	"q367e9s23YCytOqnZy4d2jf+299YNHAKB1YveSBp9YPBBpzkqH/YOK7v+c6OrlDLradtzbUfMOR4CtdO",
	"Y6bUPrhksGq/V6Zn3duGb66CjcWX5cpcm7ZnPZqBsbXu7QfT9tnO2RtkvsXMObudY9ciU5HxqbaIGJ6f",
	"WRiWFRl+6bZh4TMlr6ssAtuo2X1Zgnho5KrPQUbbqpxIJV9SeMB61QnU7gnVnRF9M52QM2XqWKTguNOX",
	"G00eoTRL/qI9RBmIPws9pmZ9WVGiD2rmFOG1dRqKM3D4rFBdlaf3HG02ZtBfQ3N9t2BLpq10HewT3R3R",
	"LHvi3mgjREzZJS3j38n7pceI+OrG6O6hlnnstN3UsbGNr+2H7g5rGd5o7rUxUI0NiMMI9oBytePHz7cc",
	"D2+WHGf4DGdnmlP8egZ4FhZk/c/QJQUH/PuZf4azEJHuHuDsmCWX2RmCcIYTkRXlswN7DIjeZkf0BYYz",
	"gGc//vD7f/7Tn2YoPpxh/vv5ndYFeQil827+ZaBXKGa9SjL0SxJjEM1CdIFxjpL4bhbDE8DoBc5w8gqy",
	"cIbPKAtn5F5yN2PAZ1UaVVnStN+zCJhj78pv460KYYrPww0iU3D4nOMk7TaJG/H//d//dz6jwYkVW/bL",
	"eMteyMwcmqNF55okMruNWZGSVijV2btEIQgnLVCy2qTL87eF9dvCQqfzNnldkllB8Zj15+UZxYyn51OQ",
	"okOUHyKALtyYVtHtp/91GH6Bl1QP5Ji02xTZxtEcpigOyaSkKu2gxyN7csvABV6JTnwb9Epawi5JRkG9",
	"diWl6PeQsjHJKF6NatPo6upBEkwjhPXm2qNZxqyLCY2PYPiE8HmLLswb5B3rcI7HHL5HJZO1tjifKIdd",
	"57ZErVTKWVV+nRtvKYOfGuB2lBG0FG5MDUNDHzu+sQ12W8M3A2O3Mw3XsJdUr+PubfFfQLVxq8CyhdqI",
	"hWFmFMaT8anxYWMJXZAXcF1SlYknVpn4B9aQheGZleKUfqdx5zxRBq+CoaKyQHks/5Ox/UAj9lLFFFdH",
	"1QLqed0geYTAWLrW2lqawXrL1NzVl8XeLnVai08B0016Qn/ksGLnd/N7qooPLNt36oHzqsZ4pWbTo6o2",
	"1lAO6crLXYmQhF5jtMpP1XiVn5YbMVW7famAY3ESa7pn0RQyg/bKYKEImRrQojrIlbklRbMfW8e+N6kq",
	"jirQ2J+lIvDJsgPPd03jAyX1PPGrT2nFl1/fI0ep7+VaMaoNHSjjameNMyvHhXkRafDVAXlBySVi04Dq",
	"6Bq+fE3wj82knL9eGJANwh48Xa4C/oxAXA9kOcKKM2zS19rWwRGBHD9AkBcZDK8tqYgPZ5UytiVlS50B",
	"w+IAw2USH1EoPEvUHdJxBkhJSfam0ogNwn4jw6hqop6h8bC2t9nTiV1GeqWftpZtBivXejTFl52zC9gD",
	"S4O6QVjSrLefBMFQPNNOP7rL6IywuLAa+I9//MMaQjwO4JtkIYoBR9S9gC8bSFbiThFXvZ2fLzEfXSD1",
	"HXphYGldi6ABD8DWfN9sueyS6C1OLghEH69tU1+hn96j0J+vLfQFROiG0zG6Y8aU6KPIGdcs4RYo3hWL",
	"uVXSr2hZN/UbVeKMJTyj+DT7MhNxEypNVRT9l3x2RnhWlfz7+V3VohuXe8tNp9K0t3fq8ttX7/LPqk37",
	"5Z26/Mu7dvlrMCzmS7eC2fMb8xrYoEEB7TmJi9wpsPAiUHWzFdl8cvHWydSyTFZW950RVhSKumJp5WQo",
	"c39YDDcN5Zvh/D6CiwyCzzL/izQCbxKIVDyStUq32S1PRbmh5UhBvrvwAlAs89RqUHjUsHi6ZX99jT4A",
	"fDiPGKslGCcXD46/U9YLpqaRbAfovDPjJL1RTWM9v8ItKD4mo5ccDhRCoUX7NLMayNMDWt7OyU/GQuP+",
	"3x7GEa1k6WGjWmjHA2t8Wnpns+/1gmK5TORk04aoj6H3wZqVSDNSZ6/KB74v+QnFsYwbxcVlo+evnWhg",
	"tl//7pBDqIFhKx8FnKR0zDdqx45oEidvtulVOp5Kq3HYkhdjnc2sxCLbC2p4OV8YC5/Whi7/76k/Li6L",
	"qp8q3viTnO4zDWt6SttxVxx/bVAwfx7kX/3y2zIpYmxDGFIYQx2vAJp9xW1KppfwfQiQLPktLYEbejhz",
	"lBw+ezhJU9nGH17sh7ZD7lQ+xQvSGel6FiveZckpg7msnzVaMmBbeJQJE6OiK9tEVqzlbcIyNaRKJXyE",
	"UxFRqwVa2RbGJ3zubXeXUkKYC8g0t5RNFJ154Yi4riqO921ya83PqW7YTFW5XVpsk110aZrRLVqGoM85",
	"zsABCxqZx4fEFSSkbp7MqEMG5QAyTFakv1ipnoiWwz0n+0NOhigncoPcBWnAQam3ugvHoWiJfCCVuigi",
	"kkXFxMMShGV8IPHByD1WnLT8/AoACa0In7SRg9LvwFCM3F2+fkf6HkiZwxB1Xdg/LGzD2jLfFttzXO6q",
	"tbXo2+zeJUkPxi6ok26de8d6MO77X1WtOEySKvpiV/nEQx/OyoiOsxBgMEPxDNGssyoo5e9n/yZMPv/t",
	"X2cVwG0tL4orq1CutRImsbN/+cPvjvh3IIVfZsfojRxGVJUlqakyqRuoq2F3d4tqjcpGrqroAkGclxq4",
	"GYxDGM6KdHZJMmEsl88ieMQzatzdtT4klSuq1UbtzLAGqNEZipJUiMuxVNUAIkVo4d7tQG2tOURt3z3i",
	"KoGm9lym/BhxrfugwPDWkkqu6uaVZkrq14Bysp54jJnW8uaBXJRuXNXEa9/uzskF3qIeeRcFuGOf1u9a",
	"yIVR528rDltsYhzSTmkE6KwJeUenFpyk1/VaPtKDHkAKIQ5ZKTQ2fzP+i/Iqmlp6rKz5Zpwl4rK58j7r",
	"qVYXSSDLkiy/PToiOeMcCmameoe6Br73p+R5PMz5JD/wvyTPUote9bCOvW0Wdkp9t51tZWJ0RUjrmgjQ",
	"lOQ8nAGS7XcRimvOOTihogu3b5qlCYpx60Wx9po4s6oUIiflM/CcvMDZL//1DzN8RnlVLspnpdfWLExe",
	"Y1LTL//1D4oPkgm1FvZS1COTGqU8XlUHMM7Qc0Eq4z3ijc9TFGvV+cSxelouCuX4lI+uhLin3lcUh/8l",
	"564msySWjKRak1JFownevB5XmZok1uzRBsSnGUmSz/ZU5wp5azqt8M9w9uV3lUQmGhO1x/uYZLI16ZOF",
	"R9YePKKYyN45yUmIv9zVLAMApuuP+qa9ff0qf7lFla8oimYgegVv+eyZbbvnN9YKWsBvrk2/uTZtaxFQ",
	"hRbBtO+3lreZ383NrWVQe/SdYbMvC4v8/snYGbZJrdg/OK5J0RGWG4t/WrumvSTE96bLkBMs39ha9K/V",
	"3qdJO8f19/d7k1vCM8QJ37g3ts59rYLgB2pkaSyXpu0HzqPputaqXzuxbVi5tqTA+BRB5VtzjMFB2QKt",
	"pKPnaQ3vSyWuznUGZSV2mEpAnhTFxheUa5C7HaXtIPkj5T1a1qf9C7LHBPlbTKjOPeC3ic8mWmr2LgEI",
	"QphRN7M+VT5hspJXrOSSgqxUWKsGIZa3QeJ/McXpkQVzg+EOJilbuhPdGPswk0XhZdSAG5Yd0ZFYAgxP",
	"CiEpmW6Jj14NKS7Uec1nrpOskL71r4tCGJGl9AAxUPKBEMQhRy2JyoU4Ulu1aK+CRB9yEy2dYnW8Z3Ph",
	"7qfsFqivD5zmrPhVQLIHtvd1MZinswH9mI7dXdgXWWjyLhs2VJmO9Bg1NpPOzuspR3sPqu6k3kDfX89p",
	"V7JA+ZC3Tr8D5hG5uxYN4HhEEQJS268QHkER4UcYF1A5IrpOFJszyIlIw4IPSSw4ziBfoReUiy3QS7Fj",
	"oJ67BMVYTkWH2GvPcZPmCUXhgXsU9tgEhsraSjIdPrrAnxWcGku6QdB2cIHG83NWf07tJfLO3Gm9GwIl",
	"Oy1lWstrQnJE0IMUFEqdmbj1TH0i68BWpEkrgGn49dFDihVU5hswydDSwOoC/eIJa4EyBp3ITjSDWMI6",
	"Gb/lwXoqoEG5FDPG6WAILH3mT2nZ5Z87014xV/GF42/6r/e0YMbhFYFYxsPwbTWPzK7YoPRMVW/72DPE",
	"sNXPQOkox52xfrC2i2C9p66q9G/qnS9+LJ2H3db8KH4aFZmx3Qa289BIC1bOg+n51lJ8sx2blND62cy3",
	"ch7qNJbt859Plh3YjrHY8r+XhmstFkyTRH6zxrD0B/OjaNx2wf4NNsyMhfxJSq792U4KniybI5UuSDfK",
	"kgKGmcx/GNvAFgm2ee8687s5/Z9mkK/IQS3FGHsfOs0P1UlqxfscTsMS4iftQAk3P26X1x+3KDdGZJkJ",
	"QVIGj9K4uOgEV42Liw47jovLFC4+eL5fe0qP+KTc9rxuOzN8q5O7+9alc4aPKq7at50mO4gEcJLK1JcA",
	"SEpucVcEpJHdunrAVIVOyVePNDRyCr/PiPR3M4aFxOBoV7mOKQOqJBeona2/XS9wmySf2dv1FUGOzhCE",
	"EYr7d9RndPgsCRx7gSECpCvP4PC5ey3853+UejTRNzF12ansqKhMUXjq5usMlJTpq9vUire33nWfwTz/",
	"Y/8JzhJ/GEr8cSjxH/sTMQ8G2p/6C7oU+GzoPIIg/CbRmRcxlmiUYARfQOdZYyjOFka4CFXbFCXxSYc+",
	"PSeS5Z0mOQaR9KzMh8z2Mb+Fa66TEU759VfMTddEw+ZVaXtX7zvXON0NrUauvlpOMchttkl3XX8XC4+7",
	"FPbaOHsoHBViVm8xuKADuSI2R+N6G2lWwibByyQKiaDkqeIl5iMF6btz1zJfsxCpVccGxOHkYb2BUTYv",
	"4gYD2y3pHUeWbAonXqMsx1f1nhbDUBmuL8c/o+yqYips1eFbRoQkt4M6mNuw4qpuFaBpjppeC5yk7Ilx",
	"N3+BUSLOkBs9/T8QYbSHxWUJCA8g1wAYILd5ckddiKx9KxXGZxof4h7IfG9hetK5FsD0ZEQYZjHn+6r5",
	"jpBGHwzL/itnzCCUt/5Uj2Wrjd2odSFKGfiiZm3SNeAlRXYoX1hLQD/XMVZLg+r3jK1vurbhm0H963IT",
	"bKz7DY1s9GiZT2WcHhqWh2OkclxUquHznxz3gwBarQqp519TMNf7TcDzVkGE6mRVtKD61xotC00lyTKY",
	"yMNbScrtpPYpK9mgCnGk1A+bK8sInPWaalnp33b5p+EuN9ajOVLcdBX8pSxDKj9VJMrvlVUWH37BqrIV",
	"xBk6tFebzcIreTvLDlwW4sr86Ju2V4/B5O1MCsK7M92laT2aq6D13bUeDPdTsDVpqLutsbdrqfynYd9v",
	"zTIcVY3cd3YlrbFcmlvTNXgIKJLU+sTwf50yLJb4XcbFEh9EYCzxu7Gw6xko5HHQ/e4b9z1fW1+4qr38",
	"KmotP/BqOXWNglXb/U6q7aFufuHVVl95NSyxVi2tpP2VVNH5Vv/d6JXnm7vGjzpIdO2rb7Q+tAsJzPXa",
	"WlqmvfzEoUY5srL4M/jjov7rh8avHxe1mHE8/KOz981mqebH5caw783an6zU8tcPjV+0VB47LahlNtwH",
	"CuBs39OocfWfrLzGlx86X37sfNnsREBAy74nq3rvGrTJ9Fu5PdivleX5HI9a/BksnUfTNVdVKMDANbcm",
	"w9nmfwULY/mhvpfFd8I369/vTZtsKXNV7jzT860H9uWJBQM0G3XVovWVLVq7zgNFiQ22hnjc3LnOT+aS",
	"lDNIRrtLltvgdwZKTp24PwYbkwfq44H0Hs2tWEBk1sTfzo7aXduWz5C7OThuGWCuHNhaMfWvHEm9h7KK",
	"3Of5husHPFZkbWRMe9XztUEt5rlGKj6VfLM2T59cp/67DKjIw+ItDJdMcQnmS2mNj5YXOEvfYBjt3sZa",
	"+8Fya3ietbaWgpE6e5+H8atmivBVk/WZjj+ZzNY8ivT27Hpm4NgBXb303ZuWHTh7P3DW5WCUof943bJ0",
	"+mrpl2uQDuC+ZBds2xMW3CR7NF3fWhrbYMFh2JsfAste7ZcmOxNc62fH9mu0dKnw5iycjww1f8uXYXvs",
	"xMAt9oS31VaKSHBNg4Yx7E1z9jxOZplkEeltae78WtxTEfjQ3FqPpluh0FsPi8DYmR8D74O5NX1jW58M",
	"3wk4M/OCB8v360QskMHWYb0IPnY//SwQ/U2DRtoVC5PZMLCFKb4JTkMjOzLmUluvgqmSFbQwFtbW8j/x",
	"wptfSM/tlbniYRY+8pW3M9wPQbkVaRjN+d38p/3Drj5s5scdYzXedn9/zxhI+e3JWRhsqXmBsXAezcB4",
	"NF3jvrGNaASHnUvDi/KlVkZFaLX0ybLrXwJjtWI5jGWw3n5qURu+byw/1EarWqZltz4GoqteFXnWd43l",
	"B24nQtZe7TfnD4+UDZWbnddAhrbxoWLo9TPafNg5LguSWxGYHy0/eDS3zpIyzRpNnWUGhh/8S7A2Tb/O",
	"cRtf22cV210r58nucNHAdsqArmS0eTjTB8P9YLrMH8ekYTUCf2MGW4P0gEo7VUCMnpORB+MQIyeOiODn",
	"Pwwl/stQojWUuO47cGh53a9WueHo709/aP3+459aH6zGccrPyN6DuL3t+5tckstGoyL4lzECa4xg3Yog",
	"UhfO6nuYdbghbQR8oXeDwbauEmRF9dDSBjFpgaxOsn7EqdUjnRB+TzI0TjfBq0373rg3eQTbD+YnIQxT",
	"xs/CQzvbPanXozGHyUzQHrEz0HTpJmgJZWVCWyorE9rHvmtuDcaCadAUejaUbHssnTLVYYqfK45FEryO",
	"HBo8Wf4mWDh7HlWF72XKmYLd0q8NWZtJMwFP1GT4wY9/+IPgF2Ufgx3Z+zsiantLx9kFrrGyaADuxdZZ",
	"fqh+ClH9fks4em0vcOXCwnIeTLLKrKVXk15bn5vCi/dkmoR5Oj67YZhV15j5mG/yuOMtHt1O9p4cl8vP",
	"9BeLlM2vELQp9Q0c+IQDU9LuIVVLlBxWNQpymDwa271ZHUpslptnEv9Yp+zXe+AMHZ5ANoo7Qd3BwHMk",
	"t+7CUOrGNAg1FUoMGl9g1G8lnELmciD1i0oj8NYH+ih5+8capEOuWBLg6BcQFaq2jw9CV2kczgi+wAuM",
	"8Ti4JGgTSxVQHcoVzA9qlMoaq05OieJqeGGojk4/1hxoEqiMB6FTGQ2/nGm9sSD5dFR4oq83MA5uasCV",
	"nhvK6nVtg8uMqyKTGKBc2iRyfWmbUl1t2s45ZehF3huM/PfeVUX2suoDvuzDqq/lcUH8eSrrUF6mQ/yy",
	"WfCjYMcq7cELgG32QHgL+0AO96rThBO4qLMblG9Bjo2+Uewe2ZeesdNfdDuGczNpwbrFuBfPQ524OalJ",
	"dgIx+kVvt1DLAa0pHYgJcYP4q+XwaWyTKpPOSsqKCC6Fr7kitu4KHbnRvqrp7hWehsMMqjn9E91b1dmv",
	"8rrsOSQaa1x9Whv7Qn83kb2OcowOyk0vc0jaruIQ/FAnlpSjs0qT7KRSrVPb++2aB9dRX597gHMH/JJH",
	"rjO5x9FVh3gvpcIHkA9yaLIDjefnTGpxJ/yjrgmxLMZDKvuWFJZGxAaWY4ok0i/QN9bk+C7WEtIbuaY2",
	"+QYy4vfUtaSIw0eUNyNQT0Kj3OcwLPHlbw1GKS28v1NMyOn2A8ahZDM7Be7fm0mGTqjEe+wqKQo8lKYl",
	"gFBsUsWJs5P4HlwqK7HB2XsBKALPKFKweSsLNGqZWjI2S4ngOsk8nEFwacKk1yNAiNKU7xMHwsHQKZ6s",
	"YFKSnm3AHIIkPno1bLF+0x6JmHhpGCsNnqZ9dkikhJc0NAp8duFfC5TJnAjlvoJsVTTsB+8LieYtR1I3",
	"tiI7wGVyucg0fYxin0U6cEV38xcUwsSFeRIVKqLXY5O8a6r8JYNHSyO+1UdKr6vpsHsGdcDU07h2tzU2",
	"ztAs6O+uMods6koChdtOjfRvd3P4onOtrLbgkFxU34gjwKCMbuIerO+8sltDDRvaZ2XvC/LhTr7vBs2x",
	"EWuVtkep4Mf1BTXUE3KPU5616/av2LEaFvzVEmNbV23DivAk/Y6JypvlLzDL4Vt1gnfP91YYlEE07UbM",
	"FHK3p0oCPZXCcHeHRICkNiRTVRjt7ipIKe3bW91Klb27ze/mvmk80Pe7R4tbqG5N437PbIYY7AP7ENAY",
	"IH3PWwO3RE0hnV9LpeI5T1feMpxeQyR38BlmtvDpb7adwshKA+uoowKBgVKo0xhGB3n8nqg4afdl+ozQ",
	"PlsxwghE26GGk16tBwdI9HtdK/LrjIEPwUUypxpFMQzGK2KeTwRxS0vsxxtHKO3vZEaWMEOcUXaZlpTU",
	"wnSsw/l4nuVxW8q97+zpn8KMy2sYuiz23OiyZvpiUZMJTsqsUZ09NQ5fbz+Rv6hxe9P4zOMmDdQMr7Rb",
	"KzOTZHv/sDBdaj5JrRzIN0eYrpnu0rR9lotZ0dattlk5gWX7TrBy9outSW1RK9Mq0QTTcG1zRa3Veqzn",
	"GrU8GdsPXrCxfI8ac1i2TUlo06hFPO2rMB5ZfKq1+t54MP9/9t51uW0cWxh9FZSrvkryldvOpXv27N41",
	"dUqWZFsTWdKW5KTTM1P6IBKSMKYIbQCyo3R11XmN83rnSb7ChVcRJEhRviT80x2LuC4sLKz7mihv2E4w",
	"kgCH9upLzhNusX87iTv+Se8I7ZIkHRCn496or3bx23TcUr3E+tQSJtLnRfQIXSP0+hREImAoF6XWaNRt",
	"jVvaAUb6LU57w0GrPwvWG6bf+dyTR90fThQUJ61P8v+fe30dOiHm7o31fBet/kfl6fJ5MAvahj7p41b0",
	"12QmPUUvu2Ptp9S+DhYUuKLMBDDDTYTHGh2k+GM8Ho4jwF/2Br2JOiT1g/S37QYu0xet6USluA4P9z/F",
	"8co70O8oaIjDjv0rdu6hr290i0atyUQ7jiknnfbH4eVl5K8TxyDx4+10pkE1lu5jl632dDiWjfRu934P",
	"VijAOYt88dRVTDh5xnErQoPkIMHP8qjD6xo684fwDC7PdCrO6rKlvI0VIoZHoS5KfHzpWhqtI4trUfQp",
	"THlana5HvOT+J4rXkO7CSayCcCcIUmeVtTDx9G03G0K5KipYy5iZtHtFOMnIMqZi6ceG2nQq5tP01SMP",
	"pk8bMZ05/zLFG9OwxsUfUN7kZWwSc2cV8MnBq3o7+DhQnsE6eEG6+kWxDIrEBn9JyjC8nabeD0FIb6fD",
	"m9a01w6atlv9frejPR0DRzwZ02L4ZaZnFq/U8Lav/zebymKCeplR55ueol7KJ1221P8W/5vFuobTxBYv",
	"P8f+jlYfTiD2J59mQTHSf88Gw1kEhujnSXs47sbgNEuPkv0hGs7wPRg3CeVZ7P3b/xjGDEmn3Wnvpjue",
	"feoN+4G7aqp58NRZNu90L2cqpiW7UeD7WDhacPjKc1S0FNuP2mbS4QCT8yt7e7m6qoplmIrq6Uk3hjFi",
	"W48b3etkm1z7YnktEr5DuSM+YH/ZVgUKCtvdYMYKG5kbGInP5dfCcgtvK+cTKHhxF1+vCf1mmwBo8fUT",
	"orZFKO+rL/rr2xpzGoyCVCJHqkCWj/rGFU3QUnqbVU+hChmP57Sw4F4o7/rp/BcyV7GHIEM2g4yjpimB",
	"OKx+ZDOMhMA00cXqGI1dylbVWyyQzP35KZZDo1Rh1dZmQwl0SiV8inrLUt/WaboceFBKkbVGkileo57P",
	"Eb1X6qL9WpA5BWLTqpTFV+tz3qNvh1dgibBtRLydT9YYer/tF3SKPgL1YY79JfgaLwwXr+AlH6BUTbVw",
	"TbWPXAHqWdv+Yru43dG2vXuCbf9uu7hvR9v2tyNv+x56uNZLG9Qzq0K7gr5lKFeiT8+XN96y6zfio0mJ",
	"Mkui/fSQItbqeUnZdnRI4K0QmNq340/dQIy7bE2msX8q5v/9bKJMQNFPPwc/tW8FIy9NQf2e/uflcPwx",
	"GPDqy3iYFC6V/k7/9HFw2/7Y787kImJ/68+DYShxTtrj7ucw5L43+Khm7fdUYfrJICmv7gmoGTJftzu6",
	"vtVKz2AXfb2QSX/4OVzV7UCLzUbp5HmxYIh2EIfYSx97pHrt6WhOpbEM9WUxFXtcBaeVlBkaT/G/mOpS",
	"/hlTbWrVvVbARfoF/ZeaRuVRH1/0tOowoZbVCk+t2dWh31r011HgMtKy1b7udmbDwZ6yVsu5qZ9T6gy1",
	"xmm3daMF80A7ItMRhIqKtK4hrfSIKzLiqgrVOkchYac32NPPJHTbFwGEr7vj3lTpnQcSqdM/Kf1CZ0+t",
	"ktBX3w4Sf4ZWkNCqoPLEqH/0e4NuDIaJnvKX1GhZSpoyGqNxt9/rXsb1KFKbrXPZ6D/ex/+QuWH21Epx",
	"pbRsHv/hQ/qH69G+YUd1S//4IetH2T1t14hWZSYuuh5zhviM6XBrXRQLMoaZfWt+Ae0b3yNqcsibQ+/O",
	"dhzBZ5Rq2/ODcvhWPThHlF3C9HOd3wX7y1A5s787jzz4E3hvn7gcSgLNJO9TLqbDgdvlik84gp726LTp",
	"JDMR2qdVX288xFGZmgWKG7FtjSD1kTve+q0cnAkb2Y668HbX9uXhFt6uxL0pU6lKtr3EPmYrVKoSlsz5",
	"7g79C8JXZUo5yM5SA2I/H3Y3JZoOpTlp62NuDwXMrWcgLZIdKSTLEJc4VNWhxLmusCRxa+SX6LCTFNm+",
	"Q4nFsBGi/9nzfYMTvudaj0XWqMTdCZqL6Y0BAEGDIR1svWynHOyvEMVc3lsfUTbhFPouckeIOsjnprse",
	"72a75ESfiUOoNfJj38f+kik22RBs4Osc+dD7XOLt8rCPSqCraF4CWT3CmH0VGWLwHFeC4nChtm9dLkaG",
	"VxQco27kbdnE2y6XyZCDRMyF9bRbHj8nm3hMyBhyL6BCUKsgVOeOLBasTMwqEvegJ9HIbO2RjUYe5Ki1",
	"2SBIYfqVzzFGmPpPOM2bcLqi5MEvs5M4Y2MXfxtfjjXQyKbEtdiQTYlbsdnyEgh1SOlCa9Ikml4IRtPt",
	"+SW6KCJmJMHJJjlEmEHnYutbg4RB59Kzr7rD4D2K+IFy/azbrkodKsP+0p77ZHm0iXHiIRtal9Uw70zC",
	"5qxMmMBdKWtw4ZKTjXKXK5qSLRev3xhyTPKbsVLrlFQ9h9FRrazH3K7XUMUHF5Qm37O55JQmlwZv1vLd",
	"G1zi1S1xH2T9zTIIoUr/PgRF2Wx6SHehZ1XX8/TkoQQ/JdteK7ZYPbd5TJtsnYdXD9hzy7E9D9gvuFQP",
	"2K9eH0287qJjXEH7uStTGA8642GvMxtdq3Skwd/T1kVfpnDrDSfhR/Hv8MNvF8PfZup3+c8Pf3krc7d+",
	"vNWJ1CbTwCWnfT0e3nSDnPejUb87/XRyejL9NBtOslVRHty1KXJxpvMN54hOOLQozCFaxtTTf56eOOGo",
	"GQpw0dCmJkP3HvlcjztUcQnIc+0WdamaJldVLQAoLIliM+++sr5EpY1w5qC9YhN8u6mVjBaf2YCj+syr",
	"uyTknG4NaVssgRUAqdAZw4M7iUnV94vZxKHb+dwUHLwJpjCCpBuFapq/B7YdK55abd46KIrjdRhhZZm3",
	"b8LhOrvm/VdLuWdX3cTpwZ1ywTvAcUbAdCIEhLTPRh5adeO9CooXSVwvPcMo0S1/Cn37y04xTnQrHQ7k",
	"wd1nBPkK0c8UbjaH5MdzLTxv9Fz6zGNLFRLJgTUzFbCPUGRcDdyhcMGD2rZJuGywc9fzx2TruyVUF8N7",
	"RO2VHTQYfZ8jLpksSl5XBOkhvE8cHgdEVrwouCURtgYIqti5jIrAsoS4RdV50ap82emqrBG1z8GVVyfa",
	"uipzVdwukyk2fhAH+LyWOLAkFj3C0aU8HB/5EFMP0kFXrsLBYsZHIcwOu2VV2N2on1hJbvpD0cAcNX6A",
	"VJFzjOVvlxnUI0K8vfdW+rn8922r37vsKdeP4fCjiigMf51Fvw3HV61B7/ew3krsz9lgOLvpXyiPt7HK",
	"Li8jYcK/ogGD38xveQa7VPbp8uDOnDm7HMueCdTYiSfX9Zj8+unJt+p8/b7QtufBOl0h8PWnqLBw4LHq",
	"Qd/F/jLyZF0QGndljTmxgukKM4AZcNEC+8gFWyZ6isZfT2MuwJCDb397K5ojsHv8Kb/VMeUD9jwAvQe4",
	"Y2COxOBgvlOrkAOcnZyWQmILVEqeV1DmGmBfLjQKHQAuXiOfYeKfAh8toWDCAScPkLqArzB1wRwydKr3",
	"Gn2T+SfkN0t35F3xqly04av8BQkYO3eMk83+krQK6P//f/8/BtaCe7Rc2bfilQWux/HFLShZy4/KBQJs",
	"N2IVVnPmXTvo3cBDgp7Lah2CDiXUzxlanQwv+93mECLK1fM3cVbIPSj3LUMUl9CtBxNOZLeCLRIOPamM",
	"KGVQKOPlFXXo+SNKlhSxUl17e/79eap/zOs4shDg+1mmbHJCXel2kimRmr2Oivw2hEnK6WTkz9LAqKkm",
	"po+lokBttn54nuYylUKKwENomXSbmfsLzU3xWIbWYHbVjaquzTqtqUrfMZjdjjqy0lHGJ9ll2prOJt3W",
	"WDpQB79etGJ1dvYHM30WXT93W9Pr7jijV8YX0eG6l1VBJ/hqqKQTLTRWqyw9crpsTvpzouRO6qOqv3d7",
	"MRt+HqgSsYPh4MvNUAZL3E5UVrBe+2NX18JpD29G054sbjee6e/x4sndgUyZ0klUVNZpxbqd3nQ47smQ",
	"9pvWoHUle7duO71pMNTkdtQNx211bnoGX2lK1iSb44UeH8GlMSFmUZC3i5lMPr8Y6dSS+9jtYtF8vjWO",
	"gdc5C/AJn2yIzwhlK7wxJLpdLBC1z2smWhtvMCnh9kP4yuD7vKGIIZ8j92JnJGgf0c4k/+dvt1TiQ77a",
	"ruc+xJ4x5SnmniGthoeVPsNGJRBgWG5Mez6uHZZu4PiYaFIgfF/oVzN2lcMhtkEO72N2gLmKLBYMcfsy",
	"FXJKVjpDnNTQByvOZ0H/ZytYDneCv1nXwUB8S/1SXZQbjG37TPBv5x52LqGD/WVa2TS6vej32rPLVls9",
	"a4PhYJb+rdXvZz4+Y+RBjtzWZuNhx1BvCfouJdgdQefO5FGim5gQDTumO22u+oYJy5sRE1aaFuikVbbJ",
	"QCRs8H1WebDQZ+tCeZnlIWUr0VgAa2ldP8jbrn3ch4xPzLpMKCRrr4SE1lIdsm4DFBJ4iZFE86xx5pBP",
	"sFsoqXR2Plxjp0/I3XYTiCvKKUf7mGQHL2HKV22dJcLwlWx9TnMa2Oe2Fq1lOucRJfdYW6j3m5GvzCEU",
	"GTXZunbTtIJdx0UwZ7/qa85+ZQPr/crWxfuVqqb2CtIS5LkT9snCGVcQ7ZIOBpFp2jTgKP6IFPhakvQr",
	"keNrKQf/YmsK1e0PfMmyNoncraLbgYE+1+8j0ThyNsvmyKSGMjc1bn7e4MXW8y5v+rnf+5c3ud+NH5fI",
	"N8U2rqBMC2XICrVCAXdiE2MkG18iVK5Dzy/hr6my5yK3FaPjNSJqOHxI2o8weDtJ3I4wQydJb44wQ3g5",
	"jjT+Df6K3EudQuMI4w/QVy4jKo8FIGXZ/TuZs67PKUbHnWdMGEf0yDMpA+6KcHKsKQIm8ljjT0iQf/8Y",
	"gwdk9AhjH5FWyAIRda/bvgyQj/NfTcyUq56ptFvL44j6kKM23HCIfVO7gs+j0G0j6+uYkDtsXMInRPEC",
	"m1yBg/opvTKFAYpT6Pd8XJxj3/hRRaJbs7lr7LqemVtfx4m1FcfWk60zOLS1N++g+da+mo4flBLoJ5Vl",
	"yRY3kFPsYR9BsxQ8omiBvxo/T7JLBKiPU6Pq0dcldkwCiZ94iEqxu4HxsMfROguWPnbujGcWfCxZhcAY",
	"dUwSFTNyq0lGLW2qPGzCB8dO1JE5q7N8s4NMmpXk7M2ehB339leqkpwqNbrF6AAHrQ0l/tZ3MDTqfKl8",
	"PY0fK8fFSuKndColsYVKtiQHLkw+yLIIlI1INkk11+UvrXKfsyjw8HfiowvCOVlbujdF3aZkY5u/jkKf",
	"Qaecs8M06pTpAvCAOTeAcstQ7kO6ZSjv22NEBt6HrIbV8JIzyQLDQxmptFp9Oru4iOyEshk6YftUhQWm",
	"I0xVLWrL0dBXrhyILNsfmNlU5+K1JXPGpK96nDI5FBmC6yHFyOdW+WYnyeap6gob7Le+YttMlaL5JeZd",
	"Sgkt0WW8x+LkNv8kffxqTC1d1TBlGEv7hOzXrJUpDWqp6F9kOEXGiDsUj6bLzH1TZpVhpdqkG18HK5/B",
	"jQd3gEqIAOwD6AOy5f9PNFKMc6BzbGsVsy/4Nkb3GD2osE+WZ49RDe1JY3LgjPvvrKDnIX+JpmVMrwWh",
	"lglPtCz5a3iPqLIyZregctklKuYF3FFgMxwP+91ZhntMtiNMttPM47jHjAlZpBOCUkIWww3yTyQrt2h7",
	"hCF3QEbQR17iN/nLXkv5q/rnieD/xRTyfb/zyYOfu4pDqq/k3/QyMR5KN/b4BdsM/gIBV1xa3It0fLuC",
	"EFHZ0Fxjxv5umsGZRrLL4Xj6ZaaqWV3e9vuzSbc1GYZ/jYcTlXt3MBzoP2a9wafetCsjOsIwS+ns1lN1",
	"trqj6fWsfd0aB6lpOzI7anvYamcHYI6lI63M5ZhF9jwv8PXMq4OBfHu1yBKu0eiuRBI/s7dlkOvMoEOq",
	"EISkIWHvmU0xoZjvBDWl2LV9C5lWQoTR7jbuzqqx5NrkItuQoyUxWGRTbYxVQVPtrDeu+3UKSE7QTDln",
	"mYtSlgR70J4ppxWT17FsVDTpcFNO2oxfGNU3i5zowScO2eTO/ilFkyOSUbr0TangT1mx3/rOClH3GrIR",
	"omvMWPKwYxCXD4zxut4jv/g6fpKNsmnoPuD36ZVUe1+gJfatN6f6dEuQMEtfxLrRXeKKfaeS+HNvwES7",
	"o8iV5F/SoTxPIOe71R7lja767D7mM1r/Q/i0D9rx36p8JvgJXq1S71DeA5N9hVK5nGLMt6zNINPXC0mx",
	"+9+3ugCCrgRwNVTCaHfQCRrpL0GhgrEQTHVNjc4nJacOBzP5IfWbrM2a+k3XLVB1Jjqz4eVlUMR1oEed",
	"tq6uwimGt9PZZDruTtvXamH97uV01m2NZZkHWdO2O57M2tfDnpxetB8OVD79vv5bTa+6d7qX3cGk96k7",
	"6w06vcuoAER2PQhdyliXV5CDf+qOZdkENZ6sHN2d3o4HYQHkjqqneUBdgOFNN1apIHMg08cPeR/1wCWL",
	"HCRXU1BRIfhDVuNNNlY/vd//KV6KwSCsCXy+IfdorQWH8vnGWCkHyL0cZ1lekJHSLN83M1SBrWM7yOsS",
	"7jTndh+ebwD57gVkpfWYGU9f2cBeSf2s586CwQQ6l95uRMkcznFgL09uPuaBWTWzCZZkFDMO7WsykC0v",
	"2Sdzf1r4FU/EQemz7B4YFEYKl4pETifGy7gkyz23gbLeCj9QoHMeJoQ6k1SiTUqg60BW4vQGxBe7Eah1",
	"EfTOVNBDD/kupNZsStDBJpS6HWvLlGIfygTkypBruxdp3p+QLXVQkC7TwrbskDA6xhrN22umxKl7zEox",
	"ox3dI9PHvIRwotvu136DHP3Exa+mi505RUEXxPDSh+XY7linzM2KgUsEfAc5GEPhrjjxomqatuFZn3GI",
	"jAvsIaPItNTSShW3K3tfxzUs413RE80zDQtSz2s/UKQXtjZRrLcexx24y2YOjDFjviJDV1tD9gBCl9DH",
	"32ApziLZiWXXkSwynEZ7jg9nTs2k/LUCimZy+9KRwlPs3KEKDnyqX6azWiyCsZC3TUc7BhrUEo9/mEgv",
	"/RSXCqENUtSVA4KO29qbunagCur4O/ELL/o0aKe8uJw77C8nO8bRevjgF3Of04wusZE+IcosHFSmqeY1",
	"aJ333r4M1tPqEc1PsGriJGvkc0IeJ5+RfCH8R6Ep/KBnu0Dgrcz75I/7qJzNsRgQgWqqZXKz1TmR5DhH",
	"YUlS4u4xmZN8FMDsJpeLwGxk88pW43byl2bkeypzNiEvUPXBKkgsnuIHMpycUs4PpZXqBer0CgxFgZRf",
	"mVsoGPcgvqFo7HIcRGq0gziAVJJba16gyA00j0bVVeLacK2slsNSqWJlJerZ5273Y3fQmXU/qbSuqiSx",
	"/qP723XvoqfTw46Gk6lyRpL1rGV56dG4N7iaTcet3kD8I/hdp+KazFqDzkwXlZ7Mxt3RUPogKb+m/75t",
	"dfRvcqzptZp3oktJj1rjj7Pp8HYsfujdiHatwXTWaU1V8trptXSEat/2p7fjVj/qnEjUFf182Z1Me5+k",
	"4eNjr6PWdtm66Uljyc3tpNeWnojDm6FMgNsfXg1nF632R1XMef/bpDe46srlyNXfdnpDDbgsNf3hGRHF",
	"811eDZlSkmbcxapueU0axf3LVkcmwWNqhKOsmgWZQk2ZESuYc1+oTjnMZRmjmpK+ta+7nVtZ/f+3cfdS",
	"UElJYYKfDZefEC8DGUzBjE5OYhUja8XkLG0PMmYoFgd5ideDEC8Xkc1rzzU4PvnOjAErJe/qgsI12os9",
	"ya8TZBmm8tU2rfhX27ziX7/ZJiq3zmhuO/XOdupvtlN/s86mXj2depT6as+zasLL2H2Ir+vWs55/y5Ap",
	"DaHWHuS0kWlvxLzvffcaegtrr60+ukeSnro5OfQD965OKS7jKtEri7mA7DP2XAdSY1S/2tQ7xq03FRRm",
	"LvOokMVCHWkZ/8Gw06SUSxLxdusNdthIJknDm3QwcTxPaRVF/oYEqdnKbCbqVW43G4oqTBZ0KjfX/2yh",
	"hxc4qGGZWdHafN3D3kNDMWyLrqO8us158Z7LrQdpeUAlOpYDFis9mephTLctPloRC1ZltRsq7SpuyR7l",
	"ZhFk2khDzXS+wJf2CBS/KDz5O3gPCsTOl/4ysOO+DD8AkW/IdEOmS5Fpdkg9kf20KwV5DVi+bS57mcv1",
	"QfVwlbkPWuRhoVwdEkybwijjNwiyLUVWQ8XbJofS9ZIOHaSu5RyYUoOpozFfFo3AB8A+KiA1It7OJ2sM",
	"vd+y3Wxy0t2k1awZg345xqC/HzZo9nWgGLHIRpy8CUXRWYIFKWWRrl6qZnhvzlk3NWekIwz7yyq5lT3C",
	"mDWDQsOcIIYSOa35nKL7nIRWutkD3JWCp+p2TUoeQ37dHvnRHNS0IpQXBVyFXuxHUD4/YCl5VjnUB+wf",
	"oHaOXZVcaaTorA/LB1H6zj3u3Um9LXXdIhukk42MePtYeJYEwIEYVxxHWp81GvNEpJ2qLXrT619kG0ww",
	"30oUbxM312Q6h3ITJhm7kpG96I7I4BnjpD68x0u59hvkbw11uLl0pzOX/iplX9MoZMVG3yEPcegVJVqz",
	"sHzYs9KX0lCSqwz4N8E+v0EcBgxYQQrdPTYvFm0qvUULmTjZqtClIwaug+v1s9hghcvLPqfcRV5iae2H",
	"pU8Tq4y0pcz/5oUcYlJjMb+rfOFs39Uqc0X7WTFTcXDQQXNC7sqJEktClh7aeNuSHhMryFYcLkv2wj7j",
	"cEnVJbfvtkEUsyBou0Q3QVkoYrykdOXDjbOCJXvx7Xru0ZJ9otSd9p3usV8SDg9ozvSbZd9pR7Z8O0cH",
	"X6QIbQ8g0g1qN6j9DFFbMzd7tesnbZmBYNLOZgg3Hjawf4Y0vvm3Y438oR9EWWczaJnjZu4pyLJUUlJT",
	"+Wz28rPoBlnVAOBigT0MjXlWjAyvi+6xg5KslF1gSrwWyv4YxyhdkfK/PkaBidC34ykqNRi9nA7ILH6o",
	"z3q2wlRAqQM5ssoormAatzoYEtxXSmKWV7viUZJuGy9+K3aL94hakI6xNwj/OeoOOiodysVwem0gdkmn",
	"/9pISx2y8aGEpLyjsX3oDWsVEMjy8SrHDgepcMlS7ri1Xjcjmme5w6rEPxetSVfnALoetj92v5ycnlwN",
	"+5exvDWy0cfu9MJUEFROcYh1r+aomkwwcGUPY0PXzbJmaJeN4KuFAWXjwR1ZLEr0eNAeE9ZdcjdSHd4e",
	"ZPx24wYXzS7EkCKHlKnzOUVwHVur6NwmPofYT6hhyh1eOuXXuHt122+NozS7n3v9zqzdGncEO9r71JvI",
	"gI9uq9OVgSjh59nn3vQ69uGyN55MZ9ctifiTbns46IR/JcNkErE04m58mQUTqb/aw0GUbOvii5jk6lb/",
	"ezi+ag16v7d0UE77djzuDvS8mTcrZq3M4J8RpFoRaVVSIW56zcqmuJ/YJwf7yxc3UFfdvpZBCZfre+SR",
	"wKXdejUGTMsyDx8X9EXeZMc+mHTZh+dyRIUKQg55SFOyaDpzPIjXiJZhWbLj2tFXtC6ZqlHVUutjxlUC",
	"LlMOqSo27yUl241NuZ8r2VCgBaRwjbiGRUXJSb96ZVOPRf1GOpCmGG6iZZjGw1zImm28MgnwBEgmqktm",
	"dK/4MsXI/Yz5qo/XmB9l5GFY0b6WoUtmibarEyVfnJh9qlQOE1m6PjwZ62L3skdvMSB8Ylc8N0uS5zYJ",
	"CThUrkTFZOWAiM+nJT9iF92gW3Emu++fCiVh8NzoUVHegTooU5k5KtMoiwQKFQS8UnQrtYSDnDQq0LJa",
	"CFA2x2+sO1ld+8i26zVUIZ0VzfZZVPjptHr7OFDWL8YE4xikbOwKBvpb1qU4GMLgkRd+N1cOPZBWmjZ3",
	"iZHnpvJvDzpK9A7SYsfyOciEFKNueyp/nbQuuuOb7nTcawvxe9wa6Daj7rjdHUx7pljsYOLMil73Qk5y",
	"q4TsoK8b5BgVj0IAc42hLkFCE2s3nvBFjAHvujfVxbJk+g31T5kEXJfQaoW/Rim6r1oygbWunzWZjrut",
	"j0awTRCkzko6YC9z1dPLJUXLkpm2WroTmmhtY1FKsvUGUjS8RzRMbmL/zsiNSAheFNSAWmCPIyrDLUp4",
	"PEWdxItfwDupZRx1F0muqeQMI9G5YHx559W2K00R61/w/Mc9A6tMNcE85VSYNUvALJQdnMMqemXjUe6T",
	"epjnOvgkDo+xG5Jd9g3nuGjmu0LSrXSSLUMWs1H2ceD4AuGUfe/q8QMOyELitbJj4pL9CmiPSn53WQBe",
	"hhwinuCChvnw2iceZTErry7NMW9pLnYd7LOcg4CSZBuSMxYAO+P8S1/k6vf1Ke5j6v2oYPiPWK9KKObg",
	"NfRs5dRijEzyTpYsE1O2/DbZ+uYDwKznK6uGgJmFJ32mYTzVN5lRKJISih5/3VL3C2ndfs08XysBbO9B",
	"qDXYrwZdJULJuuaFC3fDxXSFPiNkW5YzFCOrWDUOSRsv+up0ISXiBEsHFlaqT3pcXeiKrFEVNMAyps90",
	"rz5jPz8hgzxA1wqPytZbXROfr2z96LbrfpTS1q7D0HG2VOXmsO80DRKs2iST2KjNlT0S0Y9hf9kOk4cU",
	"WznDlrH+YUGNEoU3KhvkLO3EYc+gvXghoX9nHbhXWTFZoGUvBNLOh2vs9Am5224SFQFKWcvKGMustNSS",
	"ACD3YCNbKTXzI2lka8jOn2VIqOUJTcohNZWXkk/tMd7ZHPNdPSnRcyuCLo1MUJVXK5WLveL7VeIxSk74",
	"Qz5LSRAEI1R5oLJHKvtUZVlfD7HflniCanpI9nXBhxgzq9kyqzwwtVpDDy8FbmNaSrt5jsbDvweWo/Df",
	"s/FwcnJ68qXbGs8uvszE/1N/zmJmqMTvo37ry/DyUiYuD/w4s61X7da4qxKVy3/M9hxO9e+xLjrL+t4g",
	"s8m0NZ1NRv2eTGiuf4wt5ap10531h9IG1G99Cf7Zm7av9b+VwSz5R+tTd9y6ihK3z1rjSXcQVIidzFoX",
	"w0/doFXMCCeX05tMlQEuZY+bjMatL7P2dUtmfA9Tsie6fJrIxUvohP+eTYdTOXf0yy9f1J/aSqX/lfg5",
	"7NVvTaaz38JM9BdfZIb22bg1uOqm/45D+OLL7GY4mF7H/hmHrOz3ZTa8lAnz936IN70e3nRlcvnWZ1nN",
	"N/F3vOHn3mDWH07i/4x/1hbN+D9jWCoAOZE56PvdWRwF07/GN3k9nM7aw35n9vtwIMHT+tTq9VsXorHo",
	"KU58NBoOuoPpZHbZUp0kUk2/jKI2ytVZ3oPgJwn2xC9JXI39FV9QaypPSpYimKrTDBeQwqnZzW1/2lM4",
	"YDJQOpDxQMo4wO2qQK1VsqSriURhxrGTqdA0a4gxm2hDcl5sj2wlgZHXqkJZbrXmDmKOUWkmW5Qpdqt6",
	"TNFXXkIxxkxpOkta7SLfX2tTXeWoCdOAW3bp6cjp5GCYtVTq0Sto5nbb0HeQ55n8DjBrr+B6g4nPVngz",
	"CdP/Z7b0IGPY6UgH7GsEXXNenzZZbzzEkduF1DOWJeqgUFOU+VkzdvmrsllO9+sKz7E5lyZml9iHnvEj",
	"oQuEufEzRSjvCMS3vCRIPf8KriUs8lXZfIw2OY36xgBIzG6gD5eItlfQ85C/NLYbED8Oz+lFx1hSKkwk",
	"WtxijKC7y2smrp5rLl4loZsLoBFF9xg9GMmdYMJV3SEbdJlsaI5dYbJlG+S75gWHDYZ+Jxl1l91sjNhW",
	"SeH5HaZzNyeP1gVF8M68p9v1BlM0zgXTZ0jXCaE8JTd7btvoooTZZ0I913xXC8hb9ee4bjJIGjL4dGQQ",
	"NXSwoYNFdNB8Gi+WDopFh/6ACZfXQHTTnpit6eyiNQ1EcYOkI0Y7IFha9jfWy1Sfy2X8lF0MumAzQCYb",
	"6KfhEapLQsAMB7OroXZh1dGu2k81/cOsN4hE4cFwKgTb6F+xr2aoSqV5OsxdHklQlk7//6P8f3/4eTCb",
	"tD51lT7m9uparKXb6uv1Dm9G/e60G6ojOsPbi778V7c1HnQ7s/GtWGt3PB7KIOLub9Nxa3bRmnRn10pw",
	"lj2VIqQT/inFZfW3LE436w2mw5kaXLYVsn5vOrv4MlNoJP9Uyol+J1RSjG8HsrbeYNodTHvDQas/+6x3",
	"1u9eTmfDgVyK+HM4maiqe+FPo9Zk0u3MApCMeu2PWnGhqv9NlBJq2p21RqNuayxEfvHbf9+2+r3pF7WH",
	"iXJGDv4n4Dztiu1I4V+BdXJ9Ox3eai3CsN9VK1B/jnsfY//SraQqKGw0HfdGCuTB3sT/IxXMJAcbWBPE",
	"1QRxNUFc30UQFwvpe3H/xEvwQgPAJP06PGlpSZWakWra6dfSWVkrpVi1MI3vZyrNXI84yyPkdxLDtlWZ",
	"+/Y6Q/G3IsXm+XhiJYac8FGw62PabKzcfXqvgmPQBpjW59YXox5eDJOdbLUgfopSQm0vyMr+LkmHAB8Z",
	"i6IveJQI0MYbaeuzkomZq1AN0wH1pUBXA1vCw8FKVYQX7cvearHukUp1lKXl9uPfbKQpy7xAxrA0pPpU",
	"SD+UdgA61BXCrghYNQeJqtnWKqV2qu5aEy+AWP2JPYCfSKaFyrwn48MTV1W5M+Yh9u+6h31n1fNd7EBO",
	"TAlRq7mWRv1kfYML6NwVjD+G/l2lNEXlfVeDPvlLC1oZF7bM7S6/Zng9m0n/0S9R1D5/56qNcd/6sxU9",
	"/Iz9PmGZ+Lwh2L4K/IaSOZxjD3Nkw8rHcu4lc8iZxEarK5qzmb2szHsVBvLkPkJ5/onIJsYDUcXU+hYn",
	"G29pHk4y5HZse51eXg9ah5q/haCVYfk5dNGQ3AJiWVPQEhEhY5jZt+YX0L7xPaJwmf2iCIixnuR6LEfT",
	"RU7MoUwyCA5R1vM5ojEibzG2A7fLFZ9wBL10NrqcTitYwldVZXSzbb3wdtf23P3C25U48WWJAj0xoj/0",
	"LwhflfG3lZ1lJkDrJ2OJ3U2JpsONoCNbP6CiVt249QykRYxu3b5b4oBUhxJntML8YiergtYvCwrBemwv",
	"wGEpossn5jP07my7edhHJSAkmpeAj0cYm4Rk3cZV3JSNJiiWq0qwWruSS2l5hKiDfG6icbqRt2UTb7tc",
	"Jq2MsWb2295g5y4QEq2ayz2N9irF2ubANPWfcGrKkWMuSJtXyn1TAlU2ZFMCUzZbXgLAh2Sft75RDDoX",
	"W3tWkUHn0rMv9sewv7R/aFgeZjJOPGSD6VkNh3Sw9byC5qyUbdW+Mb5DJU79OLm72IPg2Vu+e4NLVOiT",
	"evIyoFGK9YcSkb+c4o09hjxSwNtDibdFsMzl6PUD9ks8Fyaemx2mabQHXlHkSK7SBK/R70SVw0kpGbNT",
	"n5HQumVXJ54h3pLi3TSdtTgH5b7ZijZ69Qd4yr2EXepUZxOy4A+Qok+IsoO89XlqwHaAU0YHF2MPo2O7",
	"sYe1o7txBIPje04PDbHCjp+Q7xJaeoV6+GDagYl7zGl/QGBEiB7SEjh80IabwAgVFZTQBUT7F7N2/za7",
	"iOg0AYiE09VoOJ6GGfdlcNJNS8ZiXX8ZDwfX3avhyenJdevzx+6XrsXYGgZ5mcQLYkqsa5zcq6lK3rZP",
	"Ua8wIk6Gel3+poNz2q3JdPb+7btfZu3hzUVvoALREh/GrU5rPBsO+l9m79+mvv5HwddgUN1sr8Vf91r8",
	"stciPkPq6/u3s3fvZ22dxDD+81/1r8Ehzz59SLX5kN31w+xn/atAsNnws1ibGi0fIQrp2RzyCCVz7Qj5",
	"SPbn6ckckzVyVtDHDqtrzMOCo1a4ts1Z3wkSkAmb+eKUJRD06lqx8iaqa7SgYGw94xnIg8+gExxmimRl",
	"ZTAwGi+K8CL2/QZuDivxixYLJL0yOqWWuKBkXSldjn39qTbxg00Z8oap7Cmlc61QxIi3FSOX2zMn0wMy",
	"g2QehZmv2m1QZo7hAtQ7wLfSOslGAXbmY1RdyJTKYvHEaJXKhpCPYPXglmUqgEIsMzDqBXjGDhIywlHs",
	"3QAyUdxKkr31sQB/izGUzoVccuXb1EhGuKYbGoWhdENrCSPdsUTMr4ZHrndPToXIAs8z353kmHQ5pDzn",
	"e3xXVsCtBi+TtJcGahFS5mBWHuRldFdRPqUypGD/RAvPqVQWPhsfyoL1FIGDHXwr7WmJ4RjKEBOWosAV",
	"1HiVULf0Jg/Z31OcSRVV5S1D7hitIfaxv6y+ZhoMYa/Rrq6bUZLFZwT5CtFLQpEDWRYlcP+9ZRy5I4oc",
	"vMFcuvaNQqcfW6cHxyNbt03uEU1aYGrIS+uiB+mxZGkLXOitTvEaMQ7XG3v2W+Ymda0do2IAq9arPJgT",
	"3cd7rJ8RKBR5UDy419s1du2nY3e7kJntOSW2yXzyUGJ5bEsX0EEjihjbUtteHK03iEJeqcclQh7r4zvr",
	"rqut7yLKOKHr8uf2gPjF1ptfeWSOpqWXrXtX6Ih9t4OpCjjooCVFZQxR7sS6MqQ1AcplSp6cFB2mTHs8",
	"QtXQnob2NLQnn/ZsUTmpE242XR/OjUlJglq2GW7yUBYX+IRdRKzZ0RvkYjghW+qgIGOvhfOBrIFgU3v+",
	"MmxYRnflEccqtKMftPvz9GSta1AUJoJsr5lqz6Gr/YEL+9wEjfPqlvjoKw/y3pbNk6vjm6Wh1t+WcBvR",
	"KY2zCpyge0y27JAVSZKJ3NZm42GnZGWu8V7frFXqGXprWMZXRjbPGa4uGB7g3YYYdms8TXbAKeZFHhAH",
	"Q0/SAJvbPEk1DwITbFRIk6BhGB4d87vJVYgG7WJ9sgwGmUV5sx0DKlj8+L5N3M6uRoOgo0fyC/tK0aJX",
	"IuzsN9neTv8Q0s+9F22dXQHIOMhNjPqW0MjCDXTsOQ7ku18QLJGpkvIS7Xmp0nty1wn0t4N2AKjKSuxy",
	"ICvUeT8qQAvCTo1AqwqsQt7rEVksiyJUpRiweuJ87c2P4YtustgXPvCZ2tHopD1sCk8syT2msvZb8JHx",
	"NAqV+MjklLVwlEG7VIxlSS4we5RD+MBYp/yISbr10ATJmLUSXGasU0HymIMgUMhDlWCdUussyQaleh/E",
	"liTHqsY5lLVhJB/CmGvh4Lp/cnoyuGidnJ60e+P27eTk9OR2MBl1273LXreT6UCn+OvqppD7Cvx56R0H",
	"r0XqIeIXkJdKmFfOt0r6qJUaf+PBnaHct/g0h86dTMZ1YMoYCY9x6DmSSBfTOTk96Q5ub2Y/fzw5PZkY",
	"Dj05QKpARgYGuKbi9cEQl6bIm6jJZKWTRdiwuJh48Mjp5A9OYsa281xfmrJ7PczjBN0jnxvzaYRfjb4S",
	"SnlirZy9j6/aOGiildG1JWw1E59mbn47QkuUNdVWi31gpvS++0HyqmOouTZE0vtuuYWE41168AAD9IJs",
	"DS5p4kt7BY1JeHUsbu7HvP5kIQtUQs8r+m4exQY++VXEfOjtGHLFkz4JLC6li64+jAIjT4JWnExXCEC+",
	"JmyzQhQ7IIYqYI488gAeVthZARc9gAfseUBcl7OTUxtlOpkzRO+LVr6J2TCSa2vF1hW0ApCBNYLiny7A",
	"PpBPsvjHeg3IAlwvLdeWZd9Jzh58Mc74v0AwCFgFo5wexwwT3L3cdCMKqT5j3y3yMIrwj6OvPP9mahQ1",
	"Etuy5Sj03J2gxHAu6m/QV0sIFSZI5SUis1coGMmmMaH4G/G54uptjj8d8lbGRpQG3wHc7Kq4qJie7Rqn",
	"clptgtwJFp1lKKklRl56u7kqsiIL0Pz17QGvBkaeK0Qge379MuhSlmcv4S4QXihmCb7MR0KlwuLaYdNu",
	"lNRVt3gzAhSznCMTJ/PglUSrsuebRhXLVeahWMFiJ2i5Rj5vOXyrLnvqwcAcMNUEuJBD8VQCLt5X2QHM",
	"IefIBWJ28UgdiBc3iFPsPM6BJmdZBKWEymBvigWU+ctk2q2OhTasHzXdU2iIfxK6sxkmOslpol9pDGhD",
	"b13i/B3orQFzkA8pJmdAvNCAbZBgJxhY4K/IBZCDtw1SvGikSJIyS9TAvksIjSHH/4nO/Czgef/PrxGW",
	"vH9/9p/vBbN7vQSEgneAaUIWcfEoOUqa042P9ssv/yvZOMaaxtv9x3vgKmcYcAlXFPkrhHmyZ8JzJt63",
	"wesXitfGfqoS3nBx8us/8teQO/np0bj9CFBt4i+wa5OPVG97mtE1HcISn2BEvJ1P1hh6v+3f+ugjUB/m",
	"2F+CryAo7igEVkEEBEfwioEV5iAaWdyakGuteVwbISWdoTJjy19sl7Y70pZ3j77l322X9u1IW/521C0n",
	"fBgLcpuqhvnk5F9mArNH0kvy/yXVRilV0fXyNKHXgXNyjyQ4ZavalEjjtIYoqUGqYxEpbVJyfmmCSij1",
	"sJ/1lFtOFVfkJSe6nbYBD3zCJXsT1yqGD36wWcEJsbMsQ9RxVF1SCXEN/fwM15qtr84tFOROkszeYTNs",
	"go0UeoIFDW0iMA2qmrJXUnSflnJ0ik+c8c7aal5k/wLxXLbJFdBVQsbvQEJ/Mm5TnWMVfjN+gtnidc75",
	"/QgC9gs/0zzpOOdkG/m4QcujoGWecHsksdTW07BNCHWxDzliJji9KLlWPqtHkWyzRn42su3B2949wbYP",
	"l28P3va3I2+7bhk3RVcO8msKuftqHHRKwMmK8wrWaCU+lBEdPLg7yBS9x73bKTeT3RJDte3FuZRpJzFM",
	"r4zUlmkOCOBeZYsZkk1quBLb3GOyU0OV2qqBu8tDEivDeAX3JsGV1eSzZvFQ1uybeQ+9bUkPv5Tio3S1",
	"YM2FZqjOvuH1lq9A2CSuLlpQsgYDQvnqNKDMG4ruIfYE2RagPlP/jfd2KIIMMeB4xLl7wAzFhrEk4Mst",
	"yxIaELwDMmcaFlLDQ0zm88F6Yzs4C16C1OjJjZUfOe/0Di2YahNAkiQ/Wx/zA/2wE9Ws9lfskTJZ+O3r",
	"LRidjh+wZUWIws1UP4hSm944BuL1DICxx+eULYqL3Qzl8w2Cfvz6ONBztjI2SMi9EMjxAPSXHgKv5VW+",
	"R5ShN4ATSV0iVi/OCYpbKP4d+d1F5MqWJYTYK7dcj/jLnDWdgRYQg6rumGkW9h4B6LsAghWCbvDJR0up",
	"b7Bc6704AwfarDe40gCqVKN6yWm+OQBgMDJ4/e1NSRBmoZEODd7DnJxgqK9hF8On6QMxfp3aRx3sxR6V",
	"Re+n3oIqwLylmO8mgloHSb4ZdlpbLj0xJRWXnufi1+jIVpzLevhzBCmiQWv112Vwzn//PD05jQ0hv6bH",
	"+FOaMFQQaRITh4sFdoQY1xr1pOruBv6bUKAKB4IgrESaezD3xIgTDjmTzTvE2QoWUqlGYsnnT96fvT17",
	"K/3IN8iHG3zy68mHs7dn705OTzaQryQIzuEGn9+/O3t3voRrdP6H+O9sc/fn+QIh99zTsbtLlOn5jtUK",
	"HOgDiviW+uJK7IAH6RKBDdx5BLrsDIAeF/d2Mh0PB1f9L4Aih6zXyHeRC/gKcuB4ggVhALI7uXsXLxZM",
	"3vwtQ+CfJy3HQRv+U9d3iIv95a9g+Q1v/nkiqQKiAixEKhV1WqSTPr6XhRk/qa1SuEZc1lD+x57VTYYC",
	"gxHFa0h34CPagTHaUMSQL68/BGIcIYGL1gJqJ0EA6YkG1YlKXIGpYIM43SKNB9DyPdlbEkOAC9CGCxfk",
	"XMMXAubDDVsRHlBPqe2FXP6bbZCDF1iAFa/RGVDo+Sv48uXLl5ubTmd2fX1zM5kE2/mfLaK7aD+ijwze",
	"im9g72all9sm6zUELvLwGgtK72Em16bX4gDpR8zEHuZIbwO50do42fTRPfIE43QKnBX2XPVPyDnF8y1H",
	"huWqcROLtQyszooA39/YlG6RWDX2HW/rIrDx4I4pfF0J/tMHc7QgFAFpqs2Av4Zl1trlmAzfy+otJpjH",
	"ImDSa7tQn4AUfcQi1cw78AADvFXZpl8xIKYED5ivAHQcec0IlX+TLTcsTzXMX9O/ZLTehviagXv/9q2W",
	"QjlScTIwCkU+/zcj/n85K0gZ4n+7nV7+9NeQ5ELbqLp0WtU/07LhyfCjovRBvayTK8SBoGFA3FXAOORb",
	"ZTSXPmn/OJGX+1+iTzEdPBdUaQS1376ZIiLflfngAPQ88sAkVwEpZkodJxeywB5S9I2tRBPo7yTNU0VB",
	"2bmLmUPRBvoORgzMEX9ASLEc/IH8c/v27QdnTs/lP1D2n+qPDl4szuWSgcqv8qv6fK6/A5kzIsBBuSDk",
	"u+Hfgq7PkaDBriTLSxX5rcjzWWri7tcNcgQB2DK4RL8CkPoO3r0BY5XgByy2nhe8D2C+Az7hYAMZE4Mn",
	"l0RofEVnAEgQyzgqTREFVNaEcfGqCNYtPGmUXiF4/wZcCm5PdBFsKePhPVUsHWYgwOmz/Q18eAM+Q8zB",
	"b4Ahh/guSzf4+Q1QxBtF40ph/T2ATBGI+OYSu1kKLN2RLYASvAJVkHhM+UpxoZLqME15kAsY9p398dIr",
	"+uUN6C2AT9QrIben6O8peEhsRZ69q6QGJiCoczFljPkXOeb+gEskRBIfPYDQy0XtXowZgPU0fNXllgIr",
	"pY++ciEueAJQyU0ZH/dOcB1f5Csv685KSAGJJ0kkiB29OmgJreSjLh508bDnP+oJYJZ72bu+a1xgjA+R",
	"bx/k0YNfZZmxS15ukd/dS5jecbVHDoSPVeXnLnRGY/nvXfqVoEhwSgL0ssDyGQDd4EVUxIKJlzFgXwNC",
	"qTmr+GDypJQoIMY9v8+RUbKIRJhh9f7dC6AQT41FY8QpRvcofjjiICOnRHUMUB5rLladQ2clhhJS6USi",
	"I4rjUPKkWhltC0Hxv8//d3K/dpmhBNvFiY9ic2amiLKB1yeMHgC8h9iDcw+BvS0DslHeIRGgwvlZClw+",
	"9HYcO0zitxFSAs5XW+yyS0rWI8L4kiI2hv4SXew0dubi+HcrqQmAO5Bp3m8tWaFg0W/B38CFKs0PRlRl",
	"IzsF78DfwGdI19sNeA/+BvqKhGStXQx5Q1zUc08OfPF78k5RBB4gE6+SjAA2iIdspL+WEQpTE6wwV+pe",
	"mbQIuca5rjE/bCZd9jtnM8H3kpP4xJfvWXi4DPhISNcSQ7Vgbt7YgPgBapSd23cFpUWKa/cE1oubIm6Z",
	"C3dS1y4TO51KEvnTfPeT+P8p8LCPmEMoOgWIO2dnZ29y0MqFO0l9SvE7UiuBF2C7caVifb4D0Adw62JO",
	"qGGyFWS3sjkrCYZx7L2WDL98o8WhOxQpvf5C6qf2dB/ywUgqoH66ufmp05leX/96c/PrZPK7YbEeZHzk",
	"wd1U5VnKuHI5aZgy4CVlPS3pAZkVdXdBOLjHLiJyKxqSOcuRCZAUBN2alqUgq4AaHKXi9GEMkuL3ykB8",
	"cQtWPpjsxa27JS5fvavuQI4CgpO1rhyq0lGF4AwrsLoyZBOQPLqEPv4GA18yATJCTbKS/Hb4OyloYrT3",
	"VshhyXylAPsgYJvEblWwhBkaewQ2jz+80h1UztgMPkNascTaBLU3QUGZukoRdZn2OJSI9NsCmFTZmZT1",
	"GXmTbfeZmXM5Y7uEarU2knyivEPzXYraS+bOBAtC+cWuHCxUCj0xH0Vs63EWWT9Md1DwswdjnRB3hJCq",
	"zC1SbaLlHa1oZIj/VyTlbuAS+4HJLWtVuqD7gcsy8excXxKZqU1dDdMZ6ASb3SCnm4ERt0nSGRvDilN/",
	"PBtBKxChxB0O0r7u+wnlCHbaOizlpphd+B//EocSt/3+419iX0n1i2CQFH8634XPjHxUYuJfKOYZpT8h",
	"3FUQ/xrBrxH8GsGvEfwawa+RsBoJ60XrBRrB7zkKfs9UPjuWONoIfo8u+D2BpCTe2seXlAQOXd32Ogy8",
	"lg51bzSsQ1lEWheBhdjEOfLdICdttsSE+BTBdStqaWcFFp1Az0U+F5hOIzr87ud3p+Ddz/8hmTzTxVcl",
	"uDNlHusIhVJSkEm807vxlBMxDvdjIpuq4fNYu6JtrDxxsy9mZDh87XPdFwuJcCAXZKJtCmy5YfxhJ2Z6",
	"cI77FFrpfJJvYqXDrcjMuAczMsq5SrRWHinQX6LwIXu93jKedDJBvmJQ38Tdls47nXOx1jzHqsN5rq6e",
	"2m6hLNxYmaUi3z18od+LEulf5Z1Lcp/T8HGp4Jos3goA489T8OjF3qzkq/cAaY6OsKU+V9QH8kz+nxUL",
	"AIQun8ez8aMjozz+koioHJlkTyCjk2JYqNApAwPP/5D/77l/FuCireedbJ1guqJXL1wcSF2DTHc8vbBc",
	"d7zK1K65Is0VKX1FzlUJfbGO/Nsyjtq9yFtzNI3EE2umXpaE9SNdyuhmSWTwFdYX3M95ULWbw5wbeZFo",
	"dSSX5MQkhfk7i4EixVboeSDYozSjJZ2QmZMGBw80jjEH+9Hdn+d/qBKFf5YLeNuRrXhVNlu5DB4pTAM9",
	"ohi+58pIIF0D8XQP9uGSju25P6o/gFetSDrP4z0NQnIF4f6PwKt8fy99WgdaJoY0RKgjKzklWbqAHATz",
	"gY5Ge3XWEu3VDYjdyniH1O2kBLrSkp2j5rwIGhUyDq0ouiMcGbiIQ+yZXq2wHaI9l+XiauW3rGFgyz8d",
	"0bEc+GhcIQ5io8Vfi/BnA1JqdhN7Onl79kua1TrQWh4XNvEZD4SSvNjRnYGxkTNjffae2TiEc+5yy/NS",
	"h5GvzNlSinwexP2l73bcfNGSTlDgb2B3CrAPg7/8UzAnfAX+BubGKEjRVMU1Wau5Y5toxfqbVN7NdX/M",
	"6y6eAY0O5W6+Q6Czwv5S+j6Eqeozcbm93/QA2BTZc0rwxsEetLNH4D1rvroO8YPcDDm7jdoUXNkaxWRj",
	"chEX9fQNL+n61eiNDDmlw+OtIqdGGJRWIEUDG3Hu/I/ojzyNa2yNGWrXDOkjPmztCQ4aJG+QvAjJXXyP",
	"WZBDv5qGIRoirUToxL7k0uPPK8RXiAJCZSaaWM4nHKFXWSR00QJuPX7y6wJ6DJ1aIGXSAcHS96AGt7un",
	"1a0eTWfc3PHMOx7eigr26uCuyestoKS84IJbHgxtuOPnfwT/PEilaHHhbY2OQYeMy5Z8KKOF1/1MNrSn",
	"oT0N7Tka7aFwYVacdsTXEXbuCjmEJij1x0j5uUKAUFedNCOUy0gvyBwkCy8JIi06qL+Mjh5uCVf/CaF8",
	"KHoYY86fxBc//SrpXFCIMjBHyAfyXhljY6KvpWLOyNaXFQIeVthZAahnlLE4+fNR0bPcBi+xJy5VuCkF",
	"0AWmjAMPcR6Ge2Cq0sZtZXJK9d8Y7B3grCCFDjc+lT5co+OtjTkrQrzqq1P9y61vFFQXUsnMY+7xp+D9",
	"KfiQ5x0fVCay1yJrO3YwaQ7zIt3224kgYE7oKfB3sMhhvxwAjhQmUC2LJEfgQYbkhmVvAWZAlkqL09zh",
	"ChOzJzOvA0UxBSsi00VufU5N7FT0tcR8LaDId8yert9BtQQTtsmPh4O5aPqgIED3ojfJDwubYxl3U2FR",
	"NbNiwb2SPFAfM15F4XPTvwAdRZqB2lZcjy6/ZPBj5xtKBIHK8b1RnFnYrOHOGu6s4c4a7qzhzhrurOHO",
	"Gu7su+fOAtbnYMYMxJkoe8bs/I8dgvRPS/6sUN3+BUEae6bij0Z0B96/ffs2W/su1lK33r3hGRueseEZ",
	"G56x4RkbnrHhGRueseEZK/KMVpwidu4aLrHhEhsuseESGy6x4RIbLrHhEhsu8Yez+ypW8VyVXjVyjH35",
	"2d437xmyjY37pwXuyWOukjQtyNysDzk4d6gr+8pasr/I3GoMbDfSbxw7d/kIKuto6ABXE2J2Y22OFOTZ",
	"u4LrIM72oBDHDWEMzz2kC4To4ODiSEcUVfjIBUMQzvlD1J146tKc4akmq72YT1HuH9GOTOuQf5qX+02P",
	"hNt7M1XHcL0/nbfCBiAUoaswVaoRFolWxwJDbJI6MhKIran6J8VgkNl9nBX0l3mBzCqhQECJivU2FZL6",
	"69z6E6yyXh6czP95pgernCxQr4udHCu3yvNNtV9U8Kq2FbOaUyI/h/AiLa1sdC6sO7TLg8Lojj1mQspG",
	"l9qICNC20lylBJ3qGVTvG/DIMrdGuXwLZc0hWXErr+paP2xVay4645Vs8ms9HXdu9RBk1tCoxswdXExD",
	"isKyppymasE5yrJpxXU0khkfJdS+BoWi8tJUCUxuJ1u/vEyNDAG+wgyE647eJMGi+XDDVoQHSbWkDQby",
	"jKpnyeoGNzedzuz6+uZmMjFpgfEaOcRFTVRxjWqlGEZWVCtp7AdrhdDyQkn8kA/LHAoegfgAcwacWNo1",
	"VPzQhBfMssbny7tLTZHRpsjoCyoy+t2X02Q16VaOXN6xZk1QU7i0KVzaFC49fuHSH1zoqqWCYZIxfMD+",
	"iJJ5US7lK8Q/J1s2UlcjdVXzehQsUCzhmMRm9WCu4GaDfDBHC0IREOidBX8NS2N2Mobv0TQH5jkc04X6",
	"BO6hpxapZt6BBxig7QZRRvxXTPnpyfJ40HFUKRAq/yZbbkxoLRrmr+lfRy75IchYDZmcxbE8YB9sIpKQ",
	"lFtLCKcCaJaqn8+xpg0FOi4Fes4X9bulji+TAtnqySooyKT6A/sLona6Di+/LXX5Y7nF7p/nETdkSgEa",
	"CnFAMI5ggT2lmoPYF4Cn8AE4hFAX+5AHt9N3AUUL7CMXONBztp5k5/Uiz/65ffv2gzOn5/IfKPWnTDka",
	"Qho4UFwocI/oDniQLtEpYARgDjADjFPiL70doMgh6zXyXXHFxE3ckS3YQMbAP09ajoM2/Keu7xAX+8tf",
	"wfIb3vzzBCjFCYKuojcreK+8d2NTk7UgjAy5Z3vZTUeCfXb/zoiv7g5HbsgSv9giSZmOtRLBsK8NeoZV",
	"bXFTNukI9i8rCewR6sSHWld5vVMSlkCSs7ICliY/RgtXQ4OKadCLN/g1VOflWt3b4Z1S+PcEup8sA2FK",
	"8zO6q4cyte4RhUk/zYZClaVQQkoNAdlQq4Za/VDUqj7KYKBopycbwhrSdDBpGgkoNuSpIU8NeaqTPBUx",
	"XCuyRuOtfwE9bwPpXcNqlaNn12nwNRTMgoIZvKQULEcajoUjNrXtatRrfUL+FlWpSYMXYeC5uItQ5UGg",
	"W1/8haCzAuJi1KO90qX4I/X5+RyTNXJW0Bd//BFk2DisXH80JPQsCvcLUsgRVf5zOg47Wsh+Wf/48E1h",
	"/1oTrqSmjx9C4+dbC3kpEcV0hzzEodeBHH6mcLNJ1mw+Aj8lA6AS1yu8tPqmikur72/RpQ1LQMcITEna",
	"xGIQOHdWW/9OoF9VsqQHAMGoFpRpj/YEZ9LWi2moTwH1CQAWQl+yvb45gE18H6jPjUx3MH2xThNxGM0I",
	"T7ljJBdOeGMCwhB0OoQoCGxhz4MkiPVcauRlDWFobmh9HIBAK4FeT3qB1VWzv76zzd2f53PylTmEoupX",
	"FIJwjD1BIPpw1Ms22zTey4338qM7RUapLjjZBCy29J+TWC+hzVbk4Qx0VKVmgBn4cGbKJLpdR0n2Moo8",
	"fzitGDDIkCw4rYpEgwfseXJVKoGYTvHIsc6LEcaasw3hQeLD+J4EZhm3QKa4dNTci/DArEsHFThnBpSx",
	"qoNmQHLPLB0zJa2P7Sc7JZT+vketH4/sls8es8LLlYeXK96vkEbm8Q4+jFr3y0atjxGnGN0jeV/1yrSu",
	"UYYglcGABULuuUM8QvPf+9aoJ80R+r2LTBJgA3cegS47A6An6dlkOh4Orvpf9i0TjoflFYVM6UZdvFgw",
	"ybBsGcoxVyhLRZZh1SP0Eh1fqG/Yica4UE9Kx5BeyzsHxPWreF/Pw+DlAmlaWxHDRFcUiTdeoL3MFHMG",
	"QDdg5mksilojXoAumsWKDyafXXWHxbj51CXz7k6jLTz7G3wkW30+Dpd+DvSpKeyKMKTq8+BhHx0oDUr+",
	"MRgmto49jOiHczXUvKHmL144fHwRIrxAVWUIL3YDrUmEAPHFTgiqh9EIqcbUaiyVKTWTSoyi6Roy0ZCJ",
	"JgL+u9B+RLe6Ku2SZONiBzRlyCdfI+ig3FxsskEBfTlalt/nU27GRADiK4wsTyx3LY+ac1gvsI/gcoti",
	"QDTlxpHtjg4vNY0FxIL1PCHMZL59S8CJting5V36ftiJmbKBN4ndDz/P55vrfSJzcbuQK3mQyrzNQa27",
	"1+st40kdA/JVOq43EQ28uTnvdM4F82MuckV5J13oKpHjyibrVldPbbdQFm6szFKR7x6+0ALSowuFFVIe",
	"2e6REbWmpaOvkpn79Ix2YJ+XXy/+6vHT8w/jBFYStwh1p6/FE//mFPRfK6L95hRMXsvcc2+M5TCXpWhF",
	"fHpVHGZ/iR3Bgq2FcAoeEJSFKmPMe2AXWlCyBtBPkOZXTIkdFPngNfp6FpBp8EC2ngugxzLG0UZPVUgK",
	"+q5+t9mbPI7fRW09UbaxVhlbGzf+qklsAq68lFtt0mNGJk7UCdJlQpuUnAAk178nLBRUB4tV7jpS4rAD",
	"k4WFVaTyi4FFMZ3J/al0kdEuK1VIOr5TY9tDkFpsM3W4+YWh4kWhcmXBJ+ZXn0jcqUsCPlbGvYK6PSWu",
	"Tok6Wy7cFSNV2KippHfYCSMfUej1Cbnbbuqik/oUbc6bku3moui8442OBQc1x2GIrndjse8VXq765OGc",
	"5278WrWSxeROjpxUU05SV2k9sb1zjzzIp2QPHGJb533ykA2SP/Q/xFr+LAJN4bOiRfjEghh4/Up56b06",
	"Ba8Elyr+L5D21Ztsa0ZsSbkWjTxAX0djlC3hBhzI0ZJQjKSmROwBM46dyPaRq54Q7SV+s5x61rJB+cpu",
	"k7BrvYLfXKOlPjBOABNSB9t4mDMw353l1O4Xayq/k9hly6QCh+1HvfSs/FNv7efwdAUBa64HWErZ+gx0",
	"/E/EOz4xx/xMqwM+Ua3ERueQR1MPUDmkHu4o7pZQqV+yYCv4lEIxqXw/cxiKZLtGrnh+csUKc8CTh5TD",
	"YqvEIB1E5wc41oR5KVwxjlR6iQNUZCwzq4uc8ELWduLvGjSqRjdioKxW0DR1bkQNECMWZI3EZ4UeRsQ5",
	"n6uDfCoE+tAg0AtHoDX+ekgCh4rocyNmvSEuaijQ0yBQ6twkFsgSiOC1vtrnI0I84JD1nLypgFcbQrxH",
	"Ryux5AajngVGyfMvjzZBlomnetCa8qwNOtf8woaJU56YV3vf4HaD28fC7SdmIxvUblD7cfjaEOOfjMFt",
	"cL3B9cM47n+Teb5Hw9+DBo0odZCWWcOxLv3yv8m8mnNf7DyP5dhnVnT/m8wPSAconXT3aOIV4n8nc6ac",
	"boqw9O9kDqSjRWT7BK8xOgO3N6OxtL+enZlcf/VVOSyv3hObQjuQxwzq+wXPDbO7RwtZ+MHp/pgwXtra",
	"eIW4uP/SxMgVRgZX7u9kvn/jzl3IoQOZuhOG2ycGjdrJ8feuWic2zvN2km3w/DvB832UzEd1slhgB0Nv",
	"4hCah+4VH5thavjmFjS34BFuQYDVKg0jLb4G2/UGU1Q7+t/qYRu0/7FyaDxh8MdR7tM2xGOrayTdS9n5",
	"H+rPg4qv5N2ribNC7tYrFGJaQaxpuqaRrzeWrdAJVl+3SqcccjQ5yeu+BQHaPELBbn0fZKAsZIw4WBY8",
	"kxFTAgNjKGa8WB70l9tU0dtUcriwxZF0McEEB4ZYbjcyvNiLLdes+lC+1OY9q88VlWxPnHPkiC/GUaIW",
	"2JHDFl5+zqynZeAuPbiU9GSBuLPC/jKIyldpuyBFwNlSinzu7QB0OL5H4PWXN6cA+8FfgzenYIN8V3R+",
	"PXpzKrN7Be8veH3xxpgyS/QPY7zLJLlpxbrqsKl/HTF6OmkACK5+MtJdU5UMQnSu4ujoheBRzEnBW4lW",
	"DXVqWJS6ERfKuDkK5hLFSiDwHwGa/FnwqL6ztJIao6KSbHQsKOpRLKPN7Wne9uZtb972SqSxyjPf0MuG",
	"22i4jcIrdYl96H0iHBXdqqjhi7hXDbY+I2zV6LoQKATuCT/sFfhMMUc9nxVhbNiuQdgGYSsh7IPAIIB9",
	"Zo+vfVn4Kd8Zsb/X8lga4tREdbntbQhjeO6hIDWA5lI8OZFFMibNKxcA6H2jqWlkzUbWbGTN48uarIqE",
	"2dCnhvl4PrIds1clf2hUI83z3jzvzfP+4zzvh+mSG4LZ8BsNv1F8p8ork981yrkGXx9Pm8xqUCc3KNug",
	"7KPok8kSO9Dr3gvuyyzRJVo10e3PL4eqPkeAxBHZKMfl7OeymKrUS5nLNCCulvpJtq1gRYCui8Vw0BtR",
	"MTbXCXvTh0MMcDhNNyhzJdRGVdXYfJCskYuhkDXMjMVN2OSoFpVomjqqNsh9yUTLCBDZtAgOnGKH5QBB",
	"fX/mVZ1C89E6XG/OnrGHGCc+6mzVTnO2v9/0WGiQnqk6DsCwHMD+TjORQjdiBjApimABpKDhS6Ia+7BS",
	"u6gCqElQ1MMCVrG2x8aocKo6CEwGwKJiJpXQK9+yfZNsdmxYqeqLNQJHVa8pDxULiBQyZy+gqqWJf4yQ",
	"CzorjO7ROs7qZGsew3axGn1V8aAVjZaJEodVkol2l7ejdRr1a0Vqux1cYk8gFyBbHq1a65FX8B4B6FEE",
	"3R2YI+QDtqUbyBhyTaV9MOtDxmPAza/BXwGgLE5Xc6GaoMAVSibJvkdDjJCHzd1DyKY/WqVcU4y18tsx",
	"LVh9fV4llZ9v4f4XXUG/reqc7R6xypllcbPGyvq9FEW3Lym+rLOWeFOr6viWc7pFshbZijzIKwIWmLI4",
	"73EKPHyH9M/X41P9rwm8R3l14sSAl6Ily2c5as5BEfJgbeJziP1qFbQCS7xML6GYJzcGkjMbwYJsffcT",
	"ZpgXyFupdo3+9/npf+VZgntxSBba3w0iGw8dkJlnheK5l4O3S70USeQZIcqIX7m6yEZ2B71OrATk+w8/",
	"n4L3H37+xcRZyj7H9Cy4ULRBceSSNknc3oEHGCSLVot4xYBYFHjAfAWg4whEAITKv8mWG+VWp7wcdDzG",
	"5Zjc27Lu+rSNLdH2HRpJIlCtEIK67TEao655FpU5d1bQz0th1FZ+Z1dwjYKS2LmkYj9J3fT6+tebm18n",
	"k98NB7GV6ZzdCfYdZGcCF+1/4nhtlcvuiTi+Z1qr9TkSx4YEHIkEvGJA3W/gkaUdPVhQhFrLXH+Dy6hJ",
	"ATF4tIR64rIR6qprzggVmHwKIHM0H04oEB3UX0ZtuSuJpqWaglA+FD1MdeWfx0V7eVgfYpfgnitkxBQI",
	"DGCAnhYYzxCkzsqI7RP1uQDTB+IEg2sHtC0jC/jif8dWFD1PttxYGj/T955ZO983mt7vXr+edKeUYrVl",
	"yX/RNhWfYREtjRlnJrr+eYX4StVC9wmP7jxmOjIjN9CiPGe08RBHUpHkEH+B6Rq5Uqcwx2RJ4WYlHctc",
	"yKFRDUwFmNySM+dtE1BC7rBpo+HHOljAJsqpRl3tc+T9H0c6ew6cuWIktAiob9N8JwFtx6j8EbzRfz6i",
	"btC2MJvaT0SVo+vw84eff/nw11Pw8/v//Mtffkmo/JNu8MH2HismqtFeNtrLRnv5orWXEUk8hw+QujkR",
	"POLzd0zMfnCEk8fLDtSVaRQqi3lM6sWN+gPx9cN3gHnKMTZGp1m0uJ7v4nvsbqF3KsXIU9CGFCGqChEW",
	"UfFpjk8l00YH81asibrBVfiFP0qPW/fmWQtuT5zFweRpKXhustkQJrg3juD6DNxsGRf0WVp/JAMnlS89",
	"U0WnoPtU6l4ebaEFqxlpJ9FD1yOVp2ShY4FeszdyNeov4JGlvIXsDMQung4bil+9KJIo0wM3/Fo63Et0",
	"tKUdRYG/BjXgoRB8TgqyCeZbdfEc4iIt7y7xPfLlOQK28TA3+ZszzNvErU1D3lsA+VyAJeQrRJnCJPCw",
	"QhRJLRpZSKxnwZqhBxyKOaIYyrQra8TPQG8BFtBj6FS/AKlh/J3dMB20gFuP/6oGMwDAIes59tEEF/m9",
	"7cNdWphdyBXMqbT7kYXUDYLX6z2Kg3xXtn4TPeM3N+edzvmXL1++mF9jyjsHl5fr6qntFsrCjZVZKvLd",
	"wxc61ucd6KYWlKzlSXuQcfDqt1fAhTsGXkvYC6opG+wQ44i6cPfmzFihb8cuoHN36L0vXp8s+KZYXGOQ",
	"h2xTx3KeytVCc6YyvNqEDvdBZFDpF6B7f2BQkQcZE7JZpHLD3FmB1wvI+Bx63ilwtvQeqX/Kyt3G0t2y",
	"p3kb9Xj0QiFBaQZ4hTl47WEfAZfie3QKFt4O2Kx0hXk0UnmgXye6V9R3i9cGu0jvgxufwjnkE+yicpxv",
	"gHWqOGeOTCCuV56IE3wvD6Qr3VM9xZVgJIUK/Z7Nd2DUb33pjk/BtNu6OQWTbmsyHJyCT93BbfcUTEbD",
	"8RQQCibT1nR2NR7ejvKknIsKx36lOh6wocbB6eXUexRYd4jORjNi1TQ28l6e/6ECTsz5MpWQY+3/+AIU",
	"OcESdTDOR7QDY7ShiKHgglwpm1TGmhS0aldqfocal+bOH+fOv2KqSushN78oiYpcZJRJpdHcNprbRnPb",
	"aG4bzW2juW00t43mttHcNprbRnPbaG4bzW2juW00t43mttHi5GhxkLOlmO+k5mQOGXZaW746+fUf/xLA",
	"niNIEQ1/+Vee1keyoPvpYrP1PlQ8RkVFGEfJZkfKKJKYpa6ii8GYNulExMOjWHMjIKImTfqYww47gGRt",
	"iZIlw+Hosyk45QJ0j5o0p/z8kgTpk06ynBbX24Nc0AKWZ8HSLY6F9HqC+irKhuvN3fcOUZU5toC67bVs",
	"0P8Zor8yoDB5TDYEjzCcnwt+FLY4EhwuIJOiXzBRXfgfW3fO/inZMHkLzjcUudhJA8M+MnCJuAT/T0oF",
	"HxsOzCFDLiA+wP5mywFzkA8pJvvRgleIj8SKjmou2xf+eB1a7DrXJKl4jYv6JLN9FqqEdbLPg7MDHVXu",
	"voa+i1wfMRaqUowTyK+iQ7kpgqsI4HxO0T2WCBqd42RyCkan4N1FMVqFl/rR59eAsVpA9QpG5HiS21Ul",
	"ehIKdDFqZkHxzqH77y3jT074WmoZluTPzvcmMzfugd4BPxLGiBuIHvKKJ41li54qxWVzcsram/FEvPv5",
	"3Sl49/N/5Oa0Dc3VjxITWsaSf2D+raNqVO0VqY0Cr4QCr2qGY3FZ1c1K17BTtynzEo61v4jpLo4TrRoB",
	"7fkJaBTJ9N765Gl4UmYRhRKyyFdJjcMWx6pXpieoDQiELCyUMpQwXqR9HsfaHG33wRQ1iaZqXzYA2Hpo",
	"grjgaXIgEG90LBDE5qiGBJWZmghpkvvMg5rvI9pBHGKvAHn2Wh4NfsmJqiOS2hxw5VAWKCRW4G5zEqFL",
	"A1HQSj5FZ6AwAVLQfp+RnwTzVXx8uOaBHOgh34U0t1RU0Khipah2oru9uXVDkQN5xOKV25n0xGBn4J/b",
	"t28/OHP5PzQgHP0KOsR/xcEtQ/oIHrDnibc3mlJwgQt4T2gcRnL9arhzPV6RF8gjQqs0bHKPPMC87gE7",
	"meyPcVBGxYOkGb7v0vqoeSCr+WgeeYl1ejI/DjQP1EUcRXJ9PvWCTB7XPvF/knEoha5rT5MrtZze+FlU",
	"pBMgFTRF09LQx4GZc/GpBs8kjS6vWwnCnsSv7PvwjqsaNlN/2tiniKfpyHLiwRnu1+QwOjcf6nbduLLX",
	"78p+yxDggqkOxZLIOVtwFT7csBXhQSiD3AHkKqxBKcSQCzhOY8LNTaczu76+uZlMTAweXiOHFFv5Mou6",
	"MNSHHDFZOaZsQMSR47F8+So/5pOhvP3BZjv3sHMqXzr1b0CoVBFIR/7ofEbq4yV0xE7/Bl59eXUKBsT/",
	"ae/D4NUpaHme+GfrlemhlJ1UH2vF+ijW6XtXrhtxGPvLEcX3kKOu1inY2EmOVpwwEP+qxE8nFCWRVS34",
	"WTy38bKEoTYkUycj3352zrGAQuVc1BjpUO5AJxNech10FjzPSUXNFKOAqOQqal6QKPads5SPVgeosfbV",
	"STeuEBeX1E3dUnsqsSGM62OtTCWiMXJ0t6OwUV1a3Bd347KvFMWIqdi+mvzR6tYYHhwyXajiqJwjoAa2",
	"1jDEJYJ8S5Gr9Wvlx6iS76HhQRuSb0XyMyhuFZJ/rqjPo1P+iZq2of8N/a8zR0yjUnvRKrXv7DFvXr1s",
	"hmHvNTjw/ZME9DDR55xvfdQ7tgQ0VZM8ghPzSybiB5m8m3v6zLhThfNVbien0LkTQsV9qtJ1yauZ0lzq",
	"UbWj1P4dTcz6I/ibNd5ljTtW447VuGM17liNO1ZjO2vcsRp3rEZ31LhjNe5YjTtWYwp7psqGg3IYJDUA",
	"VTQTf8Qdsv587Ni3d4U+VUEpiUh5kVHIIr6HGipAxEZLsSAaq+phFJvAvSZwrwncazRFjaao0RQ1mqJG",
	"U9RoihpNUaMpajRFjaao0RQ1mqImcO97CNyLyZ/G4qdZ4m6Tju+AHFp7EK0rG12IGkklRnFOLTsMOGpi",
	"sRyt3iEZ6kKQWABjLyVlWe+vkPVLwc8ui+Xjc7pPXGZ1jDjF6F5yOtplDkFnpcILuRI4sqYX3EEgWQiu",
	"jDVFnGp5lBSaVnqTFOqm0r+qATMv2Tn0vEoXTSYbhdFlS1Ql7eB7zDDxTwPNIqFgovE4eSVbnmd5K7Ua",
	"Jhi6WBPj6paP7hNdVwnahio0VKEWqgATb6INVfhD/aPn/nm0V/hdtWc4ZdDUyzwsO0Hz4DdX+/t/8INK",
	"2vlFuSZRufAfQrasjRgUhxxBjpa6BjDjkGPGsRMpHnMtA6K9LOTKzCpc1cBaHTUJexxRwI7jXG3CdaIa",
	"foEoebczY/rdrlGgPMN6BuxuB8imuNAaI5TfEFdy4mZ61louKVpCjiaEcqnPOBIsEhPVqkzikIMQIXLg",
	"IXiDQ7Qmqv8euxb8fBSdyQ8TqGmwYDANdsBXkIMVvEcA+0JydbcwUXvRRPhXkE305zKc2KUHl5LvWyDu",
	"rLC/TKwDUgScLaXI594OQIfjewRef3lzCrAf/DV4cwo2yHdF39ejN6eB4YUjuGbg9cUbY7lv0V9V/bR/",
	"rMTiWrGe2oBSNyMmYVAh+FUDT7BhAu1UdbiQG1M3KOOynv+hGfo/j3Rt39WWiy8ldx2nYFZDRRoq0lCR",
	"6lTkHHqebHchCEX12otR3V+lHLjpX4C5GjJLgRub8UWRm5CS1Jf28gWmZkFkUynhQ6vfjyGGxJPgCEvh",
	"rEa06i9gGlsDKwTLtDjINY30nM3r+LyrRD7t83ahPoF76G2RQDfFLuzAAwwcujeIMuK/YkDMpNyloOOI",
	"PYqXTPxNttz4hjnK07lRoT4dFdsnHhLX1LUvImUcSs7lEKE7HGKPTgVf3llaRp8miOMp6JTqW6QwVdDL",
	"I1d7jcqqN+P9KzLwT+ZY/HxSjnUEYq+xjxh4WCG+Uu642He8rYvAGv6bUKCQVosFDyvkg63yWV0h8Ori",
	"y2w4vmoNer+3pr3h4FV0q/KMWXqCm/5FQ4JrKl2sgF7JjhWemCLC6rzj9DcklNkk+PyPxG3+86gk2Toa",
	"tyqhSvGTCTpzkKm7eSuat6J5K5q34od+Kwq8rNM3/Tim8Vx6UNZAGMPgAiMhh/xSoUbO/oMmx9u7muGR",
	"DKOR80TenkP/iqPtWbtbHLznZbDS/D0Xojk/NobzWpCbW+K1AxkfEYbFmMV73299RDjEJ6vTL0CMCzZ6",
	"YEsw5YOFvbdmbgMfpliYXS9Uy51KbuEUtCFFiErGoNDDqYD/4qyGnDVmpDSmc1D6xSy+5+cPP//y4a+n",
	"4Of3//mXv/ySx/0oPWFtrujPgBMzcTbxFUbRpix3LY+bbeCYfnhL7YNXA5pmvxbPIeXAIRr9RzfxP0W2",
	"gCd27zbm08hcFrNeF3tpqYnqJ2tatiwmbMF6nhBmklOwBJxomwJe3i3vh52Y6aIP4FqSoDXiFDuv2Rsp",
	"ram/gEeWymB3BmLUSX1M0Cf9k2Ht0deS9PVGdizLCDxhXqe8BA5zyDmir5jUeBhWodpMHz3BWN66N5g7",
	"q6KF60bTp0qNVgv3p6BfX5mUWjhSBdjDFzVJ+OMnPTCE8MY2HuZnppclCjep4+HtLYDkt8AS8hWiTBEZ",
	"8LBCFEmhSad0CWMIoAccijmiGEp/tTXiZ6C3AAvoMXSqWcLUMP7ObpgOWsCtx39Vg5nyVpL1HPtogvkz",
	"y+kiuk8rSgpP4Ql5ARmaRxoDAhihGvkYmO+MCEgoF9y29dMXzCOFZdPjNxVnQF0kc3OKKbC/PAWQOdrV",
	"kVAgOqi/TIcg+tv7NhLKh6JHvisN+OdJq9//54lYAfG9HfjnyX/ftvq9y16388+T0BMizGay8SBHAG42",
	"CFLoO4iZ4Kh6jgjx7BPihF1Maw5UJsCXpRJjYu4peH8KPuTSN923PHMQnHAwe9VAsiZzV+2ZuwJ/MIrY",
	"1uMMLChZS4LnQcbBq99eARfuGHgtYS8ummywQ4wj6sLdmzOjiWzHLqBzV0NgbcH6ZF4qdc/csxyWsZbl",
	"dL9KsxUL7/XDiij/OYZ9B4E5Qj7gFLrIjZaK/c2W57FkSI06lf0iT8oyb5egj9IAr+x3CqMU56DTsDHE",
	"/0vhnPh5A5fYDzyiM4nlYsEQPxReqiKrwP3gAEO1kEl6EmJiyWnrt6XxqnY0zpJmswwPN87OoQ+9HccO",
	"Oydbzlpzco9a94jCJTKqkq8QH6bb7umVc8WlA11nD0m/15hw60W7g1L3C5QDUOARgAqRQi5XB5doAbgc",
	"JrMNhbv2ClKeh8OTqFWDvQ32Vig8IXOGUrgDjsAilSuwFvzlxEO+YFVHlMzhHHtyjTmonNnhZWD1IfHr",
	"5Z3UjocJmwjySum+wjzEBqUyEb8IxtsGG6SxSZyG6dTV9yD0obHqNlbdxqrbWHUbq25j1W2suo1Vt7Hq",
	"NlbdxqrbWHUbq25j1a3vSX3xKXUaQ3JjSG4MyY0huTEkN4bk521ILni6ogd4QzZbDxpfVBaP+Ksxli9/",
	"fbJX+L4S/wwIFs0nsY+YKZbzVLZRv7mK/5L7umhNem3V711mN5kwCDNVxk11jIbKe8nVlsrkUtZAeDbW",
	"fW0csLfyewi6eZl0++r7ezubkRpNa2VxlYj5kVSu61lLFa40r+fqkQuB2qfqPjiI1DSbldI1mzpvoO+W",
	"X2RX9jscTFW1pk+n6syzcNVq0arxAanzDazTLPVkZqV61dBPqEQ+rlr4iKKb6RqVslhFFyh/tSodbMn1",
	"ZuSQNU3y+MLjURRyjxUlUFkOrVFSrFeuq1kuM5qnL3b21lzVPh9zn7f/lqZJiskkPofYR7RC+kfN9Aap",
	"HwPHARt+OTBTmfhlZY2ycr55xj4pta6JHS2PWGPXeXGuRj+Mx9mjuCY9sitS4/BzfIefF2MKtF5owWoU",
	"paxhPZFJ2EUcYk87QymO/xUDMa78WVp8AtIoy4eblOdB0fIKGpqwa0VfSw8yhhfYCe+DfJ7A6wVkXGz/",
	"FDhbeo/UPwXFPjt7k/ewmbdRh0F3SqHgCTUFXmEOXnvYR8Cl+B6dgoW3AzYrXWEejVQe6NeJ7lVN0xww",
	"7CK9D250/5pDPsFlQ0Wuoe8i10eMhUdqnEB+vU7rBwunMN3Me+RvTdYJ+e1xvYQe18vtQFbkxXm93WAf",
	"r7frqKzCAnscUWCkx2vsfxJtDYI82c69mCivTPyZE8OvJSeGX2uZeOh7u8AeqYPYgpg2vsIMbBB1BPw9",
	"dBaZKueIcYAWC0K5fLmYWbjSnes6GOKoyCQHsRiUtpu8AxpGfQ4WDBqb7vP2AHqyPNSNJ0z9njDPN6ik",
	"8Y5+7JV/Rz6dmQQIzbfLfAejFxhmLL09NG9q7ezBEKTOyqi7vkCQcSvV9cuOuytxB/Sd3mjG+Q7tWC6X",
	"fDxdd9EKPbizCGUSzXpuXaqyZ6W2q/tFeyxvoWfCZVWcuCbGqeLstfBC9RlHniJA8KBlJ3iOF7f6OKvH",
	"ngPH9KKCcmvfhEamyfewF4Vaz2krLyJoua7Fa1Tqv+Q9KBR6jlvYi8M3bcHF95jhGn04Hnf5Gos6L3sX",
	"Co+eaBM1Mhls6L9oPuNp1m9SKwV27dx4ykde60uMEa0K38Az6yUgQ+Da9hLW6sAXBNgFpoxfQIbW0H8Z",
	"K2bIIb77opbMV5i+rBWzFaGccbJ5Gcv10ELFMb4YGoF8juiLWjLFy9XLAjLd+r4AMmX8JS14IgncS1rx",
	"VNC3p+GKPyHfJh+b9sV61BU+glvacf3qjuIuWSWgOnS1rMrUs63HA/89vQe9fuh5Mtac4jtktYeccLTC",
	"PYi+j+FZyx7ftbYu12X2ZL7LB+9AGVhHT76RKm6KEj0nG4Tcp/BVrHH2CnufbLA/Npvgjrrz2uausO/u",
	"V458lg4XeKSN1zd5pZ1j/gl5xMF811pC7DP+NDCofxkVoNGHW99Ztfylh54QGEdYxYGY8dQo8cS48MRI",
	"8BS7vyZrNN76Hcw49J0ngUDdS6gCBcyfFAI1Tl9l99BfTvH6abZe19zVTj1ZX+UpDr7OFVSAQRtyZ/XE",
	"UKh9DRXg0OIcOndP9grUOX2F3V9A/mSSUG1zV3/9fruAnreB9I494ftX3yI+rxBfiUkp8AnX8ryOhEIu",
	"wD6A4P+y93xNjePIfxXVvMxQFcjuPk3xq98DDAw7dzDkSJg5Hq6uhK0kXhTLKylkUhTf/Ur/HCfYjuTY",
	"SRz0Bo7UklrdrW6p/zxCShFGoQynLZhbxM5lK9c8n/XH8FZKSlhHFO8OA8n2MKxOOubrVOyPc9C7Pnu4",
	"vOuAweXZTQf0L8/6t9874Mfl9/vLDuj3bu8GggT7g7PBf6/ubu97ZZED5xXCtJdyI1Xa3mYWJKYKKbp9",
	"Xgnk29Ki9i4pekLRMPoFJiRcDrBS8+KQnwAAn0cdMIniDpjAXyfg28klWLFN5S8Za6kj+ixrzkXLutEj",
	"Wy/tbDSiaAQ56hPKy+Le6oj4ZCaGs76oTx/EvK1p9DDk6GzhBrXLuXyL4yge7W4Kf08hlnxWx/XuPhU1",
	"+ULwdBJnzn7ACYeYFXuSzAamgYvm1B+TmXruYirWOJ5iDMpzU0SxTMz+fYrxTU4xpvWD7nsiciFioSy8",
	"qitCqDcqRQqjpcgjiwoRkJ9DrrS6rb6MD9Jn2BoWIQHtYBE+5tjO1kIURAxAk642lw4zaWk3z2jbQCi0",
	"Y6bOzUKilQYuq1HoaGfruOhuQOJhNCoMjxbd+7LlF9XQLkg6QvItXB16KueoOnbM9PLJFMvgkWdk7+z8",
	"ddGnSJvbclJCy/DsJoguu1GOGWIlmQAFACgI4DIOpRWdoaabiAUlxKRtUeVRsp6krrLN956wNinNXdVk",
	"tdk6WSZTY15RsP2GSZTbbFVPNXy3m7SCiSx3Vd2yDEpABqvWe6cyYKzfOpfkFge9c+KvujduNQ1J3p5R",
	"BJ+KN+oK8b5uYlVuRsG7pSNrXN9mwoDLCwUo2G+usSzxbPrWUDdGgkpg7HCymi7rqiuIdm602l/0sQE+",
	"GFPExgTXVCcgip8RZWitYl2YqEJG8eG5o2beqNbUSGGgfagsv62MKVWTUle/xGkom3oLirA3fbVRY+rt",
	"hqe6qbUupKOjGNrRC+LBlvzdMLS6QWqr3R6WOtVPCpNkW7cwRotb3L2oL3n6YJevMZKlKqHPH1fEwDCM",
	"VFnvHhVweaS6rpISKdCEO6sNbEsx6sUt7BlAEhPbUIoVcTRksbF6/RsxgPR1BIAYkxkDczKVF+1TjIHq",
	"3llB4gBZ2KyN1XfYcU0FffSZHBrrD79F4pO66p3sX6LVg0w01KoMXF8xHMkTZ4h4MDblMpiqXwspAurV",
	"lOO51inAp4ejDohi89/3ow5ItH/Ap95RR2gj0IgA8On8qM4nAyFB8kvglemZ8pbAUtlsqkKh8iyhatpV",
	"/L/OFIANjJRDUaJq1kzkqVSlznEUD4lS1jInnjlV1Vn39kztwuEwwhHkJcrGWdrkd8v6bW3LG7njs7g5",
	"HaN1J61n/mrML5gGwDgEKT/bi4BxxKQTbyH/Yyz7ruX+NeqTlArrlacd8H95OYW3ZRS02QIxnh+dgMtf",
	"cJJgdAo+/vHb758/Co1D/nXyx8eyDMH9CgxdVkwhr4jC8kQN81jPE8Vhv3LZ9APlNMUtUQAxoCggNDQ1",
	"U1N925bv1r/QrWe5/ZXwu61q2WAVyx0rCwedaLkVhnZzJT9bXUKipfETe1ZSyld2qr+agUrCytI3IukK",
	"yccIYMg4+PjvjyCEcwY+SdyLfZcN5ohxREM4PzoprDBRtRZ+0974a1HybQgk+4MR5GNEmXYSnY0RRfIC",
	"QWcuYmZqEIOARhzRCMp7uAniJ+DbEAwhZqijJdQKmHhuB+YCDeEU81MFrDju6zGKUT/irj74rSkf/N7r",
	"/bXPinAoa7VsRUB9Ib3qIFZuLHQxgqE0BAqMhmv1+3qz4fyiWKMKEV34+1XITIcoI7GeyQb3wwdSveiA",
	"7KCigZzsxsUQ3rTaV5+mGnHnLbp2uUnuPkKm/gV4m8rbVFuwqVpjZ7z3vCvtszO0X4fSzd1iR5ftDm1A",
	"KLoUJGdtgLyod7nXRrzwmnEsSCAf57iXF9+A7tXbvfcP9P6B3j/Q+wd6/0DvIrQ7/0Bz7Ls5Crb2OPcO",
	"jN6B0TswtsyBcSGj8HQSRyWOjPLn92FqFA+9H34o7ilxWmm59xBJMKr0RKiPaQAN2a4yQudDQlgOnd8n",
	"IeTIU7un9iaofRWhdcXL2ov5gMBgXKKHftG/+zulFcAX0iXcqFNmnQ8PDw/HNzfHFxeFd/LurwXtk9R3",
	"hPFql6pCUmua1PfZgi6cNBfbGIzW0rSPDfGxIT42xN2ksfT4KkgO1gxn75vfWPXjsXglV1t2GstlsV/J",
	"agVfu9qrst/Gw9foxVnnS61KNtMjBDum9hVdym+9918s1fAEnD77msdgJ3mUSC6NES6USL20hde/vf7d",
	"Ev2bysHr9m1QS2otH5jbd4Wc0osQ1aTsBn7Rwo1nDoEZ/aNGqx81NpBM2q+AGkHgKpG6Lwu+eW1GPP3+",
	"TuXT8gyXxNMGt8leXHlx9R7FlUUyi/bKGe9d4ZOH1JM8xKd48CkeDq7Qa2sCX6wnumY2vbx81+0IUvKx",
	"cPXHwnk9dHfJESgMnqJ41CdDPoMU/UCUyYTiRZrooKhDQ/WFCsaro9CQkFpm/YBp+OBZL0g6U8aEr6n3",
	"lSJwzjia3M7issfGQV7jphG3GKs6qqQvXYoqCREQM/31yPmB4pBY4MW0axglapiasPGcztkGD5bctS2u",
	"0uPUhop01qW4iBkMTLWsUlwsN6yYPfUdnCJ2eiqKEYX4mpCnaVKH/NR7bzbJojhipvUm1SgyUE7exsNm",
	"x9gs4a5zPOIhhCPuURpLJ6e2bc57f8v87M+1tzeU6jCUcul9IeEa9+VcM36Jh1eNlc/TyPgdLHbjuytf",
	"RG3LXl6Z87+Se1dGo4niIcnaz1nVYkmxmcaR2EEmb/o3e2YGGpaSP/pKS0BdVXTu9Zjn8yv1cyVVRx9k",
	"CY0EEsATmpc9UvSemN39uCtLevq2pW+z7WLTKxG46Ag0lFUKN8ALqFte7dZO3enTWxF9D9SNskX15kV8",
	"w3ZotLnEd574y4i/coSBNCmciP8ZxVO0gbWq+69S9w/zeRMDVcK2sJBkO59Hc+9TDLXPVYgfRpLhrctx",
	"NSCzGpHVVGP8YKsub1Y4u1Lp/ygO8DREl8+CEh3z6fsszbuuXq0O3yr6gz5xlxUHfZbnqA3dF330vjak",
	"QNg6H8vWOafwsvufnuyWY5e9FuO1GK/FeC3GazFei/FazH5pMVGIyB1iBE/XO2z8yGvckDPDylhCaG7o",
	"0qAQI8ACmsLVOT7KvRqeI4KhDXqWmjWGmMwodaAEpqfh0jqtMDNDsjqaPDa7L+oB4bU7JBQFkPHuCyVk",
	"WB6ZZ8okQPCXONqGEUYgUNH70td4jIAeBBiw5lbZnAdi2LduIj9Vr6+6k6Ua3dPPJP9Ec3CHEoqY0MDi",
	"EYBAP8LkaNVq3XUr1UqjFxiUakpRVJ5CcOng5bFQGsC7vqOGSYKjQBJPV9Dh/wVjSBni/38/+Hr82V5i",
	"G2rTxPeTwiSxjTRzzAa34OIrxMv4xLCH4WI9NxtGfhEaSpltu4Z7MzOSM9S5x6XiU8ixF5DDc8hQeBv3",
	"lM7ZMsa9L3Edkh4mUbx48s2ZlUL6hjkbPes6sq6gtZ2wLYUztRspu4SQQ2uOXb2H6spJVOVY2XmJbzMH",
	"rRyikG/P5bgtvq3yvFESSBgFW2eOPFpMSbAabwynGFdlDdG3Gmd8FaN6xjhEfW+K8db5IocQndhiQKGY",
	"H6HzLyQeCjUlKLFqf5Z1asjGLRmzBqs3jW0wOORmnGhNeMMsisOLiKJAgS7C2FIrH9Syf0EtYh9BaLao",
	"5KZD8ip9zt+6HiXh1GzylOIPpx/GnCfstKuSfcAkOpngx5OATD7kJAFAHL7p94g4PLbo/K+zN13/tup4",
	"TQKIl/qedrtYfBwTxk8///b5tw+ZXOMvhlru0HOEZiwH4q2hfQYSRNN7GwIeIV9EjklvwAXxnUMOTIia",
	"hKm/n3GO4hDGAXIZST2CsQV49ZqXBdyjKIy0Y68DZHlnnAHcV/87QMjq9BkEGPmcmaKkOQfI42g07mIy",
	"S6OANZw/xfdrMnOB9Rd5zED4B3l06Wzc9zMQTFU8FzDCIM6AkFZ7no4SD6MRQBhN9JtGVfSRCQJ0GoMQ",
	"0ceMXPyTTJD4fCE/500AY5gwFALJI2m/L5gwJFSyX8ccjo5ValqhmH0YQszylnKpfQJUTkaV7oJxiuBT",
	"luL0BxeiXaYHlVrIoX/qj6AB6HcDBwjqYSsDQqU8dQEBZ5CGGQhn6v8Mv0g35x50ExXK0E7FkqynE0M8",
	"lxl0Mk9u5lvefooDz0kQUgLDALLsppybb04bG4xROMXZvenrTy50VwjfuIEvwKcesw5Qbq7Pgck8c0Hh",
	"kGfEgvzXAZZJy6f7q/wGLqiPyAQFYxjLlOOrh9DiR7bBpPocytw4TjACEg8RNUq0ESHpR6fpLMfDGlRl",
	"v7rQ2BPCiL9FVl9/d4KV+gUYIMo1wQHEJMKIcRKjJUmffnv9z+v/AgAA//9ruE1J9+gHAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
